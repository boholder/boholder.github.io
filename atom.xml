<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">BoHolder的网站：博客，小玩意及其他</title>
    <subtitle type="html">BoHolder&#39;s site: crafts, blogs etc</subtitle>
    <updated>2021-05-26T22:06:47&#43;08:00</updated>
    <id>https://boholder.github.io/</id>
    <link rel="alternate" type="text/html" href="https://boholder.github.io/" />
    <link rel="self" type="application/atom&#43;xml" href="https://boholder.github.io/atom.xml" />
    <author>
            <name>BoHolder</name>
            <uri>https://boholder.github.io/</uri>
            
                <email>bottleholder@anche.no</email>
            </author>
    <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights>
    <generator uri="https://gohugo.io/" version="0.79.1">Hugo</generator>
        <entry>
            <title type="text">译文：从源码中学习（阅读源码，初学者的有效成长方式）</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/learn-from-source-code/" />
            <id>https://boholder.github.io/blogs/learn-from-source-code/</id>
            <updated>2021-05-26T17:30:54&#43;08:00</updated>
            <published>2021-05-25T00:00:00&#43;00:00</published>
            <author>
                    <name>Nic</name>
                    <uri>https://coderscat.com/about/</uri>
                    </author>
            <rights>all rights reserved</rights><summary type="html">为什么我们需要阅读源代码；如何阅读代码，并尽可能从源代码中学到更多</summary>
            
                <content type="html">&lt;p&gt;这是一篇译制博客文章，原博客为
&lt;a href=&#34;https://coderscat.com/learn-from-source-code/&#34;&gt;Learn from Source Code (an Effective Way to Grow for Beginners)&lt;/a&gt;
，原作者为&lt;a href=&#34;mailto:nickmose8@gmail.com&#34;&gt;Nic&lt;/a&gt; 。
&lt;a href=&#34;mailto:boholder@anche.no&#34;&gt;我&lt;/a&gt; 向Nic申请获得了此文的中文翻译权与中文翻译文章发布权。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;上周我在和一位年轻程序员聊天时，他问到我：“如何阅读源码？”，我们讨论了一段时间，我还列举了几种有效阅读源码的方式。
然后他说：“你应该就这个话题写篇文章，这对初学者很有帮助，而且这种经验无法从书籍和教程中获得。”
那么开始吧，下面是我关于阅读源码的小技巧。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要读源码&#34;&gt;为什么我们需要读源码&lt;/h2&gt;
&lt;p&gt;我们程序员每天都要和源码打交道。经过数年的学习，大多数程序员可以“写”代码，或者至少是拷贝并修改代码。
而且，我们教授编程的方式强调编写代码的艺术，而不是如何阅读代码。
当我说“阅读代码”，我是指&lt;strong&gt;有意地专门阅读代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;众所周知，编程和写作有诸多相同之处。
唐纳德·克努特甚至引入了&lt;a href=&#34;https://en.wikipedia.org/wiki/Literate_programming&#34;&gt;文学编程(literate programming)&lt;/a&gt; 编程范式。
编程与写作有相同的理念：&lt;a href=&#34;https://www.coderscat.com/how-to-learn-all-pl&#34;&gt;表达我们的想法&lt;/a&gt; 。
还记得你在学校是怎么学习写作的吗？我们的写作能力来源于从小学开始直到现在的大量的文本阅读。
多年以来，我们阅读了不同难度的伟大作家的作品，并练习了多种写作技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果你没时间读，你就没时间（或工具）写，就这么简单。”
—— 斯蒂芬·金，&lt;a href=&#34;https://book.douban.com/subject/3888123/&#34;&gt;《写作这回事：创作生涯回忆录》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如斯蒂芬·金所观察到的那样，一个作家必须广泛而频繁地阅读，才能形成自己的声音，
并学会写出促使读者拿起书并痴读的句式和故事结构。
&lt;strong&gt;和读书一样，有意地阅读代码可以帮助程序员加速成长，尤其是对中级(intermediate)程序员而言。&lt;/strong&gt;
这样做有三个好处。&lt;/p&gt;
&lt;h3 id=&#34;站在巨人的肩膀上&#34;&gt;站在巨人的肩膀上&lt;/h3&gt;
&lt;p&gt;我们从他人身上学习。优秀的源代码就像文学杰作，它不仅仅只提供了知识和信息，还提供了启迪。&lt;/p&gt;
&lt;p&gt;通过浏览Linux内核、Redis、Nginx、Rails或其他著名项目，
你可以从全球范围的成千上万的顶级程序员那里汲取智慧。
在这些项目中可以找到无数的良好编程示例、编程范式选择、设计和架构。
向他人学习的另一个好处是能够避免常见的坑，大多数坑早已被他人踩过。&lt;/p&gt;
&lt;h3 id=&#34;解决困难问题&#34;&gt;解决困难问题&lt;/h3&gt;
&lt;p&gt;在你的职业生涯中，你终将会碰到谷歌都无法解决的问题。
如果你还没碰到过这种问题，这只是因为你编程的时间还不足够长 :)。
阅读源码是调查这类问题的好方法，也是学习新东西的好机会。&lt;/p&gt;
&lt;h3 id=&#34;扩展你的边界&#34;&gt;扩展你的边界&lt;/h3&gt;
&lt;p&gt;大多数程序员只在少数特别领域编过程。
一般而言，如果你不时常推自己一把，你的编程技能会维持在你同事间的平均水平。
不要满足于修补bug或在现有系统中添加琐碎特性的工作。
相反，你可以试着扩展到一个新的领域，持续尝试找到一个你在日常工作中接触不到、但你感兴趣的领域。
这将从整体上拓宽你对编程的理解。&lt;/p&gt;
&lt;h2 id=&#34;应该读什么样的源码&#34;&gt;应该读什么样的源码&lt;/h2&gt;
&lt;p&gt;综上，阅读源码是有益的。
那么下一个问题，有这么多优秀作品可供选择，我们该选择并阅读什么样的源码呢？
你必须从选择目标开始。如果不在这个步骤上下点功夫，你从源码中学习的效果就会打折扣。
这里有一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当你想学习一门新语言。学新语言可&lt;a href=&#34;https://coderscat.com/how-to-learn-all-pl&#34;&gt;不只是学会语法&lt;/a&gt; 。
不管怎样，阅读源码是一个非常有效的学习新语言的方式。我从&lt;a href=&#34;https://github.com/rust-rosetta/rust-rosetta&#34;&gt;rust-rosetta&lt;/a&gt;
项目中学到了很多Rust语言知识。&lt;a href=&#34;http://rosettacode.org/wiki/Category:Programming_Languages&#34;&gt;Rosetta Code&lt;/a&gt;
是一个收集同一批通用任务在不同语言上的解决方案的项目，这是一个可用来学习新语言的有用资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想了解一个特殊的算法或实现。
例如，我们都会使用标准库中的sort函数，你有没有好奇过它是怎么实现的？
或者当你要使用Redis中的Set结构，它是用什么数据结构实现的？
为了解决这些疑惑，你只需要读源码中与之相关的实现部分，通常只有很少的文件或函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在特殊的框架中编程。这意味着你对该框架已经有了一定的经验，
这是个阅读一些框架本身的源码的好机会。
很显然，了解框架的源码有助于提高你对框架的理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想拓展进入新的领域，你可以阅读这个领域的经典著名的项目的源码。
比如说，如果你在做Web开发的工作，你对分布式系统感兴趣吗？
如果你的答案是“是”而且你懂Golang，也许&lt;a href=&#34;https://github.com/etcd-io/etcd&#34;&gt;etcd&lt;/a&gt;
是你的选择。你想钻研操作系统的内部构成吗？那么也许&lt;a href=&#34;https://github.com/mit-pdos/xv6-public&#34;&gt;xv6&lt;/a&gt;
是一个好的开始。我们处在一个许多优秀开源项目都托管在了Github的好时代，请试着寻找一些这种项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记住，&lt;strong&gt;选择与你当前的编程技能与知识水平相当的项目。&lt;/strong&gt; 
如果你选择了远超你当前技能水平的项目，最终你会感到沮丧。
读一些相对较小的项目，接着读更大的项目。
如果目前你不能理解某些特定的代码片段，这意味着你有个知识缺口(knowledge gap)。
把代码放到一边去，试着读一些相关的书、论文或其他文档，当你更有信心时再回来接着读代码。
我们总能在一个模式中取得进展：读（代码、书、论文），写，更多的读，更多的写。&lt;/p&gt;
&lt;h2 id=&#34;如何读源码&#34;&gt;如何读源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095&#34;&gt;《How to read a book》&lt;/a&gt;
是一本指导人进行明智地阅读的书。作为初学者，我们值得投入时间和精力去思考我们应该如何阅读代码。
&lt;strong&gt;阅读代码不是件容易的事。&lt;/strong&gt; 光是阅读源码是不够的，你要试着去理解他人的设计和想法。&lt;/p&gt;
&lt;h3 id=&#34;预先准备&#34;&gt;预先准备&lt;/h3&gt;
&lt;p&gt;为了更有效率地阅读代码，你需要提前在手边准备这些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个你可以熟练使用的编辑器。你需要拥有快速搜索关键字或变量名的能力。
有时你需要查找函数的引用和定义。和你的编辑器相处融洽些。
为了更加有效率，试着学习仅使用键盘操作编辑器。
这会使你专注于代码而不受打扰（译：指额外思考编辑器操作）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握基本的Git或其他版本控制工具的技能，这样你就能比较代码在版本间的差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与源码有关的文档。文档可以为你的阅读提供参考，尤其是设计文档、编码规范等文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有一定的编程语言与设计模式的知识和经验。这对（阅读）大项目是强制性的。
如果你很了解一门编程语言，你也会了解关于源码组织与编程范式的最佳实践。
当然，这需要时间来积累。要有耐心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流程与技巧&#34;&gt;流程与技巧&lt;/h3&gt;
&lt;p&gt;阅读过程不是线性的。你不会就那么一个接一个地读源文件。
相反，大多数时候我们会从顶到底地阅读代码。
下面是一些更有效率阅读代码的小技巧：&lt;/p&gt;
&lt;h4 id=&#34;结合上下文阅读代码&#34;&gt;结合上下文阅读代码&lt;/h4&gt;
&lt;p&gt;当你阅读代码时，请持续提出问题。
例如，如果一个应用有缓存策略，一个好问题就是：如果键无效了会怎样？缓存中的值如何更新？
带着这些问题阅读代码，就是结合上下文。或者说因为你有了一个目标，你会变得享受阅读的过程。
你甚至可以自己做一些假设，然后在代码中寻找验证。&lt;/p&gt;
&lt;p&gt;你有点像侦探：&lt;strong&gt;你想发现代码的真相，代码的逻辑，代码是如何像故事一般上下流动的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;把实例跑起来并与之交互&#34;&gt;把实例跑起来并与之交互&lt;/h4&gt;
&lt;p&gt;源码就像乐高积木，只是已经组装好了。
如果你想了解它们是怎么组装在一起的，你需要和它交互，有时甚至要把它拆开。
阅读同一模块的老版本同样有帮助。从Git中阅读版本差异，试着弄清楚特定的特性是如何实现的
（修改日志在这个场景很有用）。
举个例子，我发现Lua的第一个版本相当简单，这可以帮助我了解作者最初的设计理念。&lt;/p&gt;
&lt;p&gt;Debug是另一种与代码交互的方式。试着在代码中加一些断点（或打印一些变量值），
然后弄明白打印到控制台中的所有输出。&lt;/p&gt;
&lt;p&gt;如果你对代码了解比较透彻了，试着对代码做一些修改，重新build并把它跑起来。
最简单的方式是试着调整配置项，去看不同配置的运行结果。
之后你可以试着添加一些细微的特性。
如果这些特性对其他人也有用，你应该把代码贡献到上游。&lt;/p&gt;
&lt;h4 id=&#34;了解数据结构间的关系&#34;&gt;了解数据结构间的关系&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;“糟糕的程序员担心代码，优秀的程序员担心数据结构和它们的关系。”
-Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据结构是一个程序中最重要的元素。用笔或者你喜欢的其他工具画出数据结构间的关系。
这个图就是源码的映射。你会在阅读过程中时常参考这个图。一些工具比如&lt;a href=&#34;https://scitools.com/&#34;&gt;scitools&lt;/a&gt;
可以用来生成UML类图。
（译：这个方法用在写代码中能节约翻Model声明文件的时间，推荐用纸笔，不占屏幕）&lt;/p&gt;
&lt;h4 id=&#34;了解模块间的依赖关系与边界&#34;&gt;了解模块间的依赖关系与边界&lt;/h4&gt;
&lt;p&gt;大项目中会包含许多模块，一个模块经常只拥有单一职责。
这有助于我们减少代码复杂度，在适当的层级上做抽象。
模块的接口是抽象的边界，我们可以一个接一个地阅读模块。
如果你在阅读一个使用Make构建的C/C++项目，Makefile是了解模块间如何组织的好切入点。&lt;/p&gt;
&lt;p&gt;边界本身也很有用。优秀的代码组织得很好，变量名与函数名的命名风格体现着可读性。
你不需要阅读全部源文件，你可以&lt;strong&gt;忽略不重要的或你熟悉的部分&lt;/strong&gt;。
如果你确定一个模块是仅仅是为了被解析而设计的(just designed for parsing)，
那么你已经大致了解了它的功能；那么你就可以跳过不读这个模块。
当然，这将大大节约时间。&lt;/p&gt;
&lt;h4 id=&#34;使用测试用例&#34;&gt;使用测试用例&lt;/h4&gt;
&lt;p&gt;测试用例也是帮助代码理解的一个很好的补充。&lt;strong&gt;测试用例就是文档。&lt;/strong&gt;
当你在阅读一个类时，试着把对应的测试代码一起读了。
测试用例能帮你弄清一个类的接口，和该类的典型用法。
集成测试用例可以让你顺着走过程序的整体流程，适合输入一些特殊值并debug运行。&lt;/p&gt;
&lt;h4 id=&#34;点评&#34;&gt;点评&lt;/h4&gt;
&lt;p&gt;为什么不在花了不少时间阅读一个项目后，写一篇代码点评呢？就像写一篇书评一样。
你可以写下代码中好的和不好的部分，还可以记下你从中学到了什么。
攥写这类文章可以帮助你阐明自己的理解，也有助于其他人阅读源码。&lt;/p&gt;
&lt;h2 id=&#34;一些好书&#34;&gt;一些好书&lt;/h2&gt;
&lt;p&gt;我发现阅读代码是一个远超我想象的广泛话题。没有系统性训练该技能的方法。
总而言之，不断练习，找到你自己的方式。下面是一些帮助你提升代码阅读能力的好书：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/&#34;&gt;《Design Patterns: Elements of Reusable Object-Oriented Software》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/0134494164/&#34;&gt;《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095/&#34;&gt;《How to Read a Book: The Classic Guide to Intelligent Reading》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啊哈，这本书对程序员也很有用。&lt;/p&gt;
&lt;h2 id=&#34;译者的话&#34;&gt;译者的话&lt;/h2&gt;
&lt;p&gt;这篇文章是为苦于不知从何开始阅读陌生项目代码的人（包括我）准备的。
截止撰文时间为止，我认为这篇文章是在同话题中较为务实的一篇，
不仅包含理念，还包含不少具体可实践的建议，因此我想把它分享给更多人。
而且我想如果它有中文版本，愿意读下去的人会多一些，我也方便向周围的人分享，于是我向Nic申请了翻译权。
我把标题改了改，这样搜索“源码”“学习”、“阅读源码”都能搜到。&lt;/p&gt;
&lt;p&gt;这篇文章对我而言，最大作用是帮我突破了“不需要有意地专门阅读代码”的心理障碍。
我一直以为既然“写代码的时间中十之六七都是花在读既有代码上”（语出《Clean Code》），
就没必要再花时间专门读代码，我大错特错。&lt;/p&gt;
&lt;p&gt;个人经验：驱动我“专门读代码”的最大动机是好奇心，和小孩拆小物件为了看内部构造差不多。
学习OO设计模式，我建议阅读&lt;a href=&#34;https://book.douban.com/subject/2243615/&#34;&gt;《Head First 设计模式》&lt;/a&gt;
，这本书超有趣，比四人帮那本删减了一些不常用的模式，但是你能轻松读下去。&lt;/p&gt;
&lt;p&gt;阅读了解项目代码是参与（开源）项目的第一步，希望这篇文章能帮助你参与到心仪的项目中去。
这也可以帮助你在工作中了解同组同事的工作，而“了解同组同事的工作对工作有诸多潜在益处”
（语出一个高级程序员的博客，没找到链接）。
来吧，花点时间挑一个看上眼的项目（或者就读你手头的项目别人写的部分），
找到你最感兴趣的功能，读一读它是怎么实现的。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/programming/" term="programming" label="programming" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/programming/" term="programming" label="programming" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">单元测试的不同方式</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/unit-test-methods/" />
            <id>https://boholder.github.io/blogs/unit-test-methods/</id>
            <updated>2021-05-25T17:37:03&#43;08:00</updated>
            <published>2021-05-23T00:00:00&#43;00:00</published>
            <author>
                    <name>BoHolder</name>
                    <uri>https://boholder.github.io/</uri>
                    <email>bottleholder@anche.no</email>
                    </author>
            <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights><summary type="html">对运行时间的测试，基于用例的测试，基于特性的测试</summary>
            
                <content type="html">&lt;h2 id=&#34;对读者的知识要求前言&#34;&gt;对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;h3 id=&#34;要求&#34;&gt;要求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;掌握任一编程语言，明白“单元测试”即相关概念定义和作用，写过单元测试。&lt;/li&gt;
&lt;li&gt;王婆卖瓜：如果不确定自己是否明白“单元测试的定义”，
请看&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#41-%E4%B8%BA%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95&#34;&gt;这段解释“为编码测试”的文字&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;在本文中我将介绍编写单元测试(和组件测试，实践中这两个概念拆不开)时可使用的三种调用-期望方式，用途各不相同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对运行时间的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：调用被测函数，并记录调用前后时间差值，计算运行时间。&lt;/li&gt;
&lt;li&gt;目的：测试运行时间表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于用例的测试(example-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：写明特定的桩(stub)的反应(mock::given&amp;hellip;thenReturn&amp;hellip;)，
写明调用被测函数时的测试数据，期望(expect,assert)特定的输出。&lt;/li&gt;
&lt;li&gt;目的：确认模块对特定输入的输出符合预期的特定值
(包括对被测在运行中调用桩时传入的参数，和对调用本身的返回值两方面)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试(property-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：基于函数与调用者的契约(contract)，生成随机的测试数据并反复调用被测函数，
期待被测因没有正确根据输入修正自己的行为，抛出被测逻辑中没有考虑到的异常。&lt;/li&gt;
&lt;li&gt;目的：测试被测函数是否满足契约。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有研究（没找到论文链接）显示，人脑对信息的记忆和理解不仅发生在接受时，还发生在接受后的一段时间。
我打算先介绍运行时间测试（很短很容易理解），再讲“基于用例的测试”（我们都熟悉的那种），最后试着让你理解一个新概念：“基于特性的测试”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章结构是头轻脚重，篇幅比例是2:3:5，运行时间测试这部分的存在非常突兀，但我不想把这部分剔除。&lt;/li&gt;
&lt;li&gt;标题包含“单元测试”就是想说明，下文介绍的内容都能在单元测试层面实现，并指导编码。&lt;/li&gt;
&lt;li&gt;“基于特性的测试”在网上有诸多争议性观点，我试着对其中一些给出基于自己理解的解释。&lt;/li&gt;
&lt;li&gt;文中唯一的举例代码所用的编程语言为Java，无需担心的是，不同语言到撰文止都已有各自的成熟的基于用例的和基于特性的测试库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-对运行时间的测试&#34;&gt;1. 对运行时间的测试&lt;/h2&gt;
&lt;p&gt;解决方案是在&lt;a href=&#34;https://book.douban.com/subject/11614538/&#34;&gt;《The Clean Coder(程序员的职业素养)》&lt;/a&gt; 中读到的。
书里的一段对测试用例的协商对话（7.2验收测试）无意间描述了这个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试人员A：该函数运行时间不应超过两秒。&lt;/li&gt;
&lt;li&gt;测试人员B：无法为“不应超过两秒”编写测试，我们可以引入概率，即保证99.5%情况下符合。&lt;/li&gt;
&lt;li&gt;测试人员A: 如果要编写循环1000次测试，期望超时次数小于5，这个用例将耗时1小时，不现实。&lt;/li&gt;
&lt;li&gt;测试人员B: 可以执行15次操作，期望运行时间确切为2秒的
&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%88%86%E6%95%B8&#34;&gt;Z-score（标准分数）&lt;/a&gt;
大于2.57。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述对话提到了两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要用概率约束关于性能的需求，这种需求才可编写测试体现。&lt;/li&gt;
&lt;li&gt;合理运用抽样统计思想可减少测试所需的重复运行次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;在勉强把它归为一类吗&#34;&gt;在勉强把它归为一类吗？&lt;/h3&gt;
&lt;p&gt;嗯，有自觉。在单元测试层面，因测试框架对程序的控制权有限，能测的所谓“性能”仅仅指运行时间。
这个方式本质算作第二种“基于用例的测试”，但它的期望目标比较特殊，所以单独提出来介绍印象会比较深。&lt;/p&gt;
&lt;p&gt;虽然提起性能就是集成测试，需求中对性能要求的范围也往往是整个流程链路，
但这个确实能在单元测试层面实现。
比如每个高级些的语言都会有查看当前时间戳的库函数，
调用前后计算差值，就能得到与真实情况偏差不大的运行时间。
注意测试框架往往提供方式限制单个测试用例的运行时间，
那个的设计意图是防止单个用例影响整体测试运行，
不适合用来测运行时间，因为不能测量重复运行，单样本在统计学上不能验证假设。&lt;/p&gt;
&lt;p&gt;在单元测试中测试运行时间有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要等到集成测试时发现问题再打回来优化，fall fast嘛，至少保证这部分没有拖后腿。&lt;/li&gt;
&lt;li&gt;根据“单元测试指导编码”的原则，如果对模块的内部的函数有不同实现方案，
该函数运行负担较重且可测试，就可计算并利用运行时间作为方案取舍的参考。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-基于用例的测试example-based-testing-ebt&#34;&gt;2. 基于用例的测试(example-based testing, EBT)&lt;/h2&gt;
&lt;p&gt;用例本该用来翻译case或use case，这是术语，
但想了想还是把example翻译成用例合适，搜了下中文的博客也都用的这个翻译。
清楚与明确，就是EBT的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于计算类函数，可以做边界值测试。&lt;/li&gt;
&lt;li&gt;对于功能类函数（后端CRUD工作），可以写个冒烟测试（冒烟是集成测试的术语，在此借其定义）检查代码能否正常工作。
或者输入异常测试数据、给桩mock异常反应，测试被测函数的异常处理流程。&lt;/li&gt;
&lt;li&gt;TDD时需要故意写使测试失败的测试用例以启发编码，这是标准操作流程。&lt;/li&gt;
&lt;li&gt;再比如你想逐步debug，使用EBT可以让你清楚地知道程序走到每一步时应有的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;运用设计模式简化构造复杂测试数据实例的过程&#34;&gt;运用设计模式简化构造复杂测试数据实例的过程&lt;/h3&gt;
&lt;p&gt;在MVx架构模式族中，中间模块的方法的参数通常是领域定义的Model，Model的某种集合，甚至主Model嵌套属性Model。
关于如何简生成过程，有以下内容供参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java语言，&lt;a href=&#34;https://stackoverflow.com/questions/12568742/generating-test-data-for-unit-test-cases-for-nested-objects&#34;&gt;StackOverFlow上的这个问题&lt;/a&gt;
可能对你有所帮助。你也可以用&lt;a href=&#34;https://projectlombok.org/&#34;&gt;Lombok库&lt;/a&gt; ，
它的&lt;code&gt;@Builder&lt;/code&gt;注解可以生成Builder模式的对象构造代码。
或者IDEA编辑器，也有生成Setter方法的功能，但Builder模式比调用Setter构造对象方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非Java语言，&lt;a href=&#34;http://www.natpryce.com/articles/000714.html&#34;&gt;这篇博客&lt;/a&gt; 中提到的几个设计模式，
比如&lt;a href=&#34;http://wiki.c2.com/?ObjectMother&#34;&gt;Object Mother(数据生成工具类)&lt;/a&gt; ，&lt;a href=&#34;https://wiki.c2.com/?TestDataBuilder&#34;&gt;Builder&lt;/a&gt;
可以简化重复的构建语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示范代码&#34;&gt;示范代码&lt;/h3&gt;
&lt;p&gt;下面示例代码使用Java语言及其下的测试框架与库：
&lt;a href=&#34;https://junit.org/junit5/&#34;&gt;Junit&lt;/a&gt; ，&lt;a href=&#34;http://hamcrest.org/&#34;&gt;Hamcrest&lt;/a&gt; ，
&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; 。
目的是测试MVC模型中一个Service的getEntitiesBy()方法的正常逻辑(略去部分代码)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设定环境&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;假设DB中存在（对Mapper进行mock）与输入Request内容对应的记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;期望&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 桩：该方法会使用输入的Request中的索引值&amp;quot;normal&amp;quot;调用Mapper查询数据库，获取对应记录包装成的Entity Model。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 返回值：该方法应返回一个消息代码为&amp;quot;ok&amp;quot;的Response对象，其数据应为一个Entity对象的列表，首个元素的状态应与Mapper返回的对象相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// -------service.ServiceTest
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Given-When-Then - Behavior Driven Development (BDD)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;withNormalResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;normal&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// given, Mockito
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;given&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;willReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// when
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// then, Hamcrest, 对调用的返回值的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ok&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Mockito, 对被测调用桩时传入的参数的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;verify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;capture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 构造Mapper桩所返回的测试数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Collections&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;singletonList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dto.Response
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Lombok
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dao.entity.Entity
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Entity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-基于特性的测试property-based-testing-pbt&#34;&gt;3. 基于特性的测试(property-based testing, PBT)&lt;/h2&gt;
&lt;h3 id=&#34;名词解释&#34;&gt;名词解释&lt;/h3&gt;
&lt;p&gt;实在不好意思，我得先让你读一些难懂的名词定义，
关键内容大多是从&lt;a href=&#34;https://book.douban.com/subject/35006892/&#34;&gt;《程序员修炼之道(第2版)》&lt;/a&gt; 抄来的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例程（routine）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“例程是某个系统对外提供的功能接口或服务的集合。
比如操作系统的API、服务等就是例程；
Delphi或C++Builder提供的标准函数和库函数等也是例程。” &amp;ndash;&lt;a href=&#34;https://baike.baidu.com/item/%E4%BE%8B%E7%A8%8B/2390628&#34;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;契约式设计（development based on contract, DBC, 或contract-driven development）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出自&lt;a href=&#34;https://archive.org/details/objectorientedso00meye_0&#34;&gt;《面向对象软件构造(Object-Oriented Software Construction)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前置条件：例程期望自己运行前环境的状态符合它运行的需求。&lt;/li&gt;
&lt;li&gt;后置条件：例程保证自己退出时，环境的状态是什么样子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的不变式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从调用者的角度来看，类会确保不变式始终为真。&lt;/li&gt;
&lt;li&gt;在例程的内部处理期间，可以不遵守不变式，但退出时不变式需为真。&lt;/li&gt;
&lt;li&gt;因为Eiffel是OO语言，所以《OOSC》的作者将该概念命名为“类”的不变式，
实际上这个名词指的是例程所依靠的模块的内部状态，在OO语言里，就是类实例的状态。
《修炼之道》作者指出，在函数式语言中，状态是在函数间传递的数据本身，不变式概念依然有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例程与调用者的契约：
&lt;ul&gt;
&lt;li&gt;如果调用者满足例程所有前置条件，则例程保证退出时所有后置条件和不变式为真。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果任一方没有履行契约，就会调用（之前同意的）补救措施——抛出异常，或程序终止。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《修炼之道》：契约和不变式放在一起并称为特性，我们基于它做自动化测试。&lt;/li&gt;
&lt;li&gt;PBT库Hypothesis的作者的&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;解释PBT概念的文章&lt;/a&gt; ：
&lt;ol&gt;
&lt;li&gt;内部对调用者透明(&lt;a href=&#34;https://hypothesis.works/articles/referential-transparency/&#34;&gt;referential transparency&lt;/a&gt;))&lt;/li&gt;
&lt;li&gt;指定随机实例的类型(types)&lt;/li&gt;
&lt;li&gt;随机生成(randomization)&lt;/li&gt;
&lt;li&gt;对相关工具的使用(the use of any particular tool or library)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;只有ebt还不够&#34;&gt;只有EBT还不够&lt;/h3&gt;
&lt;p&gt;EBT优点在精准，缺点在太精准。一言以蔽之，EBT引入了太多主观且与需求无关的细节，且能测试到的代码运行路径的覆盖率及其有限。&lt;/p&gt;
&lt;p&gt;甚至个别用例会导致类似机器学习过拟合的效果，让代码偏离了原本的意图。
这更多是错认为“测试所表达的意图不会变且一直正确”的思维陷阱所导致的。
在EBT中，测试用例就是主观对需求的理解，需要在修改功能时不断检查无法通过的测试是否仍具有意义。
比如TDD实践中所使用的单元测试方式就是EBT，
在这篇记录两个开发者使用TDD流程结对编程实现一个Kata的
&lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/home/articles/the-bowling-game-an-example-of-test-first-pair-programming&#34;&gt;文章&lt;/a&gt;
中，两人会讨论“是否该把之前写的一个测试用例删除，因为它所代表的操作已不会在现实发生，虽然之前是有意义的”，还好他们凭经验避开了。&lt;/p&gt;
&lt;p&gt;从EBT转向PBT，像从&lt;a href=&#34;https://en.wikipedia.org/wiki/Programming_paradigm&#34;&gt;命令式(imperative)编程范式&lt;/a&gt; 到声明式(declarative)编程范式的转变。
命令式是给出具体过程的实现，就像EBT要明确构造调用被测函数时的测试数据的状态。
而声明式只是声明想做什么，具体过程交给解释器，
PBT也是只对特性的假设下准确定义，但关于在抽象定义的特性的限制下如何生成大量测试数据，交给PBT库。
这样我们仅仅给出了足够定义特性的信息，而没有引入对具体取值的依赖，符合&lt;a href=&#34;https://en.wikipedia.org/wiki/Interface_segregation_principle&#34;&gt;ISP原则&lt;/a&gt; 。
两者仅在对测试数据的构造方式上有差别，而对于被测函数的期望两者是相同精确的，都要明确写成assert, expect&amp;hellip;语句。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://increment.com/testing/in-praise-of-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 里不仅有关于EBT与PBT的代码级比较，还有使用PBT发现EBT难以暴露的bug的两个真实案例。&lt;/p&gt;
&lt;p&gt;不过我个人认为，PBT并不能完全取代EBT，比如边界值这个案例，
如果不是CI那种持续地测，没准儿只运行一次单元测试没能随机出特定的边界值呢。
而且两者也不互斥，可以针对同一个API写两种测试，更可靠。&lt;/p&gt;
&lt;p&gt;另外，我看到不止一个地方这样描述PBT：它会给你带来惊喜。&lt;/p&gt;
&lt;h3 id=&#34;pbt和fuzzing概念的区分&#34;&gt;PBT和Fuzzing概念的区分&lt;/h3&gt;
&lt;p&gt;PBT很像小到被测函数范围的&lt;a href=&#34;http://en.wikipedia.org/wiki/Fuzzing&#34;&gt;Fuzzing&lt;/a&gt; ，
目的是用大量随机输入无情地对待代码，尝试找出它代码上没有体现到，但是需求上承诺要做到的特性
（对于Fuzzing来说，被测软件应该承诺做到尽可能的鲁棒性和安全性）。
&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 阐述了两者间差别与相同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fuzzing是完全由计算机控制的随机过程，而PBT在随机的范围上基于特性进行了人为限定。&lt;/li&gt;
&lt;li&gt;PBT工具与Fuzzing工具在运行流程上高度相似，两者可相互替代使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个区别上我们也能看出，PBT不仅会利用计算机的随机与自动化摆脱思维对需求的偏见，
还能反过来促使开发人员思考总结并用代码表达出函数真正的、广范围的契约与不变式。
PBT可作为单元测试的一种方式，在单元测试层面，其最重要目的也是“启发编码”。&lt;/p&gt;
&lt;h3 id=&#34;pbt到底在哪个概念层级&#34;&gt;PBT到底在哪个概念层级&lt;/h3&gt;
&lt;p&gt;我认为PBT的明确对立概念应该是EBT，发生混淆的原因有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EBT已与太多的熟悉的概念绑定：TDD实践中明确使用EBT，谈起单元测试就是EBT；
谈起集成测试、QA以及更高层的测试，也是用具体的测试集去书面化需求文档，
测试集大多为EBT（但同时也存在引入随机测试数据的测试平台）。&lt;/li&gt;
&lt;li&gt;PBT运行时间多于EBT，不符合单元测试或者TDD要求的秒级结果反馈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可能会看到有观点说单元测试、TDD和PBT是对立的概念，《修炼之道》里部分文字也有这个意思。
当人们使用对比手法介绍PBT时，如果无法把EBT这个细类概念从大类概念中抽出，并明确地指出来，就会无意中造成这种表达理解上的误差。&lt;/p&gt;
&lt;p&gt;也有观点说PBT独立于单元测试、集成测试等测试层级概念，是“额外的一类测试”，我反对这个观点。
首先，我了解到的几个现有的PBT库都兼容在了原先存在的为EBT编写的成熟测试框架下，
或者应该说是测试框架逐渐变成了无关测试方式的抽象框架，这是事实依据。
其次从定义上区分，测试层级描述的是项目活动，区别主要在参与该活动的&lt;a href=&#34;https://en.wikipedia.org/wiki/Project_stakeholder&#34;&gt;项目干系人(stakeholder)&lt;/a&gt; 
的类别，和运行时对系统覆盖的范围，和PBT所定义的东西相差甚远。
PBT可以用在单元测试中，也可以用在集成测试中，它描述的仅仅是一种构造测试数据的思路。&lt;/p&gt;
&lt;h3 id=&#34;我认为单元测试中可以使用pbt&#34;&gt;我认为单元测试中可以使用PBT&lt;/h3&gt;
&lt;p&gt;在编程实践而非项目管理定义上，单元测试（和组件测试，组件测试在定义上比单元测试多涉及一个mock）有几个共识的特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由开发人员为指导编码所写。&lt;/li&gt;
&lt;li&gt;被测代码范围最大为单个模块，我们会使用Mock技术编写模块所依赖的桩，
模拟上层调用者调用模块的API，模拟被测模块的上下文。&lt;/li&gt;
&lt;li&gt;自动化与可重复运行。&lt;/li&gt;
&lt;li&gt;测试粒度比集成测试等包含多模块的层级更细。&lt;/li&gt;
&lt;li&gt;测试反映了开发人员对代码行为的期望。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以判断说PBT没有违反上述单元测试的定义。PBT与单元测试的矛盾大概在运行时间上。&lt;/p&gt;
&lt;h4 id=&#34;单元测试运行时间的大部分受不可控因素影响&#34;&gt;单元测试运行时间的大部分受不可控因素影响&lt;/h4&gt;
&lt;p&gt;TDD等倡导测试优先的学派，为了实践需要，额外为单元测试增加了“测试集运行速度需缩短到秒级”的要求。
这个要求是基于现代电脑的高性能前提提出的，而且我猜测，单元测试被TDD概念反过来影响，加之开发人员们主观感受，
认为单元测试就是而且应该是很快的。&lt;/p&gt;
&lt;p&gt;但我们在实践中已经了解到，一旦引入Mock机制，运行一次某个类对应的单元（严格来说是组件）测试的总时间，
绝大部分为测试框架执行mock加载上下文的时间，正比于我们想测的模块所涉及的依赖的启动复杂程度。&lt;/p&gt;
&lt;p&gt;举例，以我的经验（大概只是工作电脑性能低），对于Java的Spring-boot应用中的单个Junit测试类，
使用&lt;code&gt;@RunWith(MockitoJUnitRunner.class)&lt;/code&gt;最快，大概启动10秒左右；
如果要用&lt;code&gt;@RunWith(SpringRunner.class)&lt;/code&gt;，&lt;code&gt;@SpringBootTest&lt;/code&gt;就要启动30多秒；
如果被测代码还包含从配置文件中读取配置的内容，需要额外用&lt;code&gt;@TestPropertySource&lt;/code&gt;在启动时导入测试配置文件，
又要加个10秒左右。
不管测一个方法还是测所有方法也是加载同一个上下文，最小化上下文还是需要这么多启动时间。
肯定每次运行时都要看控制台里application启动时慢慢输出的log，然后刷刷两下所有用例都测完，测试退出。
这类代码从实践上考虑就无法使用TDD开发，但这些测试就是它们的单元测试。&lt;/p&gt;
&lt;p&gt;我个人认为，正确理解单元测试的速度要求需要&lt;strong&gt;相对于&lt;/strong&gt;集成测试来说，
单元测试相比集成测试运行时间低至少一个数量级，这种说法是对的。
同时通过Mock这个例子，我们发现单元测试的运行时间取决于代码的依赖的复杂度、电脑性能等不可控因素上
（有些牵强？哈哈抱歉，大概就是想表达这么个意思，没讨论到的因素还有很多）。&lt;/p&gt;
&lt;h4 id=&#34;单元测试中能否用pbt取决于具体欲测特性的复杂度&#34;&gt;单元测试中能否用PBT，取决于具体欲测特性的复杂度&lt;/h4&gt;
&lt;p&gt;这个说法真模糊啊，但我只能拿出这种说法了。
你看，单个PBT用例相比单个EBT用例，慢就慢在要测多于一个测试数据，加上生成数据的时间，关键在运行时间。
但是生成数据的范围和单个数据测试的时间又是由特性决定的，下面分别对两方面解释一下。&lt;/p&gt;
&lt;p&gt;关于大家和PBT库认为单个PBT用例的运行次数，或者说生成测试集的大小，我搜索的结果是，
从提供限定大小的参数的库，到默认100个的固定数量的随机测试集的库，
到正统的不许设定数据集大小，粒度只能指定到数据类型，需要持续运行测试的看法，都有。
首先，肯定运行越多越好，持续集成里的测试可以这么写。其次，单元测试肯定受不了相对较长的运行时间。&lt;/p&gt;
&lt;p&gt;《修炼之道》给的介绍PBT的例子有这两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行100次，随机列表作为输入，测试排序方法调用前后列表长度没变，排序结果正确，运行时间0.95秒。&lt;/li&gt;
&lt;li&gt;运行100次，从大小为4的集合中随机取元素作为输入，测试“库存始终大于0”不变式，找到了bug，没写运行时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;嗯，第二个例子100次不算多，能找到bug是因为这个bug比较“容易”被引爆，“容易”是个主观定性的词，描述了这个特性的复杂度。
&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;这篇文章&lt;/a&gt; 里介绍了一些PBT常见模式，
不少模式（所代表的特性）复杂度并不高。&lt;/p&gt;
&lt;p&gt;鉴于我们的单元测试时间可能大部分还是会消耗在执行mock上，花10秒运行1000次测试来测试一个特性，
这样对整个模块的PBT单元测试大概要跑几分钟（共十几个特性），似乎是可以接受的。&lt;/p&gt;
&lt;h3 id=&#34;如何构造pbt所需测试数据&#34;&gt;如何构造PBT所需测试数据&lt;/h3&gt;
&lt;p&gt;基本&lt;a href=&#34;https://hypothesis.works/articles/quickcheck-in-every-language/&#34;&gt;每个编程语言都有PBT库&lt;/a&gt;
（这篇2016年的文章信息稍有过时），
这类PBT测试库通常会提供，对其服务的语言的原生库内的类的实例的随机构造方法。
有点绕，用Java下的&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/basic-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 
库举例就是：该库会提供对Java基本类型、String、常用集合类、Date等类的随机构造方法。
这种构造方法因库而异，在提供给用户使用的方式上稍有不同，
比如&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/other-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 使用参数上的注解，
Python下的&lt;a href=&#34;https://hypothesis.readthedocs.io/en/latest/quickstart.html&#34;&gt;Hypothesis&lt;/a&gt; 使用方法上的注解。&lt;/p&gt;
&lt;p&gt;这样方便你写测试时进一步构造自己软件所在领域的Model之类的实例。
构造方式与PBT相似，还是要运用上文EBT部分所述的技巧自己手工编写，
只是把Model的属性赋值部分换成库提供的随机生成方法。
具体到代码，可以参照&lt;a href=&#34;https://dev.to/quii/property-based-testing-in-real-life-4db8&#34;&gt;这篇文章&lt;/a&gt; 的做法。&lt;/p&gt;
&lt;h3 id=&#34;更多关于pbt的参考内容&#34;&gt;更多关于PBT的参考内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个叫jqwik的Java PBT库的&lt;a href=&#34;https://jqwik.net/property-based-testing.html&#34;&gt;介绍页面&lt;/a&gt; 给出了不少关于PBT的资料。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;文章 Property-based Testing Patterns&lt;/a&gt; 
易懂地说明了PBT中可遵守的一些模式，可根据这些模式来指导总结代码中的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;希望这篇文章给你讲明白了，或者至少你可以把所有参考资料读一遍，自己形成理解。
试试在工作中把PBT用起来，如果害怕擅自导入PBT包被发现，不提交至VCS就行。
顺带一提我还没实践过，打算下次迭代时试试。我预计即使是后端日常CRUD功能，
根据那篇&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;PBT Patterns文章&lt;/a&gt; 
，针对数据变换或判断的方法都可能能总结出特性。&lt;/p&gt;
&lt;p&gt;抛砖引玉，欢迎在评论中指点指正，或给出另一个角度的看法，好让我对这些概念了解更深。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/programming/" term="programming" label="programming" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/programming/" term="programming" label="programming" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">对适用于个人的电子数据备份体系的总结</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/individual-data-backup-summary/" />
            <id>https://boholder.github.io/blogs/individual-data-backup-summary/</id>
            <updated>2021-05-20T17:26:31&#43;08:00</updated>
            <published>2020-12-07T00:00:00&#43;00:00</published>
            <author>
                    <name>BoHolder</name>
                    <uri>https://boholder.github.io/</uri>
                    <email>bottleholder@anche.no</email>
                    </author>
            <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights><summary type="html">对个人数据备份实操的个人见解</summary>
            
                <content type="html">&lt;p&gt;本文中个人电子数据特指&lt;strong&gt;只凭大脑记不住或可能随时间遗忘模糊的&lt;/strong&gt;、 
对拥有其的个人来说该部分数据&lt;strong&gt;丢失或泄露将会对本人社会参与状态或本人身心状态造成不利影响的&lt;/strong&gt;，
电子数据（下文简称“数据”）。
数据保存在电子介质上，且只能通过电子设备读写， 这意味着可能需要购买额外设备以满足对其保存、处理的需要。&lt;/p&gt;
&lt;p&gt;本文在引用所有没有对应术语级定义的自创名词时，将使用大括号高亮该名词，防止读者迷惑（例：【自创名词】）。
同时本文使用反引号引用上文已提到的有对应术语的名词（例：&lt;code&gt;术语名词&lt;/code&gt;）。
本文为作者因愚蠢与意外，丢失了四个半月工作数据的反思总结文。本文内容仅个人见解，欢迎指点与讨论。&lt;/p&gt;
&lt;h2 id=&#34;数据重要性分级&#34;&gt;数据重要性分级&lt;/h2&gt;
&lt;p&gt;数据按重要性（丢失后的损失大小）分为几个等级。&lt;/p&gt;
&lt;h3 id=&#34;一级&#34;&gt;一级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密密钥：
&lt;ul&gt;
&lt;li&gt;用于解密被加密的大块数据，但数据丢失对应加密密钥也没用了&lt;/li&gt;
&lt;li&gt;即它与它所加密的数据相互依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TOTP(Time-based One-Time Password)的seed：
&lt;ul&gt;
&lt;li&gt;保有它本身能生成TOTP6位数字，&lt;/li&gt;
&lt;li&gt;即它不依赖于其他（已经被输入验证器APP中且无法提取出的）数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台账户、软件激活序列号、平台登录Licence&amp;hellip;&amp;hellip;统称“凭证”：
&lt;ul&gt;
&lt;li&gt;等同于&lt;code&gt;加密密钥&lt;/code&gt;，是“access大块数据的凭证”。&lt;/li&gt;
&lt;li&gt;它对应的“加密”数据通常不由个人保存（平台服务）或易于再取得（付费软件）。&lt;/li&gt;
&lt;li&gt;即它不依赖于其“加密”的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积小，通常很难超过100MB，该特征对&lt;code&gt;多副本备份&lt;/code&gt;要求有利，易于保存在多个存储媒介上。&lt;/li&gt;
&lt;li&gt;价值大，该类数据的确认丢失通常伴随着不可挽回的巨大损失，欲哭无泪的那种心情。
（还好平台账户还能找回密码！）&lt;/li&gt;
&lt;li&gt;你不想让它公开（加密），也不想彻底丢失它（多副本备份）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存&lt;/li&gt;
&lt;li&gt;多副本备份，包括本地存储专用设备（移动硬盘，家庭NAS）和网盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二级&#34;&gt;二级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;个人信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常被以“个人隐私”统称，因个人经历生成、或包含可识别特定个人的身份信息，多为文档、多媒体类型。&lt;/li&gt;
&lt;li&gt;此处只且只能关心你&lt;strong&gt;可以控制&lt;/strong&gt;的部分（，
至于上传到外部或在外部平台上产生的，最好在源头控制它，即永远上传最无关自己现实身份的最少信息，
相信我，遵守该原则不会影响网络社交行为，这个话题和论证可以另外写一本书的量，就此打住）。&lt;/li&gt;
&lt;li&gt;属于【个人信息】的文件举例：求职简历等“个人信息汇总提交型文档”，包含本人脸部（哪怕是低分辨率的非正脸）的照片视频，
与他人在网络上的交流记录（聊天记录、邮件、别人发来的内含自己信息的文档等）
&lt;ul&gt;
&lt;li&gt;【个人信息】和&lt;code&gt;凭证&lt;/code&gt;的差别在于文件体积大小和含义，&lt;code&gt;凭证&lt;/code&gt;就像钥匙，而【个人信息】就是宝藏本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他因人而异的想保密的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如虽然和狭义上的【个人信息】无关，但仍包含在广义的“个人隐私”中的部分（比如与个人兴趣相关的数据）。&lt;/li&gt;
&lt;li&gt;所有你不想让它公开或泄露的数据（不管它是否不宜公开，你有天然的权利使它保密，至少是权力）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;体积不定且随年龄增大（经历增多）而增大，视个体兴趣性格职业差异，
体积多数可控制在500G之内（爱拍照摄影的时尚达人们可能仍不满足这个已经被高估的容量）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;价值不定，但对你来说这些是重要的，这就足够作为执行备份的理由了。
（对你有兴趣的坏东西和好朋友通常也对这些信息感兴趣。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存（加密所用密钥可保存在【一级数据】中）&lt;/li&gt;
&lt;li&gt;至少一份完整的本地备份，和可选的网盘备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三级&#34;&gt;三级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在电子设备使用过程中积累在硬盘中的一般数据，包括程序和操作记录、文档等：
&lt;ul&gt;
&lt;li&gt;加密与否无关紧要，但一般来说不会想丢失它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积非常大，但只需要购买容量适合自己需求（包括未来几年的潜在需求）的额外存储设备。&lt;/li&gt;
&lt;li&gt;价值较小，但值得花费钱和精力加一道保险。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少一份完整的本地备份&lt;/li&gt;
&lt;li&gt;还要考虑定期将仅仅是存储在硬盘中但不常用的大文件转移到存储专用设备中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他与加密和备份相关的个人见解&#34;&gt;其他与加密和备份相关的个人见解&lt;/h2&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;p&gt;来推荐工具吧！作者已使用好几年且现在仍然在使用&lt;a href=&#34;https://www.veracrypt.fr/en/Home.html&#34;&gt;VeraCrypt&lt;/a&gt;
(&lt;a href=&#34;https://github.com/veracrypt/VeraCrypt&#34;&gt;github项目地址&lt;/a&gt;)
作为所有加密相关操作的工具软件，开源、多平台且功能完备，而且曾经停滞过几年的它现在又活跃起来了！
还有什么比一个长久又仍在活跃的开源软件项目更棒的呢。VeraCrypt既可以加密整个Driver
（驱动器？盘？我还是用英文吧）， 又可以建立一个强加密的“文件型Driver”，
解密挂载时是一个可存取文件的盘，卸载后就是一个Portable的文件。
Portable=可以当作普通单一文件进行备份处理，完美。&lt;/p&gt;
&lt;p&gt;有个非程序小缺陷，直接从官网下载时非常慢，50kb/s(35M total)，且只能单线程请求数据。
别担心，我们还有&lt;a href=&#34;https://sourceforge.net/projects/veracrypt/&#34;&gt;sourceforge的分流&lt;/a&gt;。
（注意！不要被VeraCrypt的文件Driver功能迷惑了眼睛，
作者就是因为不读文档没做备份鲁莽试用Bitlocker时，将备份密钥存入文件Driver，
忘记了该文件本身储存在设置了Bitlocker的Driver中，迷惑操作。）&lt;/p&gt;
&lt;p&gt;对于Windows专业版用户来说，
&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview&#34;&gt;Microsoft Windows BitLocker&lt;/a&gt;
也是一个趁手的工具，作为商业级软件，它使用方便，且有微软的持续质量支持。但它只能加密Driver，
因此与备份操作结合时不太方便。使用BitLocker软件加密的Driver，
在备份前需要手动解密，或设置开机（登录）后自动解密，这样备份操作才不会因读取Driver失败而失败。
作为副作用，这会让加密文件在备份过程中暴露在可被读取的未加密状态下，因此对备份时环境的安全性（断网关服务）要求严格些。&lt;/p&gt;
&lt;p&gt;不好意思，作者对Mac和Linux的常用软件集合了解不多，无法介绍对应其上的平台独有软件，
VeraCrypt是多平台的，或许你可以先试试它。&lt;/p&gt;
&lt;p&gt;特别的，对【一级数据】而言，加密保存指使用另外一个人类可读的密钥（俗语：密码）
加密存有【一级数据】的独立的Driver（或其他可独立转移的“数据集合结构”）。
这要求你至少记住这么一个“主密钥”，“主密钥”用来解密出其他密钥。
作者使用VeraCrypt提供的文件Driver保存此类信息，该方法很原始，但作者固执认为它“更安全”。
市面上还有许多诸如&lt;a href=&#34;https://1password.com/zh-cn/&#34;&gt;1Password&lt;/a&gt;等直接提供此类信息加密与备份服务的软件，
甚至连Firefox，Chrome等现代浏览器中就内置了网站密码管理服务，稍加尝试就能找到合你口味的。&lt;/p&gt;
&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;
&lt;p&gt;考虑备份要首先识别需要被备份的数据主体，
可以认为一个主体是一个包含多个同类文件的，可独立转移的集合。
举例，对于作者来说，有一个【一级数据】，
两个【二级数据】（个人保密文档和工作保密文档），
五个【三级数据】（家里台式机，家里笔记本，工作笔记本，手机，平板电脑）
（手机和平板电脑是独特的，它们实际上是备份在电脑硬盘的【三级数据】部分中，
它们本身属于一二三级混合，作者的方案是将它们的备份加密（作为【二级数据】处理），
但随电脑的【三级数据】备份。）&lt;/p&gt;
&lt;h4 id=&#34;备份位置&#34;&gt;备份位置？&lt;/h4&gt;
&lt;p&gt;因为数据保存在电子介质上，是基于物理存在的存储设备的，
因此对于备份位置的选择，作者没有考虑过同存储位置内的冗余备份，
而是做到硬件级隔离，先不管地理位置（在抽屉里的移动硬盘还是地上的NAS还是网盘服务的主机集群中），
至少是硬盘级别的隔离。&lt;/p&gt;
&lt;p&gt;举例：作者本人讨厌网络存储服务且没有多设备大量转移数据的需求（主观+客观原因），
因此没有使用客观来讲确实经济实惠又方便的网盘服务。
作者也没有设置家庭NAS，只是购买了两块大容量移动硬盘，
定期把【二级数据】和【三级数据】备份在两块硬盘上，
一块在公司柜子里，一块在家里，四舍五入也算异地容灾了，容个火灾和人祸。
至于【一级数据】，保存在家里台式机、家里笔记本电脑、两块移动硬盘、公司笔记本电脑，共五个备份。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经过这次意外后作者决定将【一级数据】和【二级数据】额外上传到Microsoft OneDrive上，
反正加密了，备份数量多多益善，而且大小不是很大，能快速完成备份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：【一级数据】最好存在于每个【二级数据】所在的备份位置中，因为两者相互依赖，
可以理解为钥匙配得比宝箱数量多，钥匙放在每一个宝箱旁，还有“主密钥”做为钥匙的保护机制。
（像作者这种使用独立加解密软件的人，还需要额外将加解密软件的免安装便携版与【一级数据】和【二级数据】放在一起）&lt;/p&gt;
&lt;h4 id=&#34;备份频率&#34;&gt;备份频率？&lt;/h4&gt;
&lt;p&gt;这是作者本次经历的人祸所暴露出的备份体系中的最大问题，
&lt;strong&gt;备份不够频繁&lt;/strong&gt;，准确的说是对于公司笔记本电脑备份不频繁。
作者决定将之后的备份频率设置到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家中和公司的本地移动硬盘上每周备份一次（顺便备份手机与平板电脑）。&lt;/li&gt;
&lt;li&gt;家中和公司的两个移动硬盘每月交叉形成两份完整备份。&lt;/li&gt;
&lt;li&gt;【一级数据】和【二级数据】在电脑上设置自动网盘上传，每次更改过后就上传。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;备份间的自动化同步问题&#34;&gt;备份间的（自动化）同步问题&lt;/h4&gt;
&lt;p&gt;这个问题又要体现网盘的优势了，经过体验，OneDrive在Windows上可以做到实时备份，
可以使用该特性保证联网存储设备上备份间的一致性。
如果不想使用网盘服务，也可自建家庭NAS，
只要是能保证储存设备间相互联网，总能有现成的解决方案建立起自动化的数据同步系统。
比如Windows10系统自带的&amp;quot;备份&amp;quot;功能，可做到目录级粒度最短每10分钟同步一次。&lt;/p&gt;
&lt;p&gt;但是无法联网的设备，比如我那两块移动硬盘，我把它看作商业级方案中的“磁带仓库”————
容量大且便宜，保存介质稳定，但无法通过网络读写。
只能通过手动操作的方式对其进行备份更新，但最多也只是按时把它拿出来插在电脑上，
剩下的应交给只需手动配置一次的电脑上的软件级备份工具。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;本来作者的备份频率是一个月一次，在家里有好好遵守设定好的TODO为设备备份，
但公司的电脑因为嫌沉发懒，一直没带回家，加之上班就是工作下班就是回家，
这几个月都没在公司专门为工作笔记本备过份。
更灵异的是，在出事前的昨天晚上，作者看视频时脑中突然蹦出“好像工作笔记本好久没备过份了”，
随即被视频的精彩打消了顾虑，或许是冥冥中注定一劫让我清醒过来吧。
还是要感谢这次意外的，因为虚假的安全比不设保险更危险。
另外一个基于SRE理论的感悟是，重要操作前先备份，
但别忘了&lt;strong&gt;无法做到先备份则应停止继续重要操作，Process fall in safe&lt;/strong&gt;。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/thought/" term="thought" label="thought" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/sre/" term="SRE" label="SRE" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">TDD实践经验分享与对TDD实践程度的讨论</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/tdd-tips-zh/" />
            <id>https://boholder.github.io/blogs/tdd-tips-zh/</id>
            <updated>2021-05-25T17:37:03&#43;08:00</updated>
            <published>2020-07-17T00:00:00&#43;00:00</published>
            <author>
                    <name>BoHolder</name>
                    <uri>https://boholder.github.io/</uri>
                    <email>bottleholder@anche.no</email>
                    </author>
            <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights><summary type="html">TDD是好的，但要求对测试库很熟悉才能实践；但这不妨碍我们按照TDD的思路来指导代码编写</summary>
            
                <content type="html">&lt;h2 id=&#34;0对读者的知识要求前言&#34;&gt;0.对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;p&gt;要求：简单掌握任一编程语言，明白“软件测试”的定义、类别与各测试类别的作用。&lt;/p&gt;
&lt;p&gt;去年刚写这篇文章（20200717）时，我第一次在《代码整洁之道》系列书中读到TDD的概念与好处，
并试着在工作中实践了一个月，写这篇文章的目的是分享实践中摸索与网上搜索到的TDD实践技巧。
今年我读了更多的书，感觉对TDD的理论与实践多了解了一些，更新打的“补丁”字数也不少，
于是把标题改成更宽泛的“对TDD的实践的讨论”。&lt;/p&gt;
&lt;p&gt;本文分成几大部分：
第一部分，对TDD的实践技巧分享，我建议跳过第4小部分的经验细节，先把后面更新的观点类的文字读一读。
第二部分，给出“严格遵守TDD在实践上很困难”、“TDD部分流程不太‘务实’”的观点以及理由；
第三部分，摘录大量书籍《程序员修炼之道(第2版)》中的文字，给出可利用TDD优势而不会陷入教条的折中实践方案，
与对于“测试”概念的新颖理解方式。&lt;/p&gt;
&lt;p&gt;希望本文能消除你对于TDD概念与实践的疑惑，让你在平时编码时能够从TDD的思维方式中获得好处，而不必苦苦承受遵守TDD流程实践中的重复与艰难。&lt;/p&gt;
&lt;h2 id=&#34;1什么是tdd&#34;&gt;1.什么是TDD&lt;/h2&gt;
&lt;p&gt;TDD的全称是 “测试驱动开发（Test-driven development）”&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;
，“是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名”。&lt;/p&gt;
&lt;p&gt;一个TDD循环的简单流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个需求对应的测试，该测试以一个功能方法的 &lt;strong&gt;一部分逻辑&lt;/strong&gt; 为目标。&lt;/li&gt;
&lt;li&gt;编写简洁的业务逻辑代码，以通过测试。&lt;/li&gt;
&lt;li&gt;回归测试，运行和这部分逻辑相关的所有测试（或者简单的把整个测试类run一下），确认全通过。&lt;/li&gt;
&lt;li&gt;重构代码，修正步骤2中因思考逻辑而忽略的设计原则|设计模式（比如if-else中重复的代码可以提取成一个方法）。&lt;/li&gt;
&lt;li&gt;重新执行步骤3，确保重构没破坏功能。回到步骤1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2tdd的好处&#34;&gt;2.TDD的好处&lt;/h2&gt;
&lt;p&gt;在此引用Uncle Bob的《代码整洁之道-程序员的职业素养》（另，推荐阅读此系列书）一书中他第一次看到TDD的回忆：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;首先，他写了一个单元测试的一小部分，没几行代码。然后，他写了刚好能使那个测试通过的代码。
接着，他又写了些测试，然后再写一些代码&amp;hellip;从编码到运行的周期如此之短&amp;hellip;Kent居然每30秒运行一次（测试）程序&amp;hellip;
忽然，我发现这种周期似曾相识！许多年前，当我还是孩子的时候&amp;hellip;解释型语言,无需编译构建，你要做的只是添加一行代码，
然后执行，再添加，再执行&amp;hellip;使用这些语言的编程效率极高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（我看到“30秒”那里，就对TDD感兴趣了。）Bob大叔说得对，我们在刚开始编程时都有一个时期，小心翼翼，一次只加一行代码， 然后运行看看print出的变量值发生了什么变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;符合预期的变化会给我们信心，而且直白的目标使下一行要加的代码“呼之欲出”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是TDD的魔力所在。它鼓励你拿出勇气去重构（烂）代码，因为你不再害怕重构它有破坏功能的风险， 快速方便的回归测试集的re-run报告帮你撑腰。&lt;/p&gt;
&lt;p&gt;TDD还有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试的代码覆盖率接近100%。&lt;/li&gt;
&lt;li&gt;这些测试不仅是单元测试的一部分，也是代码形式的用例和文档。&lt;/li&gt;
&lt;li&gt;便于执行自动化回归测试（单元测试层面）。&lt;/li&gt;
&lt;li&gt;测试间相互隔离，鼓励每次循环时编写的新逻辑间保持松耦合。&lt;/li&gt;
&lt;li&gt;TDD要求测试先行，这有助于帮助开发人员拆解需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3我认为的实施tdd的知识要求&#34;&gt;3.（我认为的）实施TDD的知识要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;熟练使用当前项目所用语言的特性与类库，和单元测试工具。 前者减少因为不熟悉语言而卡壳愣住的概率，后者是使用TDD的硬性要求。&lt;/li&gt;
&lt;li&gt;会拆解需求，从理想情况到需求所定义的限制性条件，一步步增加条件。（第4部分中详细解释）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4实施tdd过程中的困惑和解决方案&#34;&gt;4.实施TDD过程中的困惑和解决方案&lt;/h2&gt;
&lt;p&gt;TDD理论说来容易，但如果自身技能不够扎实，只是从头疼怎么写业务代码转到头疼怎么写测试而已。 测试先行意味着，测试写得不够“好”，则直接影响开发人员进一步的思考方向，严重时会把开发人员带进思考泥潭。&lt;/p&gt;
&lt;h3 id=&#34;41不需要在编写测试时编写非法输入测试&#34;&gt;4.1.不需要在编写测试时编写非法输入测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：如何在使用TDD时保证代码的健壮性？是否需要考虑非法输入？&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：TDD时不需要。TDD之后，部分代码会需要，再加上就是。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;的第二个回答，&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;1.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;编写非法输入测试(比如输入NULL，空对象指针etc，这不是一个正规名词但涵盖范围正确）是QA（测试人员）的任务， 当他们测试时，会在至少是单元测试的层面的封装（或者调用链）上测试非法输入，这意味着 &lt;strong&gt;不是每个方法都要考虑非法输入&lt;/strong&gt; ，
而TDD的测试会覆盖到每个方法。 另外，在TDD之后而不是TDD时考虑这个部分，修改代码会更头脑清晰更方便（回归测试给的信心）。&lt;/p&gt;
&lt;p&gt;同时应该注意的是，如果业务逻辑本身要求“分情况考虑”， 那么像是数组长度=0，以及由“情况”的排列组合得出的对应的“合法的”边界测试（edge cases），就要在TDD时覆盖到。 正确实例：&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;
（这是一个优雅如禅宗公案的“kata”）最后，为了考虑逻辑的“周全性”而添加的两个测试。（一个输入情况对应一个测试）&lt;/p&gt;
&lt;h3 id=&#34;42避免错误的步子大的测试&#34;&gt;4.2.避免错误的步子大的测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我写出了下一个测试，但在编业务代码时卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：先排除自身编码不熟练的因素，然后检查这个测试，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是不是覆盖的逻辑太大了，重新写一个小一些的测试（4.3详解）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;3.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;酒要一口一口地喝，路要一步一步走，步子迈大了，容易_ _ _。————《让子弹飞》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在TDD过程中，业务逻辑编码只需要恰好满足使测试通过， 如果坚持住这个原则，那么唯一使编程步骤卡壳的原因就在于： 开发人员不能快速想出通过测试的方案，又陷入了使用TDD前的窘境————没有短又直白的编码目标，头疼怎么一步到位。
这个测试不能驱动编码思路&lt;em&gt;呼之欲出&lt;/em&gt;，说明这个测试有问题，需要重新换一个。 两个资料里都提到了这样含义的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免一个测试覆盖太大的逻辑范围，这违反了TDD单个测试对应小目标的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误实例：就像文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;中“我”在第一次分析需求时，选择了不明朗的测试“演化”方向， 导致最后一步测试，实质上对应的是一步到位处理超过一种的新加入的情况，无法延续现有的代码继续修改以通过测试。&lt;/p&gt;
&lt;p&gt;现在的问题转换为“如何写出下一个测试”，请接着读4.3。&lt;/p&gt;
&lt;h3 id=&#34;43简化问题场景-逐步添加限制条件&#34;&gt;4.3.简化问题场景-&amp;gt;逐步添加限制|条件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我无法写出下一个测试，卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：接着上一步测试的目的，继续分析需求，我们走到哪了？或者我们应该换个思路重新分析需求？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;2.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;When faced with a problem you do not understand, do any part of it you do understand,
then look at it again.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;给出的引用，来自一部科幻小说。下面我要写的是我根据文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;和其他kata解决需求的思路悟出的门路， 总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要按步骤1-2-3线性流程切分需求，而是按套娃，
从理想的简单状态机（简单输入简单处理输出|复杂输入简化处理输出）到有条件|限制的复杂状态机（复杂处理+复杂输入|输出），
一步步完善处理逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你手边有《计算机网络》这类书，看看每个层的第一个教学使用的理论协议的假设条件有多理想，以数据链路层的协议为例： 单工，发送方和接收方的网络层总是准备就绪，数据处理不计时间， 可用缓存无限大，信道不会在物理层损坏|丢失。
这种理想协议只会在教科书上存在，但它形象地描述了该层协议 &lt;em&gt;可能的风险|考量&lt;/em&gt; 。 之后的篇幅逐渐引入各种机制来解决理想协议中忽略的考量，最终一个能在现实场景中使用的协议完成了。&lt;/p&gt;
&lt;p&gt;咱们的测试也应该像设计协议一样，每次只测试一个考量|一种情况， 修改少量代码通过这个测试，接着向下走，直到考虑了所有情况。&lt;/p&gt;
&lt;p&gt;正确实例：文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;后半段，“我”针对“字符串按位换行”需求，先考虑了没有空白符的“纯”字符串简单情况，然后因为引入空白符， 多增加了三种情况（分割点在空白符左、相同、右），多写三个测试并修改代码通过它们，最终完成了逻辑。&lt;/p&gt;
&lt;h2 id=&#34;参考文章因渲染问题跑到了最下面&#34;&gt;参考文章（因渲染问题跑到了最下面）&lt;/h2&gt;
&lt;h2 id=&#34;2021-03-11更新&#34;&gt;2021-03-11更新&lt;/h2&gt;
&lt;p&gt;我对TDD有了新的理解：TDD对新手来说比较难以实践，不建议新手去用。有以下几点理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写测试速度很难跟上思考速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDD本质上是把对方法|函数的功能的要求编进测试用例，要求是思考形成的， 
如果对编程语言（＆第三方测试框架）不是如母语一样熟悉，
写测试的速度跟不上思考的速度，就需要阻塞思考，慢慢写出一个个测试用例。&lt;/li&gt;
&lt;li&gt;就像阻塞快速的CPU去做慢速的I/O一样，更惨的是不是人人都是周伯通，
手脑协调同时只能做一件事， 所以不能引入一个终端机制去并行思考&amp;amp;写测试）。&lt;/li&gt;
&lt;li&gt;阻塞思考不仅痛苦还会打断思路，而且编程速度很慢，不利于完成工作。&lt;/li&gt;
&lt;li&gt;解决这个问题，或者提高写测试速度（I/O速度）；或者科幻一些，
借助机器（引入数据通道辅助I/O），比如哪天出现一个自然语言的测试框架，
写英文就能生成对应测试用例，或者脑机接口之类。唉，暂时不可求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试用例是否能体现功能需求与测试是否通过无关，不可强求测试覆盖率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极端例子：&amp;hellip;; assertThat(1，is(1)); 上述用例在计算覆盖率时照常计算，但实际上什么都没有测出来。&lt;/li&gt;
&lt;li&gt;类比网络安全上的常识“虚假的安全感比没有安全感更致命”，
虚假的单元测试覆盖率和绿色的测试通过标记比没有一丁点单元测试同样致命。&lt;/li&gt;
&lt;li&gt;我想说的是，如果强行遵守TDD（意味着无论测试质量如何都会统计出高测试覆盖率）
或者不遵守TDD但有强制的单元测试覆盖率要求，有时对项目伤害更大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有专业全面的测试环节，单元测试的价值会打个折扣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这不是我的见解，我认为&lt;a href=&#34;https://twitter.com/iamshaynez/status/1357606576396275713&#34;&gt;他说得有些道理(推特thread)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但我认为对复杂逻辑的测试该写还是写，因为单元测试就是为开发时即时测试而存在的，和QA两码事。
即使QA发现bug提出工单，你改好了，但下次重构时又 不能&amp;amp;没权限&amp;amp;不方便 即时地把历史工单的测试用例全跑一遍，不踏实。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单逻辑犯错概率很小，没有写测试的必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举个例子，为了打log而写的try-catch(-catch&amp;hellip;)逻辑，
我会把try中的逻辑单独重构成方法，
那么专门对该单纯的try-catch包装方法写测试就比较鸡肋，
如果写测试速度不够快，认真读两遍代码看看异常类的名是否写对更快些。&lt;/li&gt;
&lt;li&gt;（如果throw的方法在try中的逻辑内调用好几层深，或者catch内涉及修改对象状态的“异常时处理”操作，
写个测试用例比较好，保证确实这类异常会被这里的catch抓住而不是被内部的catch抓住，进而触发处理操作。
（比如Java Spring @Transaction 注解，就隐性地要求必须把异常抛出该注解修饰的方法，才能启动回滚，
内部的打log catch要在最后把异常再throw出去。））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要承认，如果真的能同时：1.测试质量高 2.测试覆盖率高，那么这种单元测试的价值非常大。
可惜现实情况往往是没经验满足1，没时间满足2，而且不满足1还反而有害。&lt;/p&gt;
&lt;p&gt;我现在的实践是（我们团队对单元测试没要求），要写用例就用多种assert努力体现完备的功能要求，写不出|懒不想写就干脆不写。
编写完功能代码，针对其中我认为的“复杂(变成自动机它中间状态比较多)”方法
（相对的是“惰性”的一目了然的方法：简单的异常处理，类似构造器的接参数builder方法&amp;hellip;）
写单元测试（简单的边界，null，正常），不在意覆盖率，单纯地“为了当前开发而测试”，如果能方便到以后的重构就更好啦。
（不要和“编程为了长远，只是运行刚好满足于现在的需求”准则弄混，那是描述功能设计而不是单元测试的准则。）&lt;/p&gt;
&lt;h2 id=&#34;2021-04-30更新&#34;&gt;2021-04-30更新&lt;/h2&gt;
&lt;p&gt;说实话，3月时我写下上面的补丁的内容，以提供反面的观点，但心中仍留有疑惑：
我到底该对TDD持有怎样的态度？我该如何使用其中好的思想并避开麻烦的实践过程？
《程序员修炼之道(第2版)》中谈到的关于测试的观点让我倍受启发，
我忍不住大段大段地把内容抄写在这里，以弥补与融合上面两部分中对TDD的支持与反对的观点，使之形成整体的观点。
因抄写字数太多，我不会使用格式标记抄写的段落，反过来，下面我说的话会使用&lt;em&gt;斜体&lt;/em&gt;标记。
有时会抄写原文，有时会把原本不同位置的表达同概念的单句组合在一起，有时改写难以理解的表达，
省略描述书中举例，我尽量将书中的想表达的观点呈现出来。
当然，推荐你找到本书并从“&lt;strong&gt;第7章-41节-为编码测试&lt;/strong&gt;”开始阅读原文，这书没阅读门槛，很值得一读。
嗯，版权问题&amp;hellip;&amp;hellip;我想两位作者不会因为这个来找我的，我们都想让更多人了解到更务实的工作方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;41-为编码测试&#34;&gt;41 为编码测试&lt;/h3&gt;
&lt;p&gt;我们认为“为了找bug|确保代码工作正常而编写测试”是错误的观点。&lt;/p&gt;
&lt;h4 id=&#34;提示66-测试与找bug无关&#34;&gt;提示66 测试与找bug无关&lt;/h4&gt;
&lt;p&gt;我们相信，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是运行它的时候。
当你开始编写新功能，你不知道怎么去写业务逻辑，这时可以提前考虑一下测试：
假设你已经写完了业务逻辑，准备补单元测试了。
&lt;em&gt;想想你要怎么测试业务逻辑？怎么划分每个测试方法的范围？你的代码需要注入什么依赖模块来模拟真实环境？能够控制哪些依赖模块以模拟不同情况？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从考虑测试开始，在不写一行代码的情况下，你已经有了对业务逻辑每个公开方法的方法签名（API）要求的发现，并设计了API。
考虑测试使我们减少了代码中的耦合
（与其他代码紧耦合的函数或方法很难进行测试，因为你必须在运行方法之前设置（&lt;em&gt;mock&lt;/em&gt;）好所有环境，让你的东西可测试也减少了它的耦合），
并增加了灵活性（&lt;em&gt;我们想在测试时自由地控制依赖模块来模拟不同情况，这要求业务逻辑的API所接受的参数范围要广&lt;/em&gt;）。
为公开方法写测试的考虑过程， 使我们得以从外部看待这个方法，这让我们看起来是方法的客户（&lt;em&gt;调用者&lt;/em&gt;）而不是作者。&lt;/p&gt;
&lt;h4 id=&#34;提示67-测试是代码的第一个用户&#34;&gt;提示67 测试是代码的第一个用户&lt;/h4&gt;
&lt;p&gt;我们认为，“&lt;strong&gt;测试所提供的反馈至关重要，可以指导编码过程&lt;/strong&gt;”，这是测试的最大好处。
在你对一个东西做测试前，必须先理解它在干嘛。
现实中我们刚开始编写代码时，只能基于对必须要做的事的模糊理解，&lt;em&gt;边写边理解边解决新出现的要求（错误处理，边界，isNull etc）&lt;/em&gt;，
最后代码总量比真正干事的逻辑大好几倍，里面充斥了条件逻辑与错误处理。&lt;em&gt;这时再写测试就不好分辨整个代码真正在干什么了。&lt;/em&gt;
如果你在开始编码前，就考虑过测试边界条件及其工作方式（&lt;em&gt;不同情况的分类处理&lt;/em&gt;），&lt;em&gt;那么你可能会发现简化条件逻辑的方案&lt;/em&gt;。
如果考虑需要测试的引发错误的条件，&lt;em&gt;那么你将会有意构造对应的错误处理逻辑&lt;/em&gt;。&lt;/p&gt;
&lt;h5 id=&#34;测试驱动开发&#34;&gt;测试驱动开发&lt;/h5&gt;
&lt;p&gt;我们看到TDD的好处，只要遵守流程，代码始终都有测试，你也将一直处于思考测试的状态。
我们也看到人们成为TDD的奴隶：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花费过多时间确保100%测试覆盖率&lt;/li&gt;
&lt;li&gt;做了很多冗余（&lt;em&gt;无用&lt;/em&gt;）的测试 
（&lt;em&gt;书中举例：刚开始编写方法时，对一个特定测试值（这是从特例到公式的必要一步TDD步骤）， 编写之后显著会重复|重写的AD-HOC逻辑&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;TDD的设计从底层开始，然后逐步上升。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;tdd你需要知道该去何方&#34;&gt;TDD：你需要知道该去何方。&lt;/h5&gt;
&lt;p&gt;“小步前行”被吹捧为TDD的一个优点，但这可能会误导你，它鼓励人们专注于不断优化简单的问题，而忽略编码的真正动因（&lt;em&gt;解决需求！&lt;/em&gt;）。
&lt;em&gt;书中案例：罗恩·杰弗里斯的数独程序系列博客，进行多次重构后满意，最终放弃了项目。&lt;/em&gt;
按顺序阅读博客很有趣，可以看到一个聪明人是如何被通过测试的喜悦套牢，开始为琐事（&lt;em&gt;不断想着重构&lt;/em&gt;）而分心。&lt;/p&gt;
&lt;h4 id=&#34;提示68-既非自上而下也非自下而上基于端对端构建程序&#34;&gt;提示68 既非自上而下，也非自下而上，基于端对端构建程序&lt;/h4&gt;
&lt;h5 id=&#34;自上而下与自下而上之争以你该用的方式去做&#34;&gt;自上而下与自下而上之争，以你该用的方式去做&lt;/h5&gt;
&lt;p&gt;计算机领域初期有两种程序设计学派：自上而下与自下而上。
但两个学派都没成功，因为它们都忽略了：刚开始（&lt;em&gt;即设计阶段&lt;/em&gt;）没人知道要做什么。
自上而下要求提前知晓需求，这不可能。
自下而上假设从小到大构造抽象层最终实现需求，但不知需求就无法划分功能边界。&lt;/p&gt;
&lt;p&gt;我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。
应用学到的知识充实代码，让客户参与每一步并让他们指导这个过程。
测试对开发的驱动绝对有帮助，但是，就像每次开车一样，除非心里有一个目的地，
否则就可能到处兜圈子。&lt;/p&gt;
&lt;h4 id=&#34;提示70-要对软件做测试否则只能留给用户去做&#34;&gt;提示70 要对软件做测试，否则只能留给用户去做&lt;/h4&gt;
&lt;p&gt;毫无疑问测试是编程的一部分，不该留给其他部门的人去做（&lt;em&gt;测试部门算其他部门吗？&lt;/em&gt;）。
测试、设计、编码————都是在编程。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好了，抄完了，你应该能读到两位作者的心思：按照TDD的思路在编码前考虑测试有好处，但并不是必须要遵守TDD流程来实践才能获得这个好处。
那么我再抄一段作者在书中的调侃作为本次补丁的结尾吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;忏悔&lt;/p&gt;
&lt;p&gt;我，Dave，因告诉别人自己不再编写测试，而大出风头。这样做的部分原因是想动摇那些把测试变成宗教的人的信仰。
这样说的部分原因是，这（某种程度上）是真的。&lt;/p&gt;
&lt;p&gt;我已经编写了45年的代码，30多年中我都写了自动化测试。构思写测试，已经成了我编码方式的一部分&amp;hellip;
我决定停止编写测试几个月，看看代码会出什么事。令人惊讶的是，影响“不是很大”，我花了一些时间来找出原因。&lt;/p&gt;
&lt;p&gt;我相信这个原因是，（对我来说）测试的好处更主要来自思考测试，以及思考测试对对代码造成的影响。
在长时间坚持这么做后，我写不写测试都会这样思考。代码仍是可测试的，只是无须真的写出来测试。&lt;/p&gt;
&lt;p&gt;&amp;hellip;测试也是与其他开发人员交流的一种方式，所以我开始会在与他人共享代码时为其编写测试，或给有外部依赖的事情写测试。&lt;/p&gt;
&lt;p&gt;Andy说我不应该加上这个知识栏，他担心这会诱使缺乏经验的开发人员不写测试。下面是我的折衷方案：&lt;/p&gt;
&lt;p&gt;应该编写测试吗？要，但等你写了30年后，不妨从容地做些实验，看看它究竟给你带来的什么好处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;https://en.wikipedia.org/wiki/Test-driven_development&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&#34;&gt;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&#34;&gt;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&#34;&gt;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/programming/" term="programming" label="programming" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/programming/" term="programming" label="programming" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Java实现大整数排列组合，解决抽卡欧气计算问题</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/java_arrangement_combination_zh/" />
            <id>https://boholder.github.io/blogs/java_arrangement_combination_zh/</id>
            <updated>2020-12-24T23:32:42&#43;08:00</updated>
            <published>2019-07-27T00:00:00&#43;00:00</published>
            <author>
                    <name>BoHolder</name>
                    <uri>https://boholder.github.io/</uri>
                    <email>bottleholder@anche.no</email>
                    </author>
            <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights><summary type="html">白送的10连，抽爆，抽完攀比思想冒头，循环乘嘛，实现一个！（其实是不想在WolframAlpha（一个付费在线数学计算应用）里输长长一串）</summary>
            
                <content type="html">&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近玩的某游戏开了新卡池，抽了8个10连共计80次，&lt;br&gt;
出了4个稀有度最高的角色，&lt;br&gt;
我突发奇想想算算我这个爆率算什么水平，&lt;br&gt;
程序模拟一下，顺便复习排列组合。&lt;/p&gt;
&lt;h2 id=&#34;程序设计&#34;&gt;程序设计&lt;/h2&gt;
&lt;p&gt;Java标准类库中，没有排列组合甚至阶乘的现成方法，  &lt;a href=&#34;https://stackoverflow.com/questions/891031/is-there-a-method-that-calculates-a-factorial-in-java&#34;&gt;搜了一下&lt;/a&gt;&lt;br&gt;
但为了这个引入一个第三方库又未免太麻烦，于是自己来实现。&lt;/p&gt;
&lt;p&gt;实现第一想到的是int和long两个基本类型，&lt;a href=&#34;https://www.iteye.com/blog/ly5633-1219408&#34;&gt;但想了想发现有坑&lt;/a&gt; ：int最多12！，long最多到20！&lt;br&gt;
这可不行，我这都80抽了。&lt;br&gt;
于是换Java的BigDecimal类（大整数）。&lt;/p&gt;
&lt;p&gt;问题换算成伪代码是这样：&lt;br&gt;
res=0&lt;br&gt;
res += c(n, i) *  爆率^i *  (1 - a)^(n-i) 	(i=a~b,i为整数)&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
import java.math.BigDecimal;

public class factorial {

	public static void main(String[] args) {

		// 出货率2.5%
		double a = 0.025d;
		int n = 80;
		// result
		double res = 0;
		double res2 = 0;

		for (int i = 0; i &amp;lt; 5; i++) {
			res2 += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;0~4: &amp;quot; + res2);

		for (int i = 4; i &amp;lt; n + 1; i++) {
			res += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;4~80: &amp;quot; + res);
	}

	// n!
	public static BigDecimal n(int n) {
		if (n == 0)
			return new BigDecimal(0);

		BigDecimal result = new BigDecimal(1);
		BigDecimal a;
		for (int i = 2; i &amp;lt; n + 1; i++) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/m!
	public static BigDecimal n2m(int n, int m) {

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/(n-m)! === a(n,m)
	public static BigDecimal a(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; n - m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// c(n,m) === a(n,m)/(m)!
	public static BigDecimal c(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);
		if (m == n)
			return new BigDecimal(1);

		// 优化计算，避免大除大
		if (m &amp;gt; n / 2)
			return n2m(n, m).divide(n(n - m));
		else
			return a(n, m).divide(n(m));
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;结果结论&#34;&gt;结果&amp;amp;结论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0~4:  0.8176930694561881&lt;/li&gt;
&lt;li&gt;4~80:  0.14056818112756556&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽80次，出0~4次货的概率 高达94.9%、&lt;br&gt;
出4次及以上的概率为 14%，其中出4次占9%&lt;br&gt;
这样一看我还行，乐上加乐，没钱人的开心就是这么简单。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/programming/" term="programming" label="programming" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/java/" term="java" label="java" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/programming/" term="programming" label="programming" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">HTTP cookie的安全性、安全使用方法和攻击防御手段</title>
            <link rel="alternate" type="text/html" href="https://boholder.github.io/blogs/cookie_security_zh/" />
            <id>https://boholder.github.io/blogs/cookie_security_zh/</id>
            <updated>2021-05-20T17:26:31&#43;08:00</updated>
            <published>2019-05-18T00:00:00&#43;00:00</published>
            <author>
                    <name>BoHolder</name>
                    <uri>https://boholder.github.io/</uri>
                    <email>bottleholder@anche.no</email>
                    </author>
            <rights>[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)</rights><summary type="html">工作需要，要上台讲讲cookie安全性，索性总结成博客，自认为蛮全的</summary>
            
                <content type="html">&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文将把，截至2019-05-18的，从互联网上搜集到&lt;/p&gt;
&lt;p&gt;（&amp;ldquo;cookie+security&amp;rdquo;-&amp;gt;Google与StartPage前两页结果为源+相关学术文献）的,&lt;br&gt;
有关Cookie标准与用法、cookie安全性的信息，汇总索引，以方便读者学习了解相关信息。&lt;/p&gt;
&lt;p&gt;本文需要读者对计算机网络有大致了解，&lt;br&gt;
没有了解也可以，术语会挂上解释链接，但阅读体验就比较差了。&lt;/p&gt;
&lt;p&gt;小段英文的翻译交给谷歌处理。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;2部分与3部分的解决方案部分有重复，&lt;br&gt;
但我认为还是把攻防和开发分开，缺陷与解决结合，比较方便阅读。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#what-is-cookie&#34;&gt;Cookie是什么&amp;amp;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#security-risk-in-design-and-use-and-solution&#34;&gt;设计、使用中的安全隐患以及相应改进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#attack-on-cookies-and-solution&#34;&gt;针对cookie窃取的攻击与相应防御&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#academic-discussion-about-cookies&#34;&gt;学术讨论涉及cookie的攻防&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#summary&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;what-is-cookie&#34;&gt;What is cookie&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.Cookie是什么&amp;amp;用法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34;&gt;维基百科&lt;/a&gt; 还是蛮丰富的，中文维基简单点，可以看&lt;a href=&#34;https://baike.baidu.com/item/cookie/1119&#34;&gt;百度百科&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RFC：&lt;a href=&#34;https://tools.ietf.org/html/rfc2109&#34;&gt;rfc2109-1997&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc2965&#34;&gt;rfc2965-2000&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc6265&#34;&gt;rfc6265-2011&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-httpbis-rfc6265bis/&#34;&gt;rfc6265bis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&#34;&gt;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在最新的定义cookie的RFC2965上，是这么说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;we will use the term cookie to refer to the state&lt;br&gt;
information that passes between an origin server and user agent,&lt;br&gt;
and that gets stored by the user agent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将使用术语cookie来指代在源服务器和用户代理之间传递的状态信息，&lt;br&gt;
以及由用户代理存储的状态信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单总结，cookie是：服务器与客户端间标识状态的信息，储存在客户端&lt;br&gt;
（硬盘或内存，视类型而定），由服务器增删改读。&lt;br&gt;
用途：满足对无状态的HTTP协议，想让它&lt;strong&gt;有状态&lt;/strong&gt;的需求，一种修补措施。&lt;/p&gt;
&lt;p&gt;比如一个服务器，需要同时与多个客户端通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为HTTP协议@的无连接性，所以需要一个额外方法区分不同客户端。&lt;/li&gt;
&lt;li&gt;然后因为计算机网络的网络层路由有&lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR-无类域间路由&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation&#34;&gt;NAT-网络地址转换&lt;/a&gt; 这类协议存在，&lt;br&gt;
服务器不能单靠记录IP或者MAC这些HTTP包里的信息标识每一个客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此Netscape Draft在1994年率先定义了cookie这一解决方案&lt;br&gt;
（此处apache.org的原文链接好像失效了），之后被整理成rfc2109。&lt;/p&gt;
&lt;p&gt;cookie可以用来干什么？&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Uses&#34;&gt;维基&lt;/a&gt; 给了三个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会话管理&lt;/li&gt;
&lt;li&gt;个性化定制 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zombie_cookie&#34;&gt;wikipedia-Zombie cookie （有点意思）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;格式用法&#34;&gt;格式&amp;amp;用法&lt;/h3&gt;
&lt;p&gt;一个cookie由一个键值对（key=value）组成，同时在&lt;em&gt;被设置时&lt;/em&gt; 会附加一些变量（attributes），&lt;br&gt;
这些变量用来控制该cookie的使用方法。&lt;/p&gt;
&lt;p&gt;想了解详细属性，看&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt; ，&lt;br&gt;
找不到新鲜的全面的中文材料，有个不错的&lt;a href=&#34;https://imququ.com/post/host-only-cookie.html#toc-3&#34;&gt;博客@Jerry Qu&lt;/a&gt; ，但是是13年的。&lt;/p&gt;
&lt;p&gt;比如，我们时常听闻的第三方cookie，在设置时会标一个&lt;code&gt;Third-party&lt;/code&gt;属性，&lt;br&gt;
表明这是从非当前网站（URL框里的网站）设置的。&lt;/p&gt;
&lt;p&gt;当一个网站有引用（&amp;lt;img&amp;gt;&amp;hellip;）其他网站，比如广告网站的广告资源时，&lt;br&gt;
浏览器加载该网站时，也会向广告网站发GET请求，&lt;br&gt;
第三方cookie就随着资源一起来到了浏览器上。&lt;/p&gt;
&lt;p&gt;对cookie的操作不再赘述，有需请自取。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&#34;&gt;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2&#34;&gt;https://tools.ietf.org/html/rfc6265#section-4.2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;security-risk-in-design-and-use-and-solution&#34;&gt;Security risk in design and use and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.Cookie设计与使用中的安全隐患，以及相应改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie安全性这点，&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-8&#34;&gt;rfc6265中有一整段(8. Security Considerations)&lt;/a&gt; 去阐述，&lt;br&gt;
务必读一下，总结的很好，我会跳过那些内容，只给出一个目录以供预览。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分标题&lt;/th&gt;
&lt;th&gt;简述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Overview&lt;/td&gt;
&lt;td&gt;总览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ambient Authority&lt;/td&gt;
&lt;td&gt;cookie是一种权限凭证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clear Text&lt;/td&gt;
&lt;td&gt;明文传输问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Session Identifiers&lt;/td&gt;
&lt;td&gt;非可读的会话标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Weak Confidentiality&lt;/td&gt;
&lt;td&gt;cookie在各种层面保密性都弱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reliance on DNS&lt;/td&gt;
&lt;td&gt;cookie的安全性以DNS安全为前提&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;与其说其设计不周全，不如说cookie因本身位置的限制无法保证设计安全，&lt;br&gt;
rfc还警告开发人员不要把cookie作为唯一的认证环节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265: In addition, by default, cookies do not provide confidentiality or integrity&lt;br&gt;
from network attackers, even when used in conjunction with HTTPS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此外，默认情况下，cookie不会为网络攻击者提供机密性或完整性，&lt;br&gt;
即使与HTTPS结合使用也是如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1服务器只能读取cookie键值对读不到属性&#34;&gt;1.服务器只能读取cookie键值对，读不到属性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
Notice that the cookie attributes are not returned.&lt;br&gt;
In particular,the server cannot determine from the Cookie header alone&lt;br&gt;
when a cookie will expire, for which hosts the cookie is valid,&lt;br&gt;
for which paths the cookie is valid, 
or whether the cookie was set with the Secure or HttpOnly attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
请注意，不返回cookie属性。特别是，当cookie过期时，&lt;br&gt;
服务器无法单独从Cookie标头确定，cookie对哪些主机有效，cookie的路径有效，&lt;br&gt;
或者cookie是否使用Secure或HttpOnly属性设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时在设置cookie时，客户端并不会发回结果反馈。这使得服务器不知道cookie是否被正确设置。&lt;br&gt;
这等于要从数据库读一个不知道是否干净的数据，对数据完整性有影响。&lt;/p&gt;
&lt;h4 id=&#34;解决服务器容错与键名走私smuggle&#34;&gt;解决：服务器容错与键名“走私（Smuggle）”&lt;/h4&gt;
&lt;p&gt;大多数情况下，可以用服务器逻辑容错。&lt;br&gt;
&lt;a href=&#34;https://www.owasp.org/images/a/a0/OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf&#34;&gt;OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson&lt;/a&gt;&lt;br&gt;
此报告提供了在cookie名里添加“私货”以标识属性的方法，&lt;br&gt;
比如一个cookie设置了属性&lt;code&gt;http-only&lt;/code&gt;，名字就加个前缀HTTP_ONLY_。&lt;/p&gt;
&lt;h3 id=&#34;2-domainpath属性影响完整性&#34;&gt;2. “Domain”“Path”属性影响完整性&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.3&#34;&gt;rfc6265-两个属性的设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.1.2&#34;&gt;rfc6265-两个属性在客户端的处理算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不贴原文了，简单地总结（参照维基）：&lt;/p&gt;
&lt;h4 id=&#34;path-是指域名host下的路径归属&#34;&gt;&lt;code&gt;Path&lt;/code&gt; 是指域名|Host下的路径归属。&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;比如两网站&lt;code&gt;example.com/site1/index.htm&lt;/code&gt;,&lt;code&gt;example/com/site2/index.htm&lt;/code&gt;，&lt;br&gt;
设置Path属性为&lt;code&gt;/site1&lt;/code&gt;,&lt;code&gt;/site2&lt;/code&gt;两个值以分离两个目录中的页面的cookie。&lt;/li&gt;
&lt;li&gt;有些网站的不同目录是运行不同功能的，比如两个朋友共租一个域名运营博客，用上述方式划分。&lt;br&gt;
通过这种方式可以做到分离两个博客的cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来很好，但稍有不慎（或故意为之），就可以用来绕过&lt;a href=&#34;https://en.wikipedia.org/wiki/Same-origin_policy&#34;&gt;SOE-同源策略&lt;/a&gt; 。&lt;br&gt;
比如，设置path成&lt;code&gt;/&lt;/code&gt;，好，域名下所有页面都能读该cookie了。&lt;/p&gt;
&lt;p&gt;这是一种减少网站开发人员工作量的窍门，也能被攻击者用来做窃取cookie的手段。&lt;/p&gt;
&lt;h4 id=&#34;domain-是指域名归属&#34;&gt;&lt;code&gt;Domain&lt;/code&gt; 是指域名归属。&lt;/h4&gt;
&lt;p&gt;它和&lt;code&gt;Path&lt;/code&gt;属性的缺点差不多类型，设置了&lt;code&gt;Domain&lt;/code&gt;的cookie是&lt;strong&gt;默认暴露给所有子域名&lt;/strong&gt;的。&lt;br&gt;
我们都知道，同域名不一定等于同服务器IP，所以攻击者可以劫持域名解析偷cookie。 &lt;br&gt;
因为这个原因，实际开发中一般不建议设置&lt;code&gt;Domain&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4 id=&#34;解决samesite-属性2016年不设置domain属性&#34;&gt;解决：&lt;code&gt;SameSite&lt;/code&gt; 属性(2016年)&amp;amp;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h4&gt;
&lt;h5 id=&#34;samesite&#34;&gt;&lt;code&gt;SameSite&lt;/code&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Same-site_cookie&#34;&gt;维基#Same-site_cookie&lt;/a&gt;:&lt;br&gt;
In 2016 Google Chrome version 51 introduced a new kind of cookie, the same-site cookie,&lt;br&gt;
which can only be sent in requests originating from the same origin as the target domain.&lt;br&gt;
This restriction mitigates attacks such as cross-site request forgery (XSRF).&lt;br&gt;
A cookie is given this characteristic by setting the SameSite flag to Strict or Lax.&lt;br&gt;
&lt;a href=&#34;https://tools.ietf.org/html/draft-west-first-party-cookies-07&#34;&gt;google：draft-ietf-httpbis-cookie-same-site &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年，谷歌Chrome版本51引入了一种新型cookie，即同一站点的cookie，&lt;br&gt;
只能在源自与目标域相同的源的请求中发送。此限制可缓解诸如跨站点请求伪造（XSRF）等攻击。&lt;br&gt;
通过将SameSite标志设置为Strict或Lax，可以为cookie提供此特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标准支持：截至撰文时间(2019-05)，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发支持：查到的是node.js的express、PHP7.3支持，应该还有没搜到的&lt;/li&gt;
&lt;li&gt;浏览器支持：几个主流浏览器，的新版本都已支持，不再列举名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lambdatest.com/SameSite-cookie-attribute&#34;&gt;Browser Compatibility Testing of &amp;lsquo;SameSite&amp;rsquo; cookie - LambdaTest&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;不设置domain属性&#34;&gt;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/12387338/what-is-a-host-only-cookie&#34;&gt;Stack over flow-What is a host only cookie?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之所以不设置&lt;code&gt;Domain&lt;/code&gt;属性，其实是为了激活&lt;code&gt;host-only-flag&lt;/code&gt;，&lt;br&gt;
&lt;strong&gt;当host-only-flag被设置，子域名无法访问此cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.3&#34;&gt;rfc6265-5.3.  Storage Model&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3对cookie的误用&#34;&gt;3.对cookie的误用&lt;/h3&gt;
&lt;p&gt;上面算是设计问题，下面是多数文章主要讲的，开发者对cookie的误用。&lt;/p&gt;
&lt;h4 id=&#34;http-明文传递-cookie&#34;&gt;①http 明文传递 cookie&lt;/h4&gt;
&lt;p&gt;cookie默认不加密传输，可以在传输中被坏家伙窃听或修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：设置&lt;code&gt; Secure&lt;/code&gt;属性&amp;amp;cookie加密和签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.5&#34;&gt;rfc6265-5.2.5.  The Secure Attribute&lt;/a&gt;&lt;br&gt;
&lt;code&gt;Secure&lt;/code&gt;属性保证cookie只在HTTPS环境下可被传输。&lt;/p&gt;
&lt;p&gt;和数据库设计一样，为了保险，应尽量减少数据中非必须的信息量。&lt;br&gt;
cookie值可以是随机生成的字符串（会话凭证）而不是具体信息，&lt;br&gt;
在下次登录时修改，以应对cookie窃取与重放攻击。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265:&lt;br&gt;
Servers SHOULD encrypt and sign the contents of cookies&lt;br&gt;
(using whatever format the server desires) when transmitting them to the&lt;br&gt;
user agent (even when sending the cookies over a secure channel).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当将服务器传输给用户代理时，服务器应该对cookie的内容进行加密和签名&lt;br&gt;
（使用服务器所需的任何格式）（即使通过安全通道发送cookie）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;cookie-默认可被客户端apijs-etc读取&#34;&gt;②cookie 默认可被客户端API(JS etc)读取&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;解决：设置时加 &lt;code&gt;Http-only-flag&lt;/code&gt; ，禁止客户端JS读取cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;错误规划max-ageexpires&#34;&gt;③错误规划&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准太长，简单总结：&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt;: 类似TTL，以秒计，到时删除。&lt;br&gt;
&lt;code&gt;expires&lt;/code&gt;: GMT时间字符串（Wed, 09 Jun 2021 10:18:14 GMT）,到时删除。&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt; 是 &lt;code&gt;expires&lt;/code&gt; 的一个补充性属性。没有这两个属性，cookie被视为&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Session_cookie&#34;&gt;session cookie&lt;/a&gt; 。&lt;br&gt;
cookie保留在客户端的时间越长，被攻击的可能性越高。&lt;/p&gt;
&lt;h4 id=&#34;解决谨慎设计max-ageexpires的值&#34;&gt;解决：谨慎设计&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;的值&lt;/h4&gt;
&lt;p&gt;越敏感的数据，越要设置时间短，保持用户频繁认证。&lt;/p&gt;
&lt;h2 id=&#34;attack-on-cookies-and-solution&#34;&gt;Attack on cookies and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.针对cookie窃取的攻击与相应防御&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下所有攻击手段，都能单独拉出来写好多篇技术报告|分享，&lt;br&gt;
很明显本文没有这个篇幅，因此本文征求做到全而不详，并附链接以供详求。&lt;/p&gt;
&lt;h3 id=&#34;为什么我们要攻击保护cookie&#34;&gt;为什么我们要攻击|保护cookie？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://odino.org/security-hardening-http-cookies/&#34;&gt;这篇文章&lt;/a&gt; 的一段话讲得不错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Because the data they contain is, more often than not, extremely sensitive&lt;br&gt;
— cookies are generally used to store session IDs or access tokens,&lt;br&gt;
an attacker’s holy grail.&lt;br&gt;
Once they are exposed or compromised, attackers can impersonate users,&lt;br&gt;
or escalate their privileges on your application.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为它们包含的数据通常非常敏感 - 通常用于存储会话ID或访问令牌，攻击者的圣杯。&lt;br&gt;
一旦他们暴露或受到攻击，攻击者就可以冒充用户，或者升级他们对您的应用程序的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常见攻击方式&#34;&gt;常见攻击方式&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Cookie_theft_and_session_hijacking&#34;&gt;维基百科&lt;/a&gt;总结了几种常见的攻击方式，包括攻击过程简介与防御手段，在此不复述，只提供目录。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;攻击&lt;/th&gt;
&lt;th&gt;防御&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MITM&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DNS Poisoning&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOM-Based-XSS&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http-only-flag&lt;/code&gt;&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反射型XSS+恶意代理服务器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;secure&lt;/code&gt;attr&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSRF&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;还有一类维基没提到的，针对&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS协议&lt;/a&gt; 的攻击。&lt;br&gt;
TLS协议不是完全安全的，因为设计或实现的缺陷，&lt;br&gt;
已有不少在特定情况下针对TLS的攻击出现，&lt;br&gt;
主要目的是使HTTPS降为“等同于”HTTP的情况（即复原密文为明文），&lt;br&gt;
这不是一个新方向，列举几个比较有名的攻击方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.contextis.com/en/blog/server-technologies-https-beast-attack&#34;&gt;BEAST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lucky_Thirteen_attack&#34;&gt;Lucky 13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非常见方式&#34;&gt;非常见方式&lt;/h3&gt;
&lt;p&gt;非单一的、利用知识组合各种部分的针对cookie的攻击方式，&lt;br&gt;
可惜我只找到一个。&lt;/p&gt;
&lt;h4 id=&#34;cookiejacking-rosario-valotta-2011-05linkhttpssitesgooglecomsitetentacoloviolacookiejacking&#34;&gt;①cookiejacking-Rosario Valotta-2011-05&lt;a href=&#34;https://sites.google.com/site/tentacoloviola/cookiejacking&#34;&gt;[link]&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;该方法利用了IE浏览器的“跨域交互策略”的一个漏洞，&lt;br&gt;
外部HTML的&amp;lt;iframe&amp;gt;标签可以加载本地cookie文件（本应不能）。&lt;br&gt;
恶意服务器通过一系列正常的手段获知用于构造cookie路径的信息，&lt;br&gt;
然后通过此漏洞读取cookie，并利用&lt;a href=&#34;https://www.securitysift.com/who-do-you-trust-cross-domain-content-extraction-with-clickjacking/&#34;&gt;Clickjacking&lt;/a&gt; 手段传输cookie至服务器。&lt;br&gt;
因为读的是文件，任何cookie都会被窃取。&lt;/p&gt;
&lt;p&gt;微软&lt;a href=&#34;https://digitizor.com/cookiejacking-patch/&#34;&gt;6月&lt;/a&gt; 给这个漏洞打了补丁。&lt;br&gt;
至于Clickjacking，&lt;code&gt;x-frame-options&lt;/code&gt;&lt;a href=&#34;https://www.keycdn.com/blog/x-frame-options&#34;&gt;(XFO)&lt;/a&gt; 可以防止。&lt;/p&gt;
&lt;h2 id=&#34;academic-discussion-about-cookies&#34;&gt;Academic discussion about cookies&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于cookie的学术讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本来想把理论方面作为2、3段的添头，没想到专家们已经在纸头上打过一两轮攻防了。&lt;br&gt;
故单开此段，索引几个我觉得有意思的学术文献。&lt;/p&gt;
&lt;h3 id=&#34;cookie-masking-cookie-掩盖&#34;&gt;cookie masking-cookie 掩盖&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=2714592&#34;&gt;TLS Record Protocol: Security Analysis and&lt;br&gt;
Defense-in-depth Countermeasures for HTTPS&lt;/a&gt;&lt;br&gt;
Author: Olivier Levillain etc&lt;br&gt;
Time: 2015&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个研究总结了针对TLS记录协议的5个攻击方式，并给出了两个cookie掩盖方式：&lt;br&gt;
TLS Scramble &amp;amp; MCookies，以保证在意外导致HTTP明文传输的情况下，&lt;br&gt;
继续保持cookie等秘密信息机密性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/article/10.1007%2Fs12095-018-0280-y&#34;&gt;Statistical attacks on cookie masking for RC4&lt;/a&gt;&lt;br&gt;
Author: Kenneth G. PatersonEmail author etc&lt;br&gt;
Time: 2018-02&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文验证了上篇文章两种掩盖方式理论上可被加大提供算力后破解，&lt;br&gt;
因此该掩盖方式只能提供不强的机密性。&lt;/p&gt;
&lt;h3 id=&#34;测信道攻击&#34;&gt;测信道攻击&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-319-89641-0_11&#34;&gt;Path Leaks of HTTPS Side-Channel by Cookie Injection&lt;/a&gt;&lt;br&gt;
Author: Fuqing Chen etc&lt;br&gt;
Time: 2018-04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文阐述了一种攻击方式和两种应用方面：&lt;br&gt;
利用cookie的弱同源策略（上文有提），实施cookie注入，&lt;br&gt;
用注入的cookie来推断敏感信息，进而复原一部分密文（比如请求的URL）。&lt;br&gt;
没看完，大概是利用当时浏览器的cookie路径匹配的算法的一个缺陷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-662-47854-7_6&#34;&gt;Protecting Encrypted Cookies from&lt;br&gt;
Compression Side-Channel Attacks&lt;/a&gt;&lt;br&gt;
Author: Janaka Alawatugoda etc&lt;br&gt;
Time: 2015-07&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有那么两种对TLS的攻击：&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt; 和 &lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt; （上文有提）,&lt;br&gt;
它们基于传输前压缩过程中产生的额外信息量，复现敏感信息，&lt;br&gt;
针对它们的常规解决方法是禁止传输中压缩，&lt;br&gt;
这意味着加大使用带宽资源。&lt;br&gt;
该文阐述了两种新的压缩方式，用于实现压缩并保护机密信息的功能。&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，关于此文，不包括素材阅读的，纯搜索时间，大概只有2小时多，&lt;br&gt;
因此即使是截至2019-05，此文大概还是遗漏了许多值得一提的部分，请读者海涵。&lt;/p&gt;
&lt;p&gt;其次，经过编写此文，作者对cookie的认识有了很大变化，认清了cookie能力是很有限的，&lt;br&gt;
以后编写web服务也会注意cookie的正确运用。希望各位读者也能从此文中学到知识。&lt;/p&gt;
</content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/categories/computer-security/" term="computer-security" label="computer-security" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/web-security/" term="web-security" label="web-security" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/cookie/" term="cookie" label="cookie" />
                            
                        
                            
                            
                            
                                <category scheme="https://boholder.github.io/tags/blog/" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
</feed>
