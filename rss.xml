<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>BoHolder的网站：博客，小玩意及其他</title>
        <link>https://boholder.github.io/</link>
        <description>BoHolder&#39;s site: crafts, blogs etc</description>
        <generator>Hugo 0.81.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>bottleholder@anche.no (BoHolder)</managingEditor>
        
        
            <webMaster>bottleholder@anche.no (BoHolder)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
        
        <lastBuildDate>Tue, 08 Aug 2023 17:25:16 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://boholder.github.io/rss.xml" />
        
        
            <item>
                <title>我找到了适合自己的开源项目</title>
                <link>https://boholder.github.io/blogs/join-minecraft-access-devlopment/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/join-minecraft-access-devlopment/</guid>
                <pubDate>Tue, 08 Aug 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;我正在帮忙做一个帮助视障玩家玩Minecraft的mod - &lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access&#34;&gt;minecraft-access&lt;/a&gt;，帮了大概两个多月了。这是我第一次深度参与一个开源项目。&lt;/p&gt;
&lt;h2 id=&#34;我是如何找到的&#34;&gt;我是如何找到的&lt;/h2&gt;
&lt;p&gt;得感谢Bilibili的大数据，给我推了一个盲人up主玩Minecraft的视频。我想为这方面贡献点力量，就顺藤摸瓜一通搜索，搜到了目前的项目。还好它是活跃的，我本来还担心如果没有任何相关项目是活跃的该怎么办。&lt;/p&gt;
&lt;h2 id=&#34;关于这个mod的作者&#34;&gt;关于这个mod的作者&lt;/h2&gt;
&lt;p&gt;这个mod的作者，Shoaib，挺厉害的，我在找项目的过程中发现，搜索结果中（过去的）的 Minecraft accessibility mod 大部分是他为主要开发者。目前这个mod算是把之前的各个小mod集成起来，方便下载和开发。他还在和其他人一起用C#语言开发了&lt;a href=&#34;https://github.com/khanshoaib3/stardew-access&#34;&gt;星露谷的 accessibility mod&lt;/a&gt;。他人也很好沟通，我向他介绍的一些改进建议，他大多也会接受。&lt;/p&gt;
&lt;h2 id=&#34;关于这个项目&#34;&gt;关于这个项目&lt;/h2&gt;
&lt;p&gt;这个项目很合我的口味，也正处于适合参与进去的时机：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是关于我（最）喜欢的游戏Minecraft，为Minecraft写个mod甚至是我当初选专业的一个动机。&lt;/li&gt;
&lt;li&gt;终于找到一个“不庞大”的Java项目。众所周知Java适合开发企业级应用或框架，项目都很“庞大”，很难入门。但小项目用Java我又嫌弃JVM臃肿，和嫌弃Chromium一个原因。&lt;/li&gt;
&lt;li&gt;已经落地，有现有的用户群，可以听到反馈，真的在帮助用户解决问题。软件活着要靠开发者和用户两类人同时存在。&lt;/li&gt;
&lt;li&gt;Shoaib不太适应Minecraft这种持续更新的游戏（要跟着游戏更新被迫测试和修复失效的代码），他的兴趣更多在星露谷（和其他游戏）上。我的参与让他能放下大部分这边的担子，专心去做他感兴趣的事（这边的活跃开发者只有他一个人）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个mod基本是为游戏设计一套新的适合视障者的人机交互界面，用户输入是键盘按键，mod输出是借助读屏软件API念出各种文本信息。除了正常的编程挑战乐趣之外，设计功能时要换位思考，手动测试时要闭上眼。我没系统学过人机交互的知识，每次做功能时只有一个大概的原则：用户用起来方便（更少的按键），设计符合直觉，和已有的交互类似（降低学习和记忆负担）。&lt;/p&gt;
&lt;h2 id=&#34;minecraft不适合做accessibility&#34;&gt;Minecraft不适合做accessibility&lt;/h2&gt;
&lt;p&gt;这是我在参与过程中逐渐得到的结论。我认为包括Minecraft在内的所有3D游戏都不太适合做accessibility（除了为视障者而生的游戏，如&lt;a href=&#34;https://samtupy.com/blog/2023/04/stw-early-april-update/&#34;&gt;Survive the Wild&lt;/a&gt;，游戏设计之初就考虑到）。核心论据是人机交互方面的观察：视障者的人机交互大多不是平滑连续而随机的，而是离散的。比如“指定操作目标”，是在一个既有列表中逐个选择。3D游戏中的实体有长宽高体积，环境有xyz三个方向轴，这种复杂环境对视障者的想象力、注意力和记忆力负担比较大，也不方便设计交互。&lt;/p&gt;
&lt;p&gt;Minecraft内置的accessibility功能中，针对视障者的只有对菜单的朗读（对听障者有音效方向指示的功能很好用的，我一直开着，看周围有没有岩浆和苦力怕）。我不知道Mojang有没有想过做针对视障者的accessibility，大概是太麻烦了所以没做吧。&lt;/p&gt;
&lt;p&gt;针对Minecraft的“指定操作目标”交互，从开发角度看，并不是做不到把周围可选目标组转化成一个列表，而是每个方块和实体都是可交互目标，那么长的列表用户肯定不方便用。所以目前用户的视角移动交互，我们选择了通过按键模拟视角转动，或者用户也可以很勇敢地拿起鼠标自由转动（非常容易迷失方向）。&lt;/p&gt;
&lt;p&gt;我认为目前本mod最大的交互方面的问题是——&lt;strong&gt;本mod可能会扭曲用户对Minecraft游戏的认知&lt;/strong&gt;。用户视角每指向一个方块或实体，mod就朗读出其名字和状态。实体还好，主要是方块。Minecraft最出色的设计就是通过放置一个个方块自由建造出结构。我相信人的认知是由输入构成的。在视障者尤其是没接触过Minecraft的新玩家“眼”中，Minecraft世界仅仅是由一个个方块构成的，这就是mod直接朗读出的世界。要想把多个方块“看作”结构，就需要依赖丰富的想象力，这样不仅视障者直接体验到的乐趣会大大减少，努力想象结构的过程也很费脑子。&lt;/p&gt;
&lt;p&gt;我希望这个现状会因最近新提出的需求——&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/issues/109&#34;&gt;区域地图&lt;/a&gt;而改善，这个功能提供一个鸟瞰视角，类似回合制策略游戏中的战术视角，玩家站在原地不动，通过移动光标连续读出周围环境的方块。这样玩家就不需要爬上爬下转动视角去获取方块信息了。这个功能有潜在被用作作弊的可能，但是既然材质透视挖钻石这种常见作弊，服务器也是用监控异常的矿物破坏比例而不是直接知道用户用了透视材质包，这部分就留给用户自觉遵守吧（而且不打算实现可视化（技术上很难），正常视力玩家没法方便地利用它）。&lt;/p&gt;
&lt;p&gt;我也希望有好人能针对Minecraft截图训练出一个专用的BLIP2模型之类，帮助视障者玩家“看”到身边几格之外更远更庞大的景色，比如自然生成的美景或人工建筑的结构。我不会炼丹，然后我看了下要想炼这么一个东西也挺费钱的，炼好了怎么部署保证可用性也是麻烦，鉴于现在这个mod的用户也不是很多，ROI（Return on investment）应该不好看。但是我还是希望AI能帮到视障者，不止玩游戏方面吧。&lt;/p&gt;
&lt;h2 id=&#34;这些年这么多游戏没白玩&#34;&gt;这些年这么多游戏没白玩&lt;/h2&gt;
&lt;p&gt;我惊奇的发现，在设计新功能或改善老功能时，我能从玩过的游戏中“借”来一些灵感。&lt;/p&gt;
&lt;p&gt;有个用户说，Ta确定因为砍树遗留了一些浮在天空上的原木（经典Minecraft场景吧），但Ta无法定位确切位置。当时mod已经有对内置的特定方块或实体（比如矿物方块、红石部件和动物、怪物）的扫描锁定功能了，就是类似黑魂等那种锁定拉视角，按键切换锁定目标。我就想起《塞尔达：荒野之息》里有希卡之石选择物品图鉴并扫描的功能：不显示精确的位置，离目标越近，指示器强度越强叫得越响。我借鉴这个功能&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/pull/59&#34;&gt;实现了类似的功能&lt;/a&gt;，其实只是扩展了已有的扫描锁定功能，允许用户指定目标方块或实体，并同时排除对其他预置的方块和实体的扫描，更“专注”寻找目标。&lt;/p&gt;
&lt;p&gt;上文提到的区域地图功能，我在设计功能时就联想到各种3A游戏漂亮的大地图，还有回合制策略游戏的战术视角了。我从其中借来了一些成熟的创意，比如“固定地图方向指北”，这是小地图设计的常见功能：地图随玩家视角旋转还是固定方位。&lt;/p&gt;
&lt;h2 id=&#34;minecraft真难上手&#34;&gt;Minecraft真难上手&lt;/h2&gt;
&lt;p&gt;读者们熟悉这个游戏吗？你们还记得是怎么学会这个游戏的吗？我想和我年龄相近的很多人大概是从贴吧的德芙的帖子中入门的。不聊回忆了，我的重点是，Minecraft它真难上手，我有时候教视力正常（智力也正常，甚至都比我聪明）的朋友玩Minecraft，他们也很学得为难，大概是我教得差。既然Minecraft对正常人都这么难了，想想我们的视障者用户吧。我观察到大多数熟练的用户在真正上手玩游戏之前，就已经听了很久别人玩Minecraft的视频了。比如听&lt;a href=&#34;https://www.youtube.com/watch?v=VfpHTJsn9I4&amp;amp;list=PLgENJ0iY3XBjmydGuzYTtDwfxuR6lN8KC&#34;&gt;Pixlriffs&lt;/a&gt;
的视频，我猜他在国外Minecraft玩家中享有的声誉大概和德芙类似，他教得真的很基础且详细。&lt;/p&gt;
&lt;p&gt;在玩上游戏之前，视障者用户还要安装这个mod和一些依赖mod，安装mod也不是一个简单的事，尤其是对没接触过的人来说。我写了一个&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/blob/default/doc/SET_UP_ON_WINDOWS.md&#34;&gt;啰嗦的教程&lt;/a&gt;来降低这个门槛，至少有人再问时我可以直接发链接而不是重复打字了，已经帮到了好几个人。啰嗦对视障者来说应该不是问题，他们有很高的文本理解速度。&lt;/p&gt;
&lt;p&gt;然后视障者用户面临的最后一道难关就是微软写的那官方启动器。主要缺点是界面嵌套层次太多，无用按钮太多，设置位置混乱。这些对普通用户来说不过是多点点鼠标四处看看，对视障者来说这界面就是迷雾森林。不信？看看我教程里&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/blob/default/doc/SET_UP_ON_WINDOWS.md#start-the-game&#34;&gt;对这段的描述&lt;/a&gt;写得多繁琐（我承认我写得也啰嗦），或者去启动器里按按Tab和回车，目标只是简单地按下“启动游戏”按钮，数数要按几次。&lt;/p&gt;
&lt;h2 id=&#34;关于视觉障碍&#34;&gt;关于视觉障碍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;没依据但广泛流传的：在我们从外界获取的信息中，视觉输入占据90%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从正常视力到全盲，并不是0-1 boolean。比如极高度数的近视，也算视觉障碍。或者视野不完整，或者只能感到亮度等等，都是视觉障碍。色盲也算视觉障碍，只是对生活的影响比较小。我有个医生朋友对我说过，临床医学上哪个领域复杂，看哪个有专门的科室就是，比如牙科，儿科，还有眼科。所以眼的情况大概是比较复杂的。&lt;/p&gt;
&lt;p&gt;刚开始我小心翼翼地用 visually impaired players 指代用户，但后来发现用户们也不介意，自称就是blind，那blind更方便敲，就blind吧。国内也是，我没有盲人朋友，但我搜到的盲人论坛之类，也不会用视障者这个词。我比较在意的是哪个词在与盲人口语交流时更亲近，叫视障者是不是显得很陌生？&lt;/p&gt;
&lt;p&gt;平时用户们也不太聊生活，我很少知道一个用户是男是女（如果Ta是性少数，从profile和头像中能看出来）。但是我比较清楚哪个用户的视觉障碍类型是什么（活跃用户不多，记得住）。我没有主动询问过用户相关情况，答疑时如果不清楚，就按全盲对待。但即使是大面积的视野缺失，也比全盲等情况方便玩游戏一些，我知道有一对视野缺失的夫妻还会玩慢节奏的FPS。&lt;/p&gt;
&lt;h2 id=&#34;关于星露谷-accessibility-mod&#34;&gt;关于星露谷 accessibility mod&lt;/h2&gt;
&lt;p&gt;Shoaib认为星露谷是有潜力做到100% accessibility的，这的确很令人兴奋，我很高兴视障者可以完整体验这款优秀的游戏。星露谷也还在更新。我猜是因为没有大改原有的代码，所以跟进开发新版本mod更方便。或者是因为星露谷&lt;a href=&#34;https://www.stardewvalley.net/1-5-6-out-now-on-steam-gog/&#34;&gt;上次1.5.6更新是在2021年底&lt;/a&gt;，1.6更新风声不断但直到2023今日迟迟不推出，而Minecraft一年更新一个minor，一年内几次fix，后者的更新频率还是比较高的。在&lt;a href=&#34;https://discord.gg/yQjjsDqWQX&#34;&gt;我们的Discord服务器&lt;/a&gt;中，星露谷mod的频道也远比Minecraft
mod频道热度高，大概是因为上文讨论过的星露谷比Minecraft更容易上手（而且那边活跃开发者也更多）。&lt;/p&gt;
&lt;h2 id=&#34;尾&#34;&gt;尾&lt;/h2&gt;
&lt;p&gt;总之各位如果有兴趣，也欢迎来参与这两个mod的开发。星露谷那边用户报issue挺多的，Minecraft这边目前是用户提一个需求&lt;del&gt;我&lt;/del&gt;慢慢实现一个，有&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/issues&#34;&gt;少数积压的issue&lt;/a&gt;，比如目前仍然&lt;a href=&#34;https://github.com/khanshoaib3/minecraft-access/issues/22&#34;&gt;不适配macOS系统&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;希望各位也能遇到心仪的开源项目，关键是兴趣+技术栈匹配，其实看到项目。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/life/">life</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Java9到17我关心的新特性</title>
                <link>https://boholder.github.io/blogs/java-9-to-17/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/java-9-to-17/</guid>
                <pubDate>Wed, 29 Mar 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;只记录未来开发时可能用到的特性。
都2023年了，真正可能用的版本只有11和17，不关心特性到底在哪个中间版本脱离preview了。&lt;/p&gt;
&lt;h1 id=&#34;java9&#34;&gt;Java9&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/new-java-9&#34;&gt;https://www.baeldung.com/new-java-9&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;新的HTTP client&lt;/strong&gt;
&lt;code&gt;HttpClient&lt;/code&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;code&gt;HttpResponse&lt;/code&gt;
builder构造HTTP请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Try-With-Resources&lt;/strong&gt;
能close掉在try之前定义的auto-closable资源，
只要资源是final or effectively final。
Effectively final means that the variable can&amp;rsquo;t be changed once it has been initialized.
不显式地加final也行，IDE会提示的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Interface Private Method&lt;/strong&gt;
帮助分解复杂的default方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JShell&lt;/strong&gt;
is read–eval–print loop – REPL for short.不需要定义Main来测试代码片段了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;jshell&amp;gt; /save c:\develop\JShell_hello_world.txt
jshell&amp;gt; /open c:\develop\JShell_hello_world.txt
Hello JShell!
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用jcmd在不重启JVM的情况下修改JVM参数。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;java10&#34;&gt;Java10&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-10-overview&#34;&gt;https://www.baeldung.com/java-10-overview&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Var&lt;/strong&gt;
var is not a keyword – this ensures backward compatibility for programs using var say, as a function or variable name.
var is a reserved type name.
意思是，仍然能用var作为变量名，因为它不在Java的词法里，是语法分析阶段判断的。
&lt;a href=&#34;https://stackoverflow.com/questions/49102553/what-is-the-conceptual-difference-between-a-restricted-keyword-and-reserved-t&#34;&gt;https://stackoverflow.com/questions/49102553/what-is-the-conceptual-difference-between-a-restricted-keyword-and-reserved-t&lt;/a&gt;
使用是有限制的：
is available only for local variables (with the initializer).
其实有些不new的情况也能用，比如返回值，但不推荐，减少可读性。
From &lt;a href=&#34;https://www.baeldung.com/java-10-local-variable-type-inference&#34;&gt;https://www.baeldung.com/java-10-local-variable-type-inference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** &lt;strong&gt;[List|Set|Map]copyOf()&lt;/strong&gt; 是浅拷贝，里面是DTO的话不会调用DTO的clone，不要用。&lt;/p&gt;
&lt;h1 id=&#34;java11oracle-jdk转商用201809&#34;&gt;Java11(Oracle JDK转商用)（201809）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-11-new-features&#34;&gt;https://www.baeldung.com/java-11-new-features&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Collection转array&lt;/strong&gt;
String[] sampleArray = sampleList.toArray(String[]::new);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Local-Variable Syntax for Lambda&lt;/strong&gt;
用这个语法给lambda变量加注解&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resultString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sampleList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Nonnull&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toUpperCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;joining&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nestmate概念（不需要记）&lt;/strong&gt;
&lt;a href=&#34;https://www.baeldung.com/java-nest-based-access-control&#34;&gt;https://www.baeldung.com/java-nest-based-access-control&lt;/a&gt;
对程序员来说，有新的Reflection API。
外部类和内部类互为nestmate：外部类同时为外部类和内部类的NestHost，
外部类和内部类互相加为NestMembers.这样JVM能省点事。
nestmate互相能在编码时读private成员，像以前一样。
以前用Reflect API不能读，现在能了。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getNestHost&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;java12201903&#34;&gt;Java12（201903）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-12-new-features&#34;&gt;https://www.baeldung.com/java-12-new-features&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;String.transform()&lt;/strong&gt; ，接受一个Function应用到字符串上，返回另一个字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transformed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;transform&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringBuilder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;reverse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Teeing Collector in Stream API&lt;/strong&gt;,
接受两个Collector和一个merge函数，合并两Collector结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Stream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;teeing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;summingDouble&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Collectors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;counting&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;instanceof 后定义变量名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;java13201909&#34;&gt;Java13（201909）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-13-new-features&#34;&gt;https://www.baeldung.com/java-13-new-features&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没有release出的值得注意的&lt;/p&gt;
&lt;h1 id=&#34;java14202003&#34;&gt;Java14（202003）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-14-new-features&#34;&gt;https://www.baeldung.com/java-14-new-features&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Switch语法函数式更新&lt;/strong&gt; 执行可不返回值。若使用函数体{}且要返回值，要用 &lt;code&gt;yield&lt;/code&gt; 而非 &lt;code&gt;return&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;typeOfDay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dayOfWeek&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MONDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TUESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WEDNESDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;THURSDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FRIDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Working Day&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SATURDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SUNDAY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Day Off&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;What&amp;#39;s a &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;day&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Text Block 多行字符串&lt;/strong&gt; 不需要转义双引号！所有String方法都支持。但有两个其他的转义：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\ &lt;/code&gt; to indicate the end of the line, so that a new line character is not introduced&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; to indicate a single space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TEXT_BLOCK_JSON&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;{
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Baeldung&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;,
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;website&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; : &amp;#34;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//www.%s.com/&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Records&lt;/strong&gt;
&lt;a href=&#34;https://www.baeldung.com/java-record-keyword&#34;&gt;https://www.baeldung.com/java-record-keyword&lt;/a&gt;
全参数构造方法override有些奇怪，加上全参数会报错。
因为字段全是final所以不会有Setter方法，只生成Getter。
适合定义只读的结构复杂些的常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;record&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Objects&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;requireNonNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Objects&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;requireNonNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Unknown&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更好的NPE位置报错&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;java15202009&#34;&gt;Java15（202009）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-15-new&#34;&gt;https://www.baeldung.com/java-15-new&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sealed Classes&lt;/strong&gt;
两个新关键字：&lt;code&gt;sealed&lt;/code&gt;,&lt;code&gt;permits&lt;/code&gt;
控制父类拥有有限的子类。
子类需声明为 &lt;code&gt;sealed&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;non-sealed&lt;/code&gt;。 &lt;code&gt;non-sealed&lt;/code&gt;是给扩展留的口子。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;permits&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Employee&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Manager&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Employee&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;non&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sealed&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Manager&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Foreign Memory API&lt;/strong&gt;
在JVM Heap之外操作JVM内存，不会被GC，所以可以处理大段的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;java16202103&#34;&gt;Java16（202103）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-16-new-features&#34;&gt;https://www.baeldung.com/java-16-new-features&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;能用反射API调用接口的default方法了&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stream.collect(Collectors.toList()); 简化成 Stream.toList()，还有toSet()。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;java17202109&#34;&gt;Java17（202109）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/java-17-new-features&#34;&gt;https://www.baeldung.com/java-17-new-features&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用可指定JVM中预定义的反序列化前Filter的算法&lt;/strong&gt;
&lt;a href=&#34;https://openjdk.org/jeps/290&#34;&gt;https://openjdk.org/jeps/290&lt;/a&gt;
&lt;a href=&#34;https://openjdk.org/jeps/415&#34;&gt;https://openjdk.org/jeps/415&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LTS间隔缩短到两年&lt;/strong&gt;，让202309发布的Java21成为下一个LTS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java17那个preview的switch pattern matching真香，能省掉不少if-else-大括号，可惜在preview。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>为anime角色训练LoRA模型</title>
                <link>https://boholder.github.io/blogs/train-a-lora-model-for-an-anime-character/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/train-a-lora-model-for-an-anime-character/</guid>
                <pubDate>Tue, 14 Mar 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;之前看到&lt;a href=&#34;https://twitter.com/fuyufjh&#34;&gt;Eric Fu&lt;/a&gt;发布的《狼与香辛料》中的赫萝的&lt;a href=&#34;https://civitai.com/models/16104/holo-spice-and-wolf&#34;&gt;LoRA模型&lt;/a&gt;。心里燃起一股冲动，谁不想为自己老婆炼一份模型呢，赶紧搜搜看怎么做。从基本一无所知到训练成功花了一天多，记录过程供大家参考。&lt;/p&gt;
&lt;p&gt;完成这个事需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对Python编写和环境搭建有一定了解，ML项目或者老项目免不了有点依赖冲突。为了避免依赖混淆，我给每个工具都准备了独立的venv。&lt;/li&gt;
&lt;li&gt;如果电脑是Nvidia支持cuda的GPU，记得每个项目安装依赖前先把pytorch-cuda给装了，这个用GPU，pytorch是用CPU的。安装参考&lt;a href=&#34;https://github.com/openai/whisper/discussions/47&#34;&gt;这个讨论&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;一台不错的电脑，即使最后训练配置不够，是用colab之类在云上跑，数据集预处理之类还是本地跑比较方便。最后我是在本地炼的。装的是pytorch-cuda，最后torch还是选择了用CPU跑，不是很懂怎么回事，但也有好处：虽然慢但不用担心内存溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用到的工具/项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;著名的&lt;a href=&#34;https://github.com/AUTOMATIC1111/stable-diffusion-webui&#34;&gt;stable-diffusion-webui&lt;/a&gt;（预处理数据）&lt;/li&gt;
&lt;li&gt;模型：&lt;a href=&#34;https://github.com/SkyTNT/anime-segmentation&#34;&gt;anime-segmentation - SkyTNT&lt;/a&gt;（扣除图片的背景）&lt;/li&gt;
&lt;li&gt;模型：&lt;a href=&#34;https://github.com/qhgz2013/anime-face-detector&#34;&gt;anime-face-detector - qhgz2013&lt;/a&gt;（面部识别+裁剪）&lt;/li&gt;
&lt;li&gt;用&lt;a href=&#34;https://github.com/Akegarasu/lora-scripts&#34;&gt;lora-scripts - Akegarasu&lt;/a&gt;控制&lt;a href=&#34;https://github.com/kohya-ss/sd-scripts&#34;&gt;sd-scripts - kohya-ss&lt;/a&gt;训练&lt;a href=&#34;https://github.com/KohakuBlueleaf/LyCORIS&#34;&gt;LyCORIS (LoCon改进型?)&lt;/a&gt;模型（能凑出这个名字作者真爱啊）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外注意一下，模型各有专长，我这套流程用到的工具都是针对anime角色的，如果炼真人（比如以&lt;a href=&#34;https://huggingface.co/swl-models/chilloutmix&#34;&gt;Chilloutmax&lt;/a&gt;为基底模型）的话，要另寻相同用途的工具。如果不是训练LoRA模型，而是训练embedding(textual inversion)，所需要数据集的形式会和本文有差异。&lt;/p&gt;
&lt;h2 id=&#34;一些懂了更好的前置知识&#34;&gt;一些懂了更好的前置知识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Stable Diffusion 是个text-img模型，它通过观察图片逐步加噪声学会了如何反向给噪声图片去噪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;article: &lt;a href=&#34;https://www.paepper.com/blog/posts/how-and-why-stable-diffusion-works-for-text-to-image-generation/&#34;&gt;How and why stable diffusion works for text to image generation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;video: &lt;a href=&#34;https://www.youtube.com/watch?v=-lz30by8-sU&#34;&gt;Stable Diffusion in Code (AI Image Generation) - Computerphile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LoRA是一种fine-tune（模型微调）技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;article: &lt;a href=&#34;https://huggingface.co/blog/lora&#34;&gt;Hugging face: Using LoRA for Efficient Stable Diffusion Fine-Tuning&lt;/a&gt;, &lt;a href=&#34;https://www.cnblogs.com/huggingface/p/17108402.html&#34;&gt;中文译文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;几种微调技术的对比：video: &lt;a href=&#34;https://www.youtube.com/watch?v=dVjMiJsuR5o&#34;&gt;LoRA vs Dreambooth vs Textual Inversion vs Hypernetworks&lt;/a&gt;, 不想看视频还有&lt;a href=&#34;https://www.reddit.com/r/StableDiffusion/comments/10cgxrx/wellresearched_comparison_of_training_techniques/&#34;&gt;一张直观的对比图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kohya-ss/sd-scripts/blob/main/train_README-ja.md#%E5%AD%A6%E7%BF%92%E3%81%A7%E4%BD%BF%E3%82%8F%E3%82%8C%E3%82%8B%E7%94%A8%E8%AA%9E%E3%81%AE%E3%81%94%E3%81%8F%E7%B0%A1%E5%8D%98%E3%81%AA%E8%A7%A3%E8%AA%AC&#34;&gt;学習で使われる用語のごく簡単な解説&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了这些“基础知识”，实践过程中看到不明白的名词就搜一下看看概念，这些名词会逐渐连成知识体系。现在的AI生成的参数大多是专业术语，为了弄清楚设置什么值合适，只好自己去学习其含义，在理解的基础上操作。我发现&lt;code&gt;&amp;quot;&amp;lt;不懂的名词&amp;gt;&amp;quot; [ML|stable diffusion|fine-tune|lora]&lt;/code&gt;关键字搜索效果好（只搜名词容易被更一般的含义混淆搜索结果，加一个领域词好很多）。&lt;/p&gt;
&lt;h2 id=&#34;准备数据集&#34;&gt;准备数据集&lt;/h2&gt;
&lt;h3 id=&#34;收集图片&#34;&gt;收集图片&lt;/h3&gt;
&lt;p&gt;我先搜到了&lt;a href=&#34;https://bennycheung.github.io/stable-diffusion-training-for-embeddings&#34;&gt;Stable Diffusion Training for Personal Embedding&lt;/a&gt;这篇文章，其中提到&lt;a href=&#34;https://www.youtube.com/watch?v=P1dfwViVOIU&#34;&gt;这个视频&lt;/a&gt;讲到训练个人肖像模型需要：三张不同角度全身图，五张不同角度半身图，十二张不同角度面部图。准备这个数据集可简单，找个白墙自拍就行，反正模特是自己。&lt;/p&gt;
&lt;p&gt;虚拟人物可不能给我摆拍&amp;hellip;&amp;hellip;去哪找图片？这个要分角色，是否载体作品有多种多媒体衍生，是否热门角色&amp;hellip;&amp;hellip;都有影响。比如Eric Fu的赫萝用了轻小说的插图和漫画。我要炼的是一位不太热门的角色，能截到的“官方图片”不多，不过我从Eric Fu那得知“设定需接近，画风可以有些变化”，所以&amp;hellip;&amp;hellip;我打开了同人图收藏目录，加上“官方图片”挑了约莫一百张图（什么，没有收藏目录？爱还不够啊）&lt;strong&gt;（虽然我觉得自己玩玩不发布没什么大不了的，但用同人图炼模型这件事在部分人看来是十恶不赦的。这里说清，如果用同人图训练，别声张别发布，我是没图了才用的）&lt;/strong&gt;
。结合结果来看，效果也还行。&lt;/p&gt;
&lt;p&gt;不知是否合适，我个人挑选图片的标准是“特征明显”，炼就是炼特征嘛。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;✔️人物装扮“符合官方设定”（大部分图片都会符合的）&lt;/li&gt;
&lt;li&gt;✔️人物装扮非设定，但发型、面部细节等“很像”&lt;/li&gt;
&lt;li&gt;✔️多人图，舍不得的话截一下能用&lt;/li&gt;
&lt;li&gt;❌受环境光影影响导致人物色调变化很大&lt;/li&gt;
&lt;li&gt;❌画师画风非常独特，或者太好看了超出了平均值&lt;/li&gt;
&lt;li&gt;❌非彩色图片&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;去除背景&#34;&gt;去除背景&lt;/h3&gt;
&lt;p&gt;是这样，首先我观察到刚刚炼肖像的两位的肖像照，似乎特意挑选了白色背景拍照。然后我看过&lt;a href=&#34;https://www.youtube.com/watch?v=WO2X3oZEJOA&#34;&gt;Glitch Tokens - Computerphile&lt;/a&gt;这个视频，视频中提到研究人员发现某模型对哑铃文字学到的图像特征是有肌肉的上臂。这些让我不禁猜测图片背景对人物特征学习是一种噪音，所以我决定把背景删掉。（后来我学到可以用&lt;a href=&#34;https://github.com/rinongal/textual_inversion/issues/131&#34;&gt;caption&lt;/a&gt;把图片中的某些特征做减法，让模型不要学，但我觉得这样也不如直接删背景来得效果好。）&lt;/p&gt;
&lt;p&gt;2023年了，用普通用户的关键字&lt;code&gt;photo remove background&lt;/code&gt;在茫茫想赚你钱的网站中找个自动去背景的工具可累了，倒是找到一个Photoshop脚本，但效果不尽人意。经朋友推荐有这么一个项目&lt;a href=&#34;https://github.com/SkyTNT/anime-segmentation&#34;&gt;anime-segmentation - SkyTNT&lt;/a&gt;，让我发现了&lt;a href=&#34;https://www.tensorflow.org/tutorials/images/segmentation&#34;&gt;image segmentation&lt;/a&gt;图像分割这个ML细分领域，而且朋友给的这个项目的效果已经非常好了。谢谢你，我的朋友。&lt;/p&gt;
&lt;p&gt;Python3.9搭建成功，要注意它似乎只支持png和jpg格式的输入。这样我们把原图转为了png格式的只剩下人物的透明背景图。有些输出可能没有去除干净，我没有麻烦自己再手动去除。&lt;/p&gt;
&lt;h3 id=&#34;无效操作扩大图片尺寸到正方形&#34;&gt;无效操作：扩大图片尺寸到正方形&lt;/h3&gt;
&lt;p&gt;我先实验了一次resize，发现这样会截掉图片的边角部分。但是我不想丢掉任何特征（尤其是稀少的官方设定服饰的鞋子），于是在网上找了个&lt;a href=&#34;https://community.adobe.com/t5/photoshop-ecosystem-discussions/canvas-resize-to-square-for-a-large-number-of-images-using-script/td-p/6148635&#34;&gt;Photoshop脚本&lt;/a&gt;，把所有图片按照长和宽中大的那个把图片扩展成正方形了，这样resize时会把整个图片resize。事后证明这个步骤&lt;strong&gt;毫无作用&lt;/strong&gt;，把特征变得更小更模糊了，反而不利于训练。&lt;/p&gt;
&lt;h3 id=&#34;裁剪面部&#34;&gt;裁剪面部&lt;/h3&gt;
&lt;p&gt;根据肖像数据集的说法，面部（到肩部）图片的占比不少。但是同人图画肯定不会只画个证件照，看来面部图片要从同人图（透明背景）里截出来。这回尝到ML的甜头了，直接搜&lt;code&gt;anime face detect ML&lt;/code&gt;，Github&lt;a href=&#34;https://github.com/search?q=anime+face+detect&#34;&gt;给出了一些项目&lt;/a&gt;。挑项目，尤其挑Python ML项目（要基于项目写两行代码把图片裁出来保存），比起star我更在意开发时间，生怕年代久远的项目依赖有问题。&lt;a href=&#34;https://github.com/hysts/anime-face-detector&#34;&gt;anime-face-detector - hysts&lt;/a&gt;
是最新的，两年前开发，但是折腾了很久也没解决关于mmcv的依赖的版本问题。转向第二新（三年前开发）的项目&lt;a href=&#34;https://github.com/qhgz2013/anime-face-detector&#34;&gt;anime-face-detector - qhgz2013&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;哎，Python3.9成了，于是我fork了项目&lt;a href=&#34;https://github.com/boholder/anime-face-detector/commit/afc906d49fe03aeaea457ae4d0f0523d09b62a57&#34;&gt;改了两行&lt;/a&gt;，让裁剪出的图片大于面部识别结果，把发型和肩部和兽耳（兽耳往上长的）也截下来（谢谢qhgz2013已经开发了crop功能，省事了）。这样从每张图截取出面部，训练集大小翻个倍。&lt;/p&gt;
&lt;h3 id=&#34;resize--caption&#34;&gt;resize + caption&lt;/h3&gt;
&lt;p&gt;现在算是收集好了原始数据集，打开web-ui -&amp;gt; Train -&amp;gt; Preprocess images，按照&lt;a href=&#34;https://dfldata.xyz/forum.php?mod=viewthread&amp;amp;tid=12796&#34;&gt;这个教程&lt;/a&gt;中的步骤来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把图片resize到512*512（虽然LoRA是支持非该大小的，但我没太明白LoRA对训练集图片的要求，为了保险还是经典512（stable diffusion v1.*版本的输入图片大小）吧）。&lt;/li&gt;
&lt;li&gt;勾上&lt;code&gt;Auto focal point crop&lt;/code&gt;焦点聚集&lt;/li&gt;
&lt;li&gt;勾上&lt;code&gt;Use Deepbooru for caption&lt;/code&gt;用&lt;a href=&#34;https://github.com/KichangKim/DeepDanbooru&#34;&gt;DeepDanbooru - KichangKim&lt;/a&gt;这个为anime角色训练的图片tag提取模型，自动为训练集标注tag，存这些tag的文件（或这些tag的集合）叫caption，如上文所述，作用是不让模型学（=强化这些tag的权重）这些标注的特征，专注于学习“新的”（角色）特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们终于把训练集准备好了，一堆512*512的图片和对应的caption文本文件。根据结果来看，face detect、 web-ui两者生成的图片都把透明背景替换成了黑色纯色背景，这些黑色背景的训练集确实会影响结果模型的生成效果，在不给背景tag的时候，倾向于生成简单背景（simple background）或黑色纯色背景，但是给了背景tag，生成就正常了，无需担心。&lt;/p&gt;
&lt;h3 id=&#34;检查与修改caption&#34;&gt;检查与修改caption&lt;/h3&gt;
&lt;p&gt;资料：&lt;a href=&#34;https://github.com/rinongal/textual_inversion/issues/131&#34;&gt;Do image captions have any effect during training?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经过进一步搜索与实验，我发现caption对模型的训练和使用有很大用途。我&lt;a href=&#34;https://github.com/boholder/tools_for_training_sd_model&#34;&gt;写了几个简单脚本&lt;/a&gt;做相关的自动化工作。我训练的角色是手机游戏公主连结里的&lt;a href=&#34;https://gamewith.jp/pricone-re/article/show/92907&#34;&gt;姫宮真歩&lt;/a&gt;，以她作为示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://boholder.github.io/img/postimg/maho_by_ai.png&#34; alt=&#34;an anime girl picture generated by AI&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;# 链接网站中的官方形象和AI生成图的形象相似度非常高，很开心

(masterpiece:1.331), best_quality,
(1girl:1.21),
fox_ear, fox_tail,
(brown|gold) hair, long_hair, hair_tubes, blunt_bangs,
green_eyes, narrowed_eyes,
medium_breasts,
smile,
print_kimono, frills, maid_headdress, hair_flower,
sit,
nature,
looking_at_viewer,
&amp;lt;lora:himemiyamaho:0.7&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;对于训练&#34;&gt;对于训练&lt;/h4&gt;
&lt;p&gt;通过把角色特征浓厚的tag从caption中删除，可强化模型学习那些特征。这些特征应该是在未来你想生成的&lt;strong&gt;所有&lt;/strong&gt;场景中该角色都具有的（比如眼镜的志村新八）。比如服饰不该被删除，因为不同场景角色服饰会变。对于真步，我删除了以下tag：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;blunt_bangs&lt;/code&gt;: 平刘海。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eyebrows_visible_through_hair&lt;/code&gt;: 所谓图层错误眉毛，在真步上不明显，其他角色如&lt;a href=&#34;https://disp.cc/b/ACG/ftGJ&#34;&gt;犬山葵&lt;/a&gt;更是当官方梗玩。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;low_twintails&lt;/code&gt;: 扎在低位的双马尾。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*_breasts&lt;/code&gt;: 为什么要删除胸部tag？不删除这类tag训练出的初版模型，在不指定胸部大小的情况下100%生成巨乳。故删了tag让模型学学真步的真实。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我没删除诸如&lt;code&gt;fox_ear, fox_tail, (brown|gold) hair, long_hair, green_eyes,&lt;/code&gt;这些非常基础的特征，以我目前的知识储备判断，这些删了也可以。&lt;/p&gt;
&lt;p&gt;有想要避免的特征，在每张图片的caption中都加上对应tag，极力避免模型去学习。对于真步，我删除了&lt;code&gt;bare_shoulders（露肩膀）&lt;/code&gt;。抽卡手机游戏嘛，换皮，真步有好几套衣服，我用来训练的同人图大多是通常服（如图所示的和服）和泳装两套。在训练出的初版模型中，我观察到生成的绝大多数通常服图片，都是像花魁一样露肩膀的，不符合真步的角色印象。开始我以为是模型把泳装的露肩学混了，之后检查训练集发现原来我用的同人图里不少通常图也是露肩的。图片不方便另外收集，怎么解决这个问题？最后我想到用caption控制，实验发现效果不错，终于不再露肩膀了。&lt;/p&gt;
&lt;h4 id=&#34;对于使用&#34;&gt;对于使用&lt;/h4&gt;
&lt;p&gt;对所有caption文件内容做统计，可直观得知如果想生成目标角色该用什么tag。对于我这英语词汇量不过关的人非常开眼界，学到好多新单词，它们能帮你更精确地与模型沟通。&lt;/p&gt;
&lt;p&gt;caption帮助模型在学习时理解训练集中的图片：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;训练图片的prompt&lt;/strong&gt; = &lt;strong&gt;caption&lt;/strong&gt;（模型不学的）+ &lt;strong&gt;模型学到的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等到使用时我们就可以把这个公式倒过来：通过查看caption得知的tags + 模型 = 看起来像训练图片的结果！如果你想生成和训练集中某图片相似的结果，看一下它的caption吧。&lt;/p&gt;
&lt;h2 id=&#34;开炼&#34;&gt;开炼&lt;/h2&gt;
&lt;p&gt;首先我的fine-tune技术就是跟着Eric Fu选的LoRA，因为我听说LoRA技术不仅在时间线上更新鲜，而且似乎对内存需求低。然后LoRA也分几个算法，跟着选的&lt;a href=&#34;https://github.com/KohakuBlueleaf/LyCORIS&#34;&gt;LyCORIS&lt;/a&gt;模型，走别人已经验证过可行性的路准没错，而且自己也没有足够ML知识做选型。LyCORIS的README和顺着&lt;a href=&#34;https://dfldata.xyz/forum.php?mod=viewthread&amp;amp;tid=12796&#34;&gt;论坛教程&lt;/a&gt;找到的&lt;a href=&#34;https://github.com/Akegarasu/lora-scripts&#34;&gt;lora-scripts - Akegarasu&lt;/a&gt;
项目的README都指向这个项目：&lt;a href=&#34;https://github.com/kohya-ss/sd-scripts&#34;&gt;sd-scripts - kohya-ss&lt;/a&gt;。他们三者的关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sd-scripts 集成了方便直接使用的fine-tune脚本，可以炼所有四种fine-tune方式。&lt;/li&gt;
&lt;li&gt;lora-scripts 进一步针对LoRA训练简化了对sd-scripts的使用，而且每个参数都有推荐值，帮大忙了。&lt;/li&gt;
&lt;li&gt;运行sd-scripts时用参数指定LyCORIS为算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python3.10，先安装lora-scripts（同时会安装sd-scripts的依赖），再install LyCORIS库，这三个项目共用一个venv。基底模型用的&lt;a href=&#34;https://huggingface.co/andite/anything-v4.0&#34;&gt;anything-v4.5&lt;/a&gt;。我&lt;a href=&#34;https://github.com/boholder/lora-scripts/commit/0780625ad726a0a03f9f3cb2b3ec19131e5ce582&#34;&gt;改了一下&lt;/a&gt;lora-scripts，加上了关于LyCORIS的新参数。这里注意sd-scripts是在lora-scripts目录下的，但运行配置中的数据集目录似乎要加上&lt;code&gt;..&lt;/code&gt;父目录（sd-scripts运行时的work directory是自己本目录？）。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;如果我能用通过&lt;a href=&#34;https://distill.pub/2017/feature-visualization/&#34;&gt;Feature Visualization&lt;/a&gt; （对图片任务模型）、token聚类（对文本任务模型）这些技术可视化地研究一下我生成的LoRA模型内部就好了，好奇它学了真步哪些特征。搜了下还没有基于stable diffusion模型的现成工具，作罢。另外我仍然对caption如何起作用不太清楚，但在网上搜不到更多解释。如果你知道相关材料，请不惜赐教。&lt;/p&gt;
&lt;p&gt;祝大家都能炼出自己老婆，实现妄想自由。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/fun/">fun</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/stablediffusion/">StableDiffusion</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>关于SSTV的知识</title>
                <link>https://boholder.github.io/blogs/sstv-intro/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/sstv-intro/</guid>
                <pubDate>Thu, 23 Feb 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;谢谢&lt;a href=&#34;https://www.youtube.com/watch?v=q9chAP5AmCU&#34;&gt;乔伊的视频&lt;/a&gt;让我对无线电产生了兴趣。&lt;/p&gt;
&lt;h2 id=&#34;补一补专业知识&#34;&gt;补一补专业知识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.shuxuele.com/algebra/amplitude-period-frequency-phase-shift.html&#34;&gt;数学上的波，频率、幅度、位移的感念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37535928&#34;&gt;信号调制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;载波（carrier）：作为传输基底的纯净的固定周期（频率）的高频率信号。&lt;/p&gt;
&lt;p&gt;调制（modulation）：动词或动名词，一种信号处理方式，通过往指定的载波中嵌入真正想传递的信号（信息）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要调制：
&lt;ol&gt;
&lt;li&gt;发信号的天线长度要不小于信号波长十分之一，高频波长短，容易用较短的天线辐射出去。&lt;/li&gt;
&lt;li&gt;通过调制人工将不同信号隔离在不同频率，信号不串台。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;调制分为数字调制和模拟调制，指的是原始信息的形式
&lt;ul&gt;
&lt;li&gt;数字是01（比如无线网卡）&lt;/li&gt;
&lt;li&gt;模拟是个连续的波（比如麦克风直连电台发信器）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模拟调制的几种方式中有我们收音机上会看到的FM、AM，英语字面缩写。
&lt;ul&gt;
&lt;li&gt;Frequency modulation是调频（频率越高图示的线越横向密集，声音越尖）。&lt;/li&gt;
&lt;li&gt;Amplitude modulation是调幅（幅度越大图示的线谷峰高低差越大，声音越响）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sstv格式&#34;&gt;SSTV格式&lt;/h2&gt;
&lt;p&gt;SSTV（slow-scan television，慢扫描电视）是一种将图片信息嵌入音频信号（并发送）的方式。SSTV选用的方式是FM，把图片的像素亮度映射为频率，越亮频率越高，彩色图片是发送颜色各自的亮度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sigidwiki.com/wiki/Slow-Scan_Television_%28SSTV%29&#34;&gt;https://www.sigidwiki.com/wiki/Slow-Scan_Television_%28SSTV%29&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Slow-scan_television&#34;&gt;https://en.wikipedia.org/wiki/Slow-scan_television&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yumpu.com/en/document/read/7259948/proposal-for-sstv-mode-specifications&#34;&gt;https://www.yumpu.com/en/document/read/7259948/proposal-for-sstv-mode-specifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sstv-handbook.com/&#34;&gt;https://www.sstv-handbook.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就像网络通信协议一样，在发送真正的数据前，SSTV会发送校准头（calibration header），虽然没搜到后者，但感觉和令人怀念的&lt;a href=&#34;https://www.youtube.com/watch?v=QDS4B0mM-ew&#34;&gt;拨号上网的开头声音&lt;/a&gt;是一样的，因为是模拟调制的校准头所以每次听都是一样的声音。&lt;/p&gt;
&lt;p&gt;校准头之后是传输模式（mode），用VIS code（vertical interval signaling）这种编码传输，每30ms跳一次频率。除去开头结尾的两个1200Hz信号，1100Hz=1，1300Hz=0，共7bit+最后奇偶校验位。这7位二进制当成数字转换成十进制，对应某个模式。比如&lt;code&gt;Robot36&lt;/code&gt;模式的数字是&lt;code&gt;8d（d=十进制）&lt;/code&gt;。这些模式是不同人发明的，但开头都是校准头和VIS，类似网络中标准协议框架和具体实现？&lt;/p&gt;
&lt;p&gt;VIS发完了，1ms都不耽搁，开始发数据。逐行从左往右从上往下，类似多图杀猫时期的图片加载。每行开始先是一个同步脉冲（sync pulse），再是真正的亮度对应的频率。如果有多个颜色就是连续发送，有些模式的颜色间可能有分隔信号用的短脉冲。数据发完就结束了，没有tail的概念。&lt;/p&gt;
&lt;p&gt;SSTV的载波可以是各种频率，比如业余无线电的UHF（300～3000MHz）和VHF（30～300MHz）或高频（3MHz~30MHz）。但是SSTV的信号本身的频率范围是1100Hz~2300Hz，在人耳听力范围（20Hz~20000Hz）内，直接从图片生成的SSTV音频，或用收音机解调（制）无线信号再用扬声器放出的声音，人耳是能听到的。&lt;/p&gt;
&lt;p&gt;解析SSTV信号，就是在音频信号里找校准头，然后顺着解析VIS，最后按模式规则解析数据，把频率反向转换回像素。重要的三要素：时长，频率，信息排列顺序。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/fun/">fun</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/sstv/">sstv</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>我在开发Puntgun中学到的东西</title>
                <link>https://boholder.github.io/blogs/what-i-learned-from-putgun/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/what-i-learned-from-putgun/</guid>
                <pubDate>Sat, 11 Feb 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/boholder/puntgun&#34;&gt;Puntgun&lt;/a&gt;是我写的一个命令行工具，Python语言，帮助推特账号管理自动化。
从2022年二月底开始写，到2022年十一月底碰到一个&lt;a href=&#34;https://github.com/boholder/puntgun/issues/17&#34;&gt;对我来说很难实现的编程问题&lt;/a&gt;，
加上当时马斯克成功收购推特，之后心思就不再它上面了。2023年2月9日，推特不再提供免费API，算是帮我下手了结了这个项目。
（从十一月的新闻我就判断马斯克不倾向于开放生态，不利好我这项目，你看果然吧，但确实没想到能做这么绝。）
这是我第一个尝试运营社区的项目，然后事情还没开始就结束啦。😂
项目框架已经写好了，可以自定义规则，示范用的规则没写几条就碰到了那个难题，算是基本实现目标吧。&lt;/p&gt;
&lt;p&gt;失败是成功之母，前提是记得总结经验，故有此文与大家分享，如果读文有感而发，请务必在评论区评论，让我学习一下你的经验。&lt;/p&gt;
&lt;h2 id=&#34;第三方开发风险大&#34;&gt;第三方开发风险大&lt;/h2&gt;
&lt;p&gt;虽然但是，推特一直是开放平台的标杆啊啊啊，oauth和雪花算法都是它给业界贡献的，开发者API全，还有官方维护API库（没Python语言）。
我觉得任谁都想不到推特能在马斯克收购后转变这么大，或者我眼光浅没有从投资角度去分析推特居然经营不善到要被收购。
第三方开发风险大，嗯，这回栽个大的。&lt;/p&gt;
&lt;p&gt;2022年初的选题思考：开发面向用户的应用型软件，比开发面向开发者的库更容易找到还没人做的空缺，也更容易吸引人气。
我是在手动Block各种奇怪Follower时发现这个选题的，像我这种小账号每次意外被大量Fo，手动筛选Follower都要花半小时，肯定有很多用户苦于没法自动化管理。
&lt;a href=&#34;https://en.wikipedia.org/wiki/Punt_gun&#34;&gt;Punt gun&lt;/a&gt;巨型猎鸟霰弹枪，用规则批量Block，我看行。后来自然而然地扩展成多用途工具，mute、打印、调用HTTP，想得很美。&lt;/p&gt;
&lt;p&gt;以后慎重选择依赖平台做第三方开发，至少不能依赖商业平台，等于把项目的命拱手让给不可控风险。&lt;/p&gt;
&lt;h2 id=&#34;原型与便签&#34;&gt;原型与便签&lt;/h2&gt;
&lt;p&gt;《程序员修炼之道》-第二章：注重实效的途径-原型与便签（翻了下书第一版也有这节）。
这节讲的是：&lt;strong&gt;如果使用原型实验可行性，记得贴个便签时刻提醒自己这是个需要无情丢掉的原型，不要投入太多，不要直接基于它做开发。&lt;/strong&gt;
我读过这书，记得这节，但我犯了这个错误，错误导致了那个至少占50%责任的编程难题。&lt;/p&gt;
&lt;p&gt;这个难题是这样形成的：&lt;/p&gt;
&lt;p&gt;我这个工具会大量调用推特API，确实是I/O bound项目。Python有现成又好用的nio包，asyncio。
我用的叫tweepy的第三方推特API库，提供两种调用，一种是&lt;a href=&#34;https://docs.tweepy.org/en/latest/client.html&#34;&gt;blocking I/O&lt;/a&gt;，一种是&lt;a href=&#34;https://docs.tweepy.org/en/latest/asyncclient.html&#34;&gt;asyncio形式&lt;/a&gt;的。
2022年初，我不会asyncio，然后我想先跑通请求验证一下可行性，之后再改成nio，就选择了blocking形式的tweepy API。
显然我没在显示器上贴便签，把这事给忘了，在开发过程中一直没替换成nio。&lt;/p&gt;
&lt;p&gt;这个工具的基本功能是“输入推文或用户信息，多个规则匹配，决定对其的操作”，是类似责任链模式的那么一种东西。
根据我的工作经验判断，这个模式很像应用网关的过滤器链，可以仿照着开发。
在我的Java开发工作中，reactive形式的WebFlux库（或RxJava库）是合适又方便的框架。
Python生态里有对标&lt;a href=&#34;https://reactivex.io/&#34;&gt;reactivex&lt;/a&gt;规范的&lt;a href=&#34;https://rxpy.readthedocs.io/en/latest/&#34;&gt;RxPy&lt;/a&gt;框架，好，用它。&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;直到我在开发将近完成时才发现rxpy和asyncio不能兼容。经过详尽搜索后（有兴趣请看&lt;a href=&#34;https://github.com/ReactiveX/RxPY/issues/669&#34;&gt;我提的issue&lt;/a&gt;），我面临着：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在rxpy的asyncio库中实现我需要但没有的API | 在rxpy库中实现兼容asyncio的接口 =
&lt;ul&gt;
&lt;li&gt;了解Reactivex规范的实现方式 +&lt;/li&gt;
&lt;li&gt;精通asyncio +&lt;/li&gt;
&lt;li&gt;精通rxpy项目 =&lt;/li&gt;
&lt;li&gt;我还没这个本事，根据issues，贡献这个库的人都有在其他语言的rx库中贡献或工作过的经历。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不考虑第一方兼容，两者独立运行，通过threading库或multiprocessing库协调 =
&lt;ul&gt;
&lt;li&gt;首先得让它俩都正常跑起来（这很难） +&lt;/li&gt;
&lt;li&gt;精通这俩库中的一种 +&lt;/li&gt;
&lt;li&gt;实现一种数据传递方式，在两机制间传递信息（单用Queue只能通一边，怕是要上共享内存+锁那种，这两边至少把数据来回倒腾两次，没有上限）=&lt;/li&gt;
&lt;li&gt;俗话说的好，引入多线程就是引入至少一个bug，还自己实现多线程方面的内容，我不会，也不想引入，日后维护纯添麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;放弃rxpy（因为不能放弃nio），用asyncio重新写一遍关键代码（因为asyncio的特性，基本得全重写）。
&lt;ul&gt;
&lt;li&gt;如果推特没宣布关API，我打算用这种，但自己实现一种类似责任链机制也不简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;幸好，推特没有给我这个赎罪（？）的机会。这个错实实在在是我亲手埋下的，请大家务必记得做原型就贴便签。&lt;/p&gt;
&lt;h2 id=&#34;认清需求后再推翻重写一遍&#34;&gt;认清需求后再推翻重写一遍&lt;/h2&gt;
&lt;p&gt;我在五月二号，开始开发两个整月后，&lt;a href=&#34;https://github.com/boholder/puntgun/commit/ce1f395bd135d1484ba4332f6362fcac6dcd345c&#34;&gt;把项目推翻&lt;/a&gt;重新写了一遍，我认为这个决定做对了。&lt;/p&gt;
&lt;p&gt;大家可以翻一下各种著名项目的最开始的commit，大概都差不多：模块划分频繁更改、各种rename&amp;hellip;&amp;hellip;说明开发刚开始，没人知道自己想做什么。
软件开发学说里有系统边界这个概念，但我们的项目需求是内生的，没人告诉我们要写什么。
怎么办，总之先写着，直到真正确定下想做什么之前全都是原型，是自己（dev）为自己（customer）写的prototype，启发自己的需求。
等到你真正明白自己这个项目的系统边界了，再从头开始&lt;strong&gt;为这个目的而设计项目结构&lt;/strong&gt;，别不舍得。
这里我再掉一下书袋，还是《程序员修炼之道》第二版，有个什么“（汽车）不要开出前灯范围”的章节，讲的是相关方面（推荐读这本书，很棒）。&lt;/p&gt;
&lt;h2 id=&#34;列个计划表&#34;&gt;列个计划表&lt;/h2&gt;
&lt;p&gt;自己的项目啥都想要，正常。但是我推荐列一个计划表，比如用&lt;a href=&#34;https://github.com/boholder/puntgun/projects/1&#34;&gt;github的project&lt;/a&gt;。
自己的项目不会有排期，所以泳道图的堆栈式结构就足够了，用来给要做的事排优先级。
也可以加一个泳道存灵感，总之把长期开发中想到的东西都写在计划表里，给大脑工作区腾地方，也不怕遗忘。&lt;/p&gt;
&lt;p&gt;根据我的经验，选择困难时，无论是不知道选哪个实现方案还是买哪件商品，消去法（列条件限制）比较管用。
用语言描述你的目标，列出各个方案，重点放在“这个方案会让项目增加什么复杂性|硬性限制”上，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个方案能满足我哪些需要？&lt;/li&gt;
&lt;li&gt;这个方案我是要自己实现还是使用现成的库？
&lt;ul&gt;
&lt;li&gt;自己实现，可行性？（时间等成本上）值得吗？&lt;/li&gt;
&lt;li&gt;引入现成的库会对我的项目增加什么新约束？（切记上文的教训）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以先实现简单的，之后再做优化。简单的完成品比精致的半成品重要。
前提是它被封装地很好，不会对外部造成影响。
即使是自己在开发整个项目，封装依然可以帮忙节约大量的认知负担。
设计好外围的交互关系后，一次只专注于一个模块的内部设计。
拆分功能到足够小，小到能凭经验把它实现。&lt;/p&gt;
&lt;h2 id=&#34;注释和单元测试拯救记忆力&#34;&gt;注释和单元测试拯救记忆力&lt;/h2&gt;
&lt;p&gt;哈，这回可没人用覆盖率逼我写单测了，也没规定要求写那没人看的word接口文档。这回我的单测只能帮到一个同事——未来想重构的我。
我记性不好，很不好的那种不好，每天下班我要记一下自己在做什么，睡一觉如同内存掉电，没记录的话要坐工位上半小时才能想起来。
这项目，我就周末逮着点时间写写，要是不多写点单测和注释和TODO，怕是每周看到代码都像刚接手的项目，不可能持续小一年。
至少对我来说，单测和注释（和计划表）是维持这个项目的一大重要支撑。&lt;/p&gt;
&lt;h2 id=&#34;技术栈不熟可以抄&#34;&gt;技术栈不熟可以抄&lt;/h2&gt;
&lt;p&gt;隔语言如隔山，换门语言做开发并不仅需要学会语言本身，工程结构，编码规范，CI中要用到的检查工具，开发、测试所依赖的框架&amp;hellip;&amp;hellip;基本要全换。
自己一个个要素去搜，费时费力。有没有好办法？有，找一个已经成熟的和你的项目结构类似的项目，读+搜着学习它的工具配置和代码结构，抄到我们这边。
这个技巧我用过两次了，我的&lt;a href=&#34;https://github.com/boholder/naming&#34;&gt;naming&lt;/a&gt;小工具是Rust写的命令行工具，抄的我记得应该是&lt;a href=&#34;https://github.com/databricks/click&#34;&gt;click&lt;/a&gt;，
这次的puntgun是Python写的命令行工具，抄的&lt;a href=&#34;https://github.com/pdm-project/pdm&#34;&gt;PDM&lt;/a&gt;。
通过抄成熟项目，避免了自己闭门造车搞出一个不成熟的开发环境（未知技术栈对我们来说是unknown unknown嘛，不看到就不会知道还有这么方便的工具），抄着学不丢人，半吊子才丢人。&lt;/p&gt;
&lt;h2 id=&#34;后记之后干点啥&#34;&gt;后记：之后干点啥？&lt;/h2&gt;
&lt;p&gt;经验总结到此为止，希望我的经历能对你开发个人项目有所帮助。&lt;/p&gt;
&lt;p&gt;我买了块&lt;a href=&#34;https://www.raspberrypi.com/documentation/microcontrollers/raspberry-pi-pico.html&#34;&gt;树莓派pico-W&lt;/a&gt;，还买了块&lt;a href=&#34;https://www.waveshare.net/shop/Pico-LCD-1.3.htm&#34;&gt;小显示屏&lt;/a&gt;，
试试bare metal coding，大概会对各种计组知识有更深的理解吧，如果没放弃的话。&lt;/p&gt;
&lt;p&gt;最近推特中文圈有个高手云集的讨论&lt;a href=&#34;https://twitter.com/xuwenhao/status/1622108853944057858&#34;&gt;AI编程理论可行性和对行业冲击的串&lt;/a&gt;，
我相信其中的观点比如“当AI创造的成本压得比维护现有代码低，维护就不复存在了”（就像家电维修成本高不如换新的），
然后我们短暂而自豪的coding culture大部分都是为了“更好地维护”这一目的设计的，
我对失去信仰的恐惧大概比对失去工作的恐惧还要更甚。
我想了两个转行方向，做profiling和做渗透测试，但经过咨询推友发现这两个方向都不能在“成熟AI编程”前提下站稳不受冲击。
大概唯一的慰藉就是看看现在的AI给出的错误百出的编程答案，心想这碗饭还能多吃几年。&lt;/p&gt;
&lt;p&gt;整理心态积极拥抱变化吧，这也是我们这行的信条之一，与君共勉。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>用Maven reactor命令行选项节约build时间</title>
                <link>https://boholder.github.io/blogs/maven-build-advance/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/maven-build-advance/</guid>
                <pubDate>Sat, 11 Feb 2023 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;微服务开发下的build困扰&#34;&gt;微服务开发下的build困扰&lt;/h2&gt;
&lt;p&gt;前提：Java开发，Maven做依赖管理，JetBrains IntelliJ IDEA做IDE&lt;/p&gt;
&lt;p&gt;在Java微服务开发下，项目开发结构(repo)可能有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有模块(maven module)，包括服务（Spring Application）和自己开发的依赖模块，都塞在一个项目里。
&lt;ul&gt;
&lt;li&gt;方便管理各模块间的关系，方便写代码&lt;/li&gt;
&lt;li&gt;git log 很乱很多，但也方便集中检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务和自己开发的依赖模块独立在不同项目里
&lt;ul&gt;
&lt;li&gt;不方便管理模块关系&lt;/li&gt;
&lt;li&gt;git log 少又清晰，只有该组件相关的提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（以我的工作经历来看，两种结构怎么选好像和开发组的人员结构有关：如果负责不同服务的小组紧密围绕在开发组长周围，选集中式的面儿大；如果小组间相互不太紧密，比如这个项目是不同部门联合开发之类，选分散式的面儿大。）&lt;/p&gt;
&lt;p&gt;现在假设：&lt;code&gt;服务A -依赖-&amp;gt; 依赖B&lt;/code&gt;。现在我想改依赖B的代码，启动服务A检查修改效果。（假如B不方便写单测，比如写了个自定义某框架相关的配置类，只能启动看看效果）正确的操作步骤为&lt;strong&gt;先build B，再debug run A&lt;/strong&gt;，虽然JetBrains会监控服务A的代码变化并在run时rebuild A，但它不会（至少默认不会）监控A依赖的B的变化。这个算常识，对吧，但人总有大意的时候，我已经不止一次忘记先build B，然后debug A时B的行为就死活不变，直到花很长时间想起来这个原因。&lt;/p&gt;
&lt;p&gt;怎样实现启动A时让B自动build，或者简单点，让B的artifact能反映最新的代码修改？&lt;/p&gt;
&lt;p&gt;对分散式结构，我至今没什么好招，都跨文件目录了，感觉只有用外部工具才能实现，至今没找到此类工具或Maven plugin/ IDEA plugin。如果下个我参与的项目是分散式，我打算自己写一个工具。还好现在我所在的组采用集中式结构。&lt;/p&gt;
&lt;p&gt;首先想到的是Maven的&lt;a href=&#34;https://maven.apache.org/guides/mini/guide-multiple-modules.html&#34;&gt;reactor&lt;/a&gt;内部机制，如果在顶级（maven root）项目上build，reactor就能根据拓扑排序依次build所有模块。现在出现了另一个问题：浪费时间在build不需要的模块上。比如我组的项目里有个胖服务，整个build它和它的依赖链要十几分钟，这样会让开发体验变得不流畅（此处插一个程序员笑话&lt;a href=&#34;https://xkcd.com/303/&#34;&gt;xkcd - Compiling&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;Maven提供了一些&lt;a href=&#34;https://maven.apache.org/guides/mini/guide-multiple-modules.html#command-line-options&#34;&gt;命令行选项&lt;/a&gt;实现这种需求。我没能找到一个讲得非常明白的博客，所以自己写一篇。注意这里只挑一般会用到的选项写，全部选项请看链接（没写的都是几乎不会用的选项），或者直接&lt;code&gt;mvn --help&lt;/code&gt;参数比网站上的还全。&lt;/p&gt;
&lt;h2 id=&#34;maven-reactor-cmd-options&#34;&gt;Maven reactor cmd options&lt;/h2&gt;
&lt;p&gt;这里有一个&lt;a href=&#34;https://github.com/boholder/sample-multiple-module-proj&#34;&gt;示例项目&lt;/a&gt;，它的依赖结构和reactor给出的root build顺序是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;dep-util
 |
dep-service  dep-util2
 |      \      /
app-1     app-2
   
[INFO] Archetype - sample-multiple-module-proj                            [pom]
[INFO] dep-util                                                           [jar]
[INFO] dep-service                                                        [jar]
[INFO] app-1                                                              [jar]
[INFO] dep-util2                                                          [jar]
[INFO] app-2                                                              [jar]
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;projects&#34;&gt;projects&lt;/h3&gt;
&lt;p&gt;简写&lt;code&gt;-pl&lt;/code&gt;，特别指定一个模块的子集去build，不build其他的。
如：&lt;code&gt;mvn --projects &amp;quot;dep-util, dep-util2&amp;quot; clean install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;[INFO] dep-util ........................................... SUCCESS [  0.995 s]
[INFO] dep-util2 .......................................... SUCCESS [  0.084 s]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个选项比较万能，不会沿依赖链传递build，指定什么build什么。
比如我改了&lt;code&gt;dep-util2&lt;/code&gt;，但没改接口，选这个命令是最适合的。回到开头的问题，如果我频繁改模块B，B直接被服务A依赖，那每次运行只需手动build模块B，再跑Run/Debug自动build服务A。&lt;/p&gt;
&lt;p&gt;我在SOF上&lt;a href=&#34;https://stackoverflow.com/a/49979240/11397457&#34;&gt;找到&lt;/a&gt;了一个自动化程度高一些的命令，根据git修改记录自动取需要build的模块名：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;mvn install -pl $(git status &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep -E &lt;span class=&#34;s2&#34;&gt;&amp;#34;modified:|deleted:|added:&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; awk &amp;#39;{print $2}&amp;#39; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; cut -f1 -d&lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;resume-from&#34;&gt;resume-from&lt;/h3&gt;
&lt;p&gt;简写&lt;code&gt;-rf&lt;/code&gt;（一阵恶寒），这个选项本意是指定一个build fail的callback，“如果主build命令失败，从root build顺序的中间指定模块开始重新尝试build”。
但是它可以单独用，效果是直接从中间开始build。单独用到的机会很少，因为从指定的中间到底部可能包含我们不想build的模块。
比如我们改了&lt;code&gt;dep-util&lt;/code&gt;和&lt;code&gt;app-1&lt;/code&gt;，&lt;code&gt;mvn --resume-from dep-util clean install&lt;/code&gt;，等于从顶build到尾，把&lt;code&gt;dep-util2&lt;/code&gt;和&lt;code&gt;app-2&lt;/code&gt;也build了。&lt;/p&gt;
&lt;h3 id=&#34;also-make&#34;&gt;also-make&lt;/h3&gt;
&lt;p&gt;简写&lt;code&gt;-am&lt;/code&gt;，这个选项用于想同时build依赖和服务，意为“也build主命令目标的依赖”，目标选服务，会向下递归传递。比如：改了&lt;code&gt;dep-util&lt;/code&gt;和&lt;code&gt;app-1&lt;/code&gt;，
&lt;code&gt;mvn --projects app-1 --also-make clean install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;[INFO] dep-util ........................................... SUCCESS [  0.824 s]
[INFO] dep-service ........................................ SUCCESS [  0.106 s]
[INFO] app-1 .............................................. SUCCESS [  0.109 s]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;also-make-dependents&#34;&gt;also-make-dependents&lt;/h3&gt;
&lt;p&gt;简写&lt;code&gt;-amd&lt;/code&gt;，这个是&lt;code&gt;--also-make&lt;/code&gt;的相反选项，“也build使用主命令目标的模块”，目标选依赖，会向上传递。
如：&lt;code&gt;mvn --projects dep-util --also-make-dependents clean install&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;[INFO] dep-util ........................................... SUCCESS [  1.010 s]
[INFO] dep-service ........................................ SUCCESS [  0.105 s]
[INFO] app-1 .............................................. SUCCESS [  0.109 s]
[INFO] app-2 .............................................. SUCCESS [  0.097 s]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用在接下来要在本地环境同时开多个依赖该模块的服务做测试的情况（微服务一个请求串多个服务常有的事）。&lt;/p&gt;
&lt;h2 id=&#34;理解maven的artifact控制逻辑&#34;&gt;理解Maven的artifact控制逻辑&lt;/h2&gt;
&lt;p&gt;理解Maven的控制逻辑，能让你更清楚的知道什么时候该build什么模块。总结下来就一点：&lt;strong&gt;改了哪个build哪个，其他不用动，从底向上build&lt;/strong&gt;。但是如果你pull了代码，想跑一整个服务，不知道什么模块被同事改了，那就只能图省事用上面的&lt;code&gt;--also-make&lt;/code&gt;build服务主模块，以更新整个依赖链了。&lt;/p&gt;
&lt;p&gt;（我的实践是每参加一个Java项目组，为其项目分配一个独立的Maven配置和仓库目录，防止依赖混淆。其实对Maven这种通过版本管理依赖的工具+Java语言的目标文件（库分发文件）即jar包中的字节码不会被轻松修改，所有项目用一个库也是可行的。你看Python、JS的工具，大部分不允许同一依赖的多个版本共存在一个环境中。）&lt;/p&gt;
&lt;p&gt;看这个SOF上的提问：&lt;a href=&#34;https://stackoverflow.com/questions/40979487/target-folder-vs-local-repository&#34;&gt;target folder vs local repository&lt;/a&gt; 我们得知：跑&lt;code&gt;mvn install&lt;/code&gt;时，Maven会生成模块的artifact（jar包）放进本地仓库。使用的&lt;a href=&#34;https://stackoverflow.com/questions/54616030/difference-between-jar-fat-jar-executable-jar&#34;&gt;打包方式&lt;/a&gt;不同，服务“依赖”模块artifact的时机也不同，有的是打包有的是运行时，但都是从本地仓库取的artifact。总之我们通过更新模块的artifact，把模块的修改“带进了服务里”。&lt;/p&gt;
&lt;h2 id=&#34;常见错误操作&#34;&gt;常见错误操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们有时会用鼠标在IDEA的Maven插件的界面中（在界面右侧边栏里），运行Maven命令弹窗-&amp;gt;输入栏右边点击选择目标模块，这个操作不等于加&lt;code&gt;--projects&lt;/code&gt;选项，即比如&lt;code&gt;mvn --also-make clean install&lt;/code&gt;+&lt;code&gt;选中app-1&lt;/code&gt;是无效的，只build &lt;code&gt;app-1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDEA有一个&lt;a href=&#34;https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#delegate_to_maven&#34;&gt;Delegate build and run actions to Maven&lt;/a&gt;设置，勾选后效果大概是Run/Debug时跑&lt;code&gt;--also-make&lt;/code&gt;，即build整个依赖链。因为我们&lt;strong&gt;并不是每次都要build整个依赖链&lt;/strong&gt;，这选项还是不打开比较好，浪费的时间更多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时我们改了两个模块，先build上层的模块，会报“找不到（下层模块的）符号”，但是我们在编辑器里能看到代码没报红色错误。这就是因为我们忘了先build下层模块，而不该判断为IDEA的索引缓存又坏了，进而花大量时间重新缓存索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/java/">java</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>我对人情的理解</title>
                <link>https://boholder.github.io/blogs/favor/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/favor/</guid>
                <pubDate>Sat, 10 Dec 2022 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;希望读者从文中获益&#34;&gt;希望读者从文中获益&lt;/h2&gt;
&lt;p&gt;前几天一技术群在讨论话题“是否要接受父母决定的道路（就业）”，我把该话题理解为“是否该接受父母的人情”（实际上该话题可分解为“是否接受并顺从父母的决定”+“是否使用父母的人情/是否对父母欠下人情债”），叭叭叭一顿说，激起不少反对声音。我试着解释，但没能解释清楚，留下一地鸡毛就逃走了。我们搞开发的喜欢以文档为共识和契约，于是我打算用这篇文章讲清楚我个人对于人情及相关概念的理解。&lt;/p&gt;
&lt;p&gt;写本文的目的不是为了面子之类的虚的，无意冒犯任何人，我就觉得（内省：这可能是我的误解）好像很多人因为生活背景等原因过度厌恶人情，导致白白错过了一些微小的幸福，我觉得可惜（内省：同理心泛滥，这算优越感的隐晦体现吗）。&lt;strong&gt;我希望这篇文章能为理解人情提供另一个角度&lt;/strong&gt;，把模糊的人情分解，把理应被道德谴责的黑色和有益的白色分开（当然中间有分不开的灰色部分），分享一下我从社交与互惠中得到的收获。文章结构松散，想到什么写什么，跳着看感兴趣的即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我在玩火，试图讨论主观概念。&lt;strong&gt;这个话题受主观影响，没有正确答案&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;我害怕这篇文章激起争论或关注，我是极度厌恶“热度”的人。希望最后我不会主动把这篇文章删掉。&lt;/li&gt;
&lt;li&gt;我对进一步讨论没太大兴趣。如果您对我的理解持不赞同意见，我建议咱们求同存异，聊点编程、ACG之类的（有人能指点一下我在Python中遇到的&lt;a href=&#34;https://github.com/boholder/puntgun/issues/17&#34;&gt;reactivex与asyncio结合使用的疑惑&lt;/a&gt;吗？DS2的预告片谁看懂了？）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;人情的正当性并非所有人情交换都违反规则&#34;&gt;人情的正当性：并非所有人情交换都违反规则&lt;/h2&gt;
&lt;p&gt;严格意义上讲，只要不涉及对公共规则的违反，没产生&lt;a href=&#34;https://en.wikipedia.org/wiki/Externality&#34;&gt;外部性效应&lt;/a&gt;，是纯粹的互助，就没有不公平一说。我“从白到黑”举三个例子，都是真事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;白的例子：有一天突然下了大雨，下班高峰期打车也排队，我决定撑伞走路回家，麻烦的是那天正好要带些东西回家，边打伞边提东西挺狼狈。刚走出公司，路旁缓缓停下一辆车，车窗摇下，是一位和我关系不错的同事，他招呼我上车送我回家，我接受了，我俩在车上聊地挺开心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;群友举了个绝妙的灰色例子：外国小镇中，开车的小违章被警察看到，警察能否高抬贵手免开一百刀的罚单，取决于开车者和警察的个人交情（小镇都是熟面孔）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;黑的例子就很多了，就是常规意义上的我们所认知的有腐臭味的那种，走后门，找关系，勾结，拉帮结派……&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我想我们能达成一致：白例子令人感到温馨，黑例子应被人不齿。我们在开罚单这个例子上也许有分歧，它轻微违反了公共规则。就交通罚款的设立目的来说，是为了给违规行为增加负反馈，警察因人情免除罚款，可能使开车者未来继续违规，这对他人不公平。但谁又能知道是否良心谴责和对警察的人情债可替代现金罚款，约束开车者呢。&lt;/p&gt;
&lt;p&gt;至此我可以进一步澄清部分主旨：&lt;strong&gt;我希望大家不要因人情中黑的部分而厌恶所有互助行为&lt;/strong&gt;（我想也不会有人这么做）。也许这时你发现我把“好的互助”也放在了人情中（虽然我认为人情不代指行动而代指行动的产物），和你理解的“人情是坏的、有利益勾结的”不一样。因为这些“好的互助”也符合我的人情体系，你帮我，我帮你，天经地义，这是抽象的，没有好坏。&lt;/p&gt;
&lt;h2 id=&#34;建模人情&#34;&gt;建模人情&lt;/h2&gt;
&lt;p&gt;我对“人情”的理解（定义）是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一种可积累、使用的资源，难以量化，但可以&lt;a href=&#34;https://en.wikipedia.org/wiki/Qualitative&#34;&gt;质化&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;类似货币，是“价值等价物”，可借用金融概念解释。A帮了B，A在B心里积累了人情，B对A负人情债。&lt;/li&gt;
&lt;li&gt;因为是资源，所以可以作为衡量行动成本收益天平的砝码。&lt;/li&gt;
&lt;li&gt;将社会关系抽象为有向图，人是节点，人情是边的权值。因为是有向图，所以A和B可互相独立地积累人情。&lt;/li&gt;
&lt;li&gt;没有中央记账。假设每个人对数值的衡量相同（A与B对于同样的人情点数所认为的重要性相同），每个人的人情账本上对同一边的权值大小（或同一件事所价值的人情量）理解可不同。（A觉得随手帮B无所谓，B觉得A是大恩人）&lt;/li&gt;
&lt;li&gt;人情通过互惠reciprocity行动相互积累，单次施惠时，一方选择提出给予，一方选择同意接受与否，口语称“帮忙”。&lt;/li&gt;
&lt;li&gt;因为不像金融体系中有法律和契约保证，人情的“返还”概率（或倍率）可用接受者社会信用来评价。自己对自己的信用评价和他人对自己的信用评价不同。&lt;/li&gt;
&lt;li&gt;人情系统可超越个人，在组织乃至国家层面成立（一定有个我不知道的社会学名词讲这个概念）。&lt;/li&gt;
&lt;li&gt;人情资源也可在关系亲密者间转移或分摊，或者说代理使用？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后建模的计算公式：
&lt;strong&gt;A在B处积累的人情 =&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;A账: A认为B的信用 * A认为“A帮过B的忙的总价值”&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;B账: B的实际信用 * B认为“A帮过B的忙的总价值”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于A、B两人，有两个方向*两个账本（信用评价，帮忙价值）=四个值（打星为主观判断）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;记账主体&lt;/th&gt;
&lt;th&gt;给予者&lt;/th&gt;
&lt;th&gt;接受者&lt;/th&gt;
&lt;th&gt;帮忙价值*&lt;/th&gt;
&lt;th&gt;接受者信用*&lt;/th&gt;
&lt;th&gt;最终人情值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Ab价&lt;/td&gt;
&lt;td&gt;Ab信&lt;/td&gt;
&lt;td&gt;Ab价*Ab信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;A欠B&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Aa价&lt;/td&gt;
&lt;td&gt;Aa信&lt;/td&gt;
&lt;td&gt;Aa价*Aa信&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;记账主体&lt;/th&gt;
&lt;th&gt;给予者&lt;/th&gt;
&lt;th&gt;接受者&lt;/th&gt;
&lt;th&gt;帮忙价值*&lt;/th&gt;
&lt;th&gt;接受者信用*&lt;/th&gt;
&lt;th&gt;最终人情值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Bb价&lt;/td&gt;
&lt;td&gt;Ba信&lt;/td&gt;
&lt;td&gt;Bb价*Ba信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;B欠A&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Ba价&lt;/td&gt;
&lt;td&gt;Bb信&lt;/td&gt;
&lt;td&gt;Ba价*Bb信&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;分析给予和接受的决策&#34;&gt;分析给予和接受的决策&lt;/h3&gt;
&lt;p&gt;人情的积累是个相互给予的过程，每次给予成立，是双向正反馈，路越走越宽，两人间关系纽带越来越紧密。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给予有正向动机：利他主义altruism（无私） + 利己主义egoism （期待回报）+ 回报感激（Ta帮过我）&lt;/li&gt;
&lt;li&gt;同意接受有好处：实际的好处 + 感激之情（心里暖暖的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为没有中央记账，双方在对方处积攒的人情（编号2，编号4）不能达成相互抵消的共识，仅能在自己的小账本里打算盘（1抵2，3抵4）。&lt;/p&gt;
&lt;p&gt;抛开社会关系造成的压力（真能抛开？），给予方A对一次给予决策有完全的主动性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若给予完全由利己主义驱动，A在帮助B时不能得知该行动真正的价值（编号4，两个因素都由B决定），只能参照判断。&lt;strong&gt;这种“不清不楚”的特征让很多人皱眉远离，但这只是利己动机的部分，给予者可以让利他主义占动机上风，享受“做好事真开心”的感觉。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;感谢利他主义的存在，“无偿（不期待回报）帮助陌生人”这一美好的事得以发生。&lt;/li&gt;
&lt;li&gt;根据我的生活经验，实际情况下给予的动机一般为利他与利己混合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抛开社会关系造成的压力，接受方B也有完全的主动性选择是否接受。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受的正向动机 = 实际的好处 + 感激之情 - 增加的人情债&lt;/li&gt;
&lt;li&gt;B对A增加的人情债（编号1）也是不清不楚的参照判断，&lt;strong&gt;我猜厌恶人情的人大多是在决策是否接受时激发了&lt;a href=&#34;https://en.wikipedia.org/wiki/Loss_aversion&#34;&gt;损失厌恶&lt;/a&gt;，这很合理&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我认为坏东西大多是利用社会关系的杠杆从人情中单方面牟利的，比如双方有不平等关系，优势方总可以利用压力强迫弱势方服从，优势方在给予（PUA-强迫给予信息）和接受（抢夺）都强势。&lt;/p&gt;
&lt;h3 id=&#34;现实中的人情点数交换机制&#34;&gt;现实中的人情点数交换机制&lt;/h3&gt;
&lt;p&gt;我觉得这段用游戏做比喻最合适。现代大型游戏，比如MMORPG或单机游戏，一般不仅仅只有交易系统一个&lt;strong&gt;物品交换机制&lt;/strong&gt;。比如MMORPG里有公会、势力组织，遵照“贡献度”机制，你可以通过帮助组织赚取贡献度，再&lt;strong&gt;消耗&lt;/strong&gt;贡献度交换特殊物品。单机里我能想到两种：1. RimWorld有&lt;a href=&#34;https://rimworldwiki.com/wiki/Factions#Faction_Relationships&#34;&gt;阵营关系&lt;/a&gt;机制，当你受到袭击时，可&lt;strong&gt;消耗&lt;/strong&gt;关系呼叫友方阵营支援。2. 很多养成游戏里和NPC的好感度&lt;strong&gt;只升不降&lt;/strong&gt;
，达到一定程度后解锁新功能（如女神异闻录5里&lt;a href=&#34;https://zh.moegirl.org.cn/zh-hant/%E5%B7%9D%E4%B8%8A%E8%B4%9E%E4%BB%A3&#34;&gt;让老师帮忙洗衣服&lt;/a&gt;&amp;hellip;&amp;hellip;）。我认为现实中的人情交换机制是只升不降好感度系统和动态贡献度系统的混合。&lt;/p&gt;
&lt;p&gt;为什么玩家愿意使用这些机制？因为有&lt;strong&gt;金钱换不来的特殊物品&lt;/strong&gt;做奖励。现实里金钱买不到的特殊资源比游戏只多不少，这些资源有各种各样的原因无法市场化。资源并不一定是实物，倒不如说我更喜欢信息，因为交换代价很小但可能价值比较大。没有这些花哨东西，游戏照样能通关；现实只是用交易系统，仍然能正常生活。这机制它就在那，使用的决定权在你。我是本着不用白不用的态度去用的，而且和背景差异大的人接触能学到很多可能一辈子都不会了解的信息。&lt;/p&gt;
&lt;h2 id=&#34;社交好处多&#34;&gt;社交好处多&lt;/h2&gt;
&lt;p&gt;刚开始写大纲时，我把人情和社交混为一谈，现在我认为积累人情的互惠只是各类社交行动中的一种，是集合包含关系。如果把人情和社交混起来，则“鼓励积累人情”变成了“鼓励不要自我封闭，去社交”，我也被误导着收集了一些资料。这些资料质量还挺高，我要把它们贴在这里，也不枉收集了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;弱链接weak ties&lt;a href=&#34;https://scholar.google.com/scholar?q=+weak+ties+benefit&#34;&gt;好处多多&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统计表明大部分求职者的工作由“非亲密关系”，即弱链接推荐提供。&lt;/li&gt;
&lt;li&gt;将社会关系绘制为无向图，关系紧密的群体间的关系多由群体中个人的弱链接提供。而这些人因占据两群体间的“关口”位置，（在模拟资源分配中）比其他节点有优势。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;人情交换机制可作为交易机制的保险。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当交易机制意外失效时（如区域封锁导致物资供给不足）&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;li&gt;结婚的社会意义就是两个家庭|家族的“相互保”。———— &lt;a href=&#34;https://book.douban.com/subject/35837685/&#34;&gt;《文明的逻辑》 陈志武&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;社交纽带使得脆弱的个体组成团队，更好地抵御风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们的身体将社交视为必需品而非嗜好品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;著名的科普视频系列Kurzgesagt中有两集谈到相关内容：&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=n3Xv_g3g-mA&amp;amp;t=85s&#34;&gt;Loneliness&lt;/a&gt;：孤独如同饥饿，是自然生理需求，驱使我们为了社交而行动，这个演化可能是由远古时期“不合作就会死”的恶劣环境选择出来的。比较要命的是，研究表明社交不足会让大脑产生压力，而压力会损害健康。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=WPPPFqsECz0&amp;amp;t=120s&#34;&gt;An Antidote to Dissatisfaction&lt;/a&gt;：感激是治愈不满的良药，而感激或许源于社交行为中的互惠。&lt;/li&gt;
&lt;li&gt;不过我发现，每个人的社交需求槽长度是不一样的，想办法满足自己的槽就行了。现在我们利用网络可以轻松找到符合自己兴趣的话题并参与进去，现实里不见人也可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说到&lt;strong&gt;连结&lt;/strong&gt;，我一定要提一下&lt;del&gt;公主连结&lt;/del&gt;&lt;a href=&#34;https://www.gcores.com/collections/75&#34;&gt;死亡搁浅&lt;/a&gt;这个游戏，&lt;del&gt;游戏制作人&lt;/del&gt;监督&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%B0%8F%E5%B2%9B%E7%A7%80%E5%A4%AB&#34;&gt;小岛秀夫&lt;/a&gt;用他天才般的大脑构想了一个濒临崩溃的世界，让玩家随着操作的角色一起&lt;strong&gt;重新连接&lt;/strong&gt;各个分散的人类据点，并从中体会&lt;strong&gt;纽带&lt;/strong&gt;的重要性。它明明是个单人游玩的单机游戏，却能让玩家体会到与NPC乃至其他玩家之间的&lt;strong&gt;连结&lt;/strong&gt;，从而不会感到孤独。感兴趣请务必玩一下。&lt;/p&gt;
&lt;h2 id=&#34;应用题&#34;&gt;应用题&lt;/h2&gt;
&lt;h3 id=&#34;正常社交就能积累人情无需应酬&#34;&gt;正常社交就能积累人情，无需应酬&lt;/h3&gt;
&lt;p&gt;聊天时一位群友对我的反驳是“我不想应酬”，我先搜了“应酬”的字典义：1.交际来往2.以礼待人3.私人开的宴会。啊呀，如果他指的是含义一即社交的话，我只好用“社交是必需品”来劝说他了。但是若按现代人思维理解，加上我对他工作地点的了解，大概是工作相关的酒场应酬吧，不是好事啊，确实不该去。&lt;/p&gt;
&lt;p&gt;互惠并不需要强迫自己，甚至会乐意这样做，因为是互惠，有来有回。我倾向于通过聊天来交换信息，和谁都能聊两句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我成了面馆里的熟客，与老板聊天得知老板愿意为熟客按兰州拉面的宽度特别准备面条，并爱上了二粗宽度的牛肉面。&lt;/li&gt;
&lt;li&gt;和公司、小区物业的保洁保安聊家常，混个脸熟，物业有什么打算，打听一下就提前知道了。&lt;/li&gt;
&lt;li&gt;只要有机会，我会在打车时和司机聊天，问问滴滴又搞了什么我看不懂的操作，师傅您怎么看。😂&lt;/li&gt;
&lt;li&gt;取快递人不多时我会报快递号取件而不是在手机里操作，顺便聊两句。&lt;/li&gt;
&lt;li&gt;在电梯里和邻居独处，聊两句，夸夸孩子夸夸狗，都没有夸夸衣服发型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这算外向吗？我觉得还行吧，开口说话成本很低，但聊天的潜在收益可能很高，我是务实又好奇的人。我知道一位比我更善于和陌生人交谈的人——&lt;a href=&#34;https://twitter.com/freiheityu&#34;&gt;余晟老师&lt;/a&gt;
，他时不时在推特上分享自己和不同国家的陌生人交流的事。嗯&amp;hellip;&amp;hellip;不想聊天？也行，怀着一颗善良的心，他人有困难能帮就帮，行动比耍嘴皮子更能让人印象深刻，你默默做过的好事，和你一样的好人都会默默记在心里。对了，Kurzgesagt有期视频专门讲怎么交朋友，有需就看看：&lt;a href=&#34;https://www.youtube.com/watch?v=I9hJ_Rux9y0&#34;&gt;Why You Are Lonely and How to Make Friends&lt;/a&gt;。如果你真的想积累黑色的人情和关系，我觉得我不够格教（笑），去书店里看看那本《厚黑学》下架了吗？&lt;/p&gt;
&lt;h3 id=&#34;如何谨慎地欠人情债&#34;&gt;如何谨慎地欠人情债&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A在B处积累的人情 =&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;A账: A认为B的信用 * A认为“A帮过B的忙的总价值”&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;B账: B的实际信用 * B认为“A帮过B的忙的总价值”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聊天时，群友指出我只说了欠人情债的好处，丝毫不说还人情债时的坏处，我坏。我补充一下，首先我认为人情并没有&lt;strong&gt;还&lt;/strong&gt;债这一概念，人情系统是通过相互给予实现的，往好处想，在没有套路的童话世界里，给予的行为是由利他主义和感激之情驱动的。&lt;/p&gt;
&lt;p&gt;但我们也提到了给予的利己主义动机，社会关系的压力，损失厌恶等成本衡量概念，不能当作没说过。好吧，既然我们已经使用了债务概念，且让我继续用它打比喻，装作一个精明的人，考虑成本收益平衡。&lt;/p&gt;
&lt;p&gt;首先列一下信用贷款的大致公式（A借款给B，期望从B上收益），以A对B信用评价为核心，A会从风险和收益两方面考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A对B的信用评价 正比于 A对B贷款授信额度 （防止B还不了款的风险控制）&lt;/li&gt;
&lt;li&gt;A对B的信用评价 反比于 A与B签署的贷款协议的利率 （从B上的预期收益更大，才能平衡风险）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有网络借贷平台，日利率滚起来都比正常银行的信用卡月利率高。网络借贷平台对贷款客户的信用评价低，走的是高风险高收益模型。银行对信用卡客户信用评价高，不担心风险，用低利率鼓励客户使用信用卡。&lt;/p&gt;
&lt;p&gt;那么我们作为办理信用贷款的B：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们会首选大型商业银行作为贷款方（前提是我们的信用尚可），因为我们不希望我们欠的债务（A帮过B的忙的总价值）（A的预期收益）在A看来比我们认为的多（还款利率设定的高）。类比到人情，我们&lt;a href=&#34;https://www.youtube.com/watch?v=LHfF7slQhh4&#34;&gt;不会选择接受&lt;/a&gt;看低我们、想从我们身上获取更多的人的给予。&lt;/li&gt;
&lt;li&gt;为了顺利还款，维持信用评级，我们不会借超过还款能力的金额。银行追求低风险，我们想贷也不会贷给我们。但是有坏借贷平台，愿意给我们贷明显离谱的金额，代价是超高利率，如果还不上的话&amp;hellip;&amp;hellip;请脑补各种催债情景。类比到人情，我们不会选择接受提供给我们的明显无法偿还的给予。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接受的主动权在我们这，即使A再怎么希望把我们变成摇钱树，我们不咬钩就行。例外是引入社会关系压力后的场景，A强迫我们接受，这怎么办，不好说，我建议远离A，到A观测不到或触及不到的地方。&lt;/p&gt;
&lt;h3 id=&#34;是否应使用父母的人情&#34;&gt;是否应使用父母的人情&lt;/h3&gt;
&lt;p&gt;现在回答开头提到的问题，这是个主观题，没有正确答案，我试着用我的模型里回答。这时我发现公式应该再加一个动机变量“期望回报系数|认为被期望回报系数”，但我懒了不想改上面的文字了。父母是给予方，我们是接受方，为了突出主要矛盾，假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“帮忙价值”极高，孩子无法偿还。&lt;/li&gt;
&lt;li&gt;父母对孩子和孩子对自身的“信用评价”都高。&lt;/li&gt;
&lt;li&gt;父母被拒绝或期望落空都会失望。&lt;/li&gt;
&lt;li&gt;孩子在判断动机失败时，会做出实际与自身利益相悖的决策，会失望。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即人情债数值极高，关键在“期望回报系数”。对父母和孩子两个动机变量的取值分别假设，排列组合共四种场景，由孩子决策是否选择接受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父母的真正动机：1.利他（你是我们孩子，我们无偿给你资源） 2.利己（我们期望从你身上获得投资回报）&lt;/li&gt;
&lt;li&gt;孩子对父母的动机判断（人情债计算）：1.父母不求回报 2.父母期望回报&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实孩子用来决策的信息只有自己的判断，加上父母真正动机，只有“父母和孩子都认为不期望回报”这一种情况下孩子会接受，且未来不会让父母失望。其他三种情况要么父母立刻失望，要么未来失望。孩子失望和不失望二比二对半开，还行。当然父母和孩子还可以通过谈心来统一判断。&lt;/p&gt;
&lt;p&gt;之前群聊时还引入了“孩子有无能力拒绝父母并自立”，“是否喜爱父母”，“父母是否有控制欲”之类的变量。抛开模型的话，如果我是孩子，场景是就业，我更倾向于不让父母伤心，接受并且把父母提供的选择作为保底，自己尝试符合自己兴趣的风险更大收益更高的机会。&lt;/p&gt;
&lt;p&gt;我想大部分父母对孩子的爱还是无偿的吧。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/thought/">thought</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>信息在网上随风飘飞</title>
                <link>https://boholder.github.io/blogs/information-flies-in-the-wind-on-the-internet/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/information-flies-in-the-wind-on-the-internet/</guid>
                <pubDate>Sat, 15 Oct 2022 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;这篇文章阐述我的一个想法：发布到互联网上的信息，一旦发布就很难全网抹除，发布时间越长越难抹除。这是因为信息特殊的性质——可读=可复制副本=拥有。&lt;/p&gt;
&lt;h2 id=&#34;预言故事诽谤如随风飘飞的鸡毛&#34;&gt;预言故事：诽谤如随风飘飞的鸡毛&lt;/h2&gt;
&lt;p&gt;有这样一篇预言故事&lt;a href=&#34;https://philipchircop.wordpress.com/2014/05/28/picking-up-feathers/&#34;&gt;《捡起鸡毛》&lt;/a&gt;，很短，我翻译一下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一位妇女忏悔自己诽谤他人。告解神父，一位睿智的老者，他慈爱地听着，赦免了她的罪，并指定给了她一项奇怪的悔罪行为——他让她回家找一只母鸡然后回来，当她沿街走时要拔掉母鸡的羽毛。当她回来时，神父说:
“现在请回家去，边走边捡起你在路上拔下的每一根羽毛。”妇女告诉他这是不可能的，因为几乎可以肯定的是，风已经把它们吹走了。神父告诉她：&amp;quot;
你看，就像风吹散了羽毛就不可能再捡起来一样，流言蜚语和诽谤一旦从我们嘴里说出来，就不可能再收集起来。&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;公开发布的信息一如风中鸡毛&#34;&gt;公开发布的信息一如风中鸡毛&lt;/h2&gt;
&lt;p&gt;公开发布的信息就像在风中撒手的鸡毛，不管自愿与否都实际放弃了控制权。就像公共场合说出的话，不知道谁会听到，不知道听到的人中有多少人会记住，也不知道记住的人中多少人会把这个话传给其他不在场的人。信息的传递方式在现实和网络上分毫不差。&lt;/p&gt;
&lt;p&gt;有人会感叹互联网信息的可用性差，比如老平台被公司关闭、域名到期或服务器下线导致的网站下线、磁力链接失效&amp;hellip;&amp;hellip;或许信息还躺在世界上某个硬盘中，甚至在私有域中，只是不可公开读取。如果时光能倒流，回到还能读取信息的时候，任何人都可以将其备份并永久保存到本地。不知浏览器何时拥有的“脱机可用”这功能，大概很久前就有。即使没保存，这不是还有回忆吗，也是信息特性的证明，没人能抹除你的记忆。&lt;/p&gt;
&lt;p&gt;如果你当时忘了备份，可能有其他网民或系统帮你备了份。比起讨厌更应该感谢保存互联网信息的系统，不管是用自动爬虫的搜索引擎还是接受快照请求的存档网站，毕竟它们将保存的信息公开给了所有人，分享和开放是好事。另外我们永远不可能知道某个已经不可访问的信息在全球有多少个离线备份。&lt;/p&gt;
&lt;h2 id=&#34;非公开上传的信息也难逃一劫&#34;&gt;非公开上传的信息也难逃一劫&lt;/h2&gt;
&lt;p&gt;并非信息设置为非公开就万事大吉。信息被联网上传到另一个地方，都或多或少暴露在风险下。&lt;/p&gt;
&lt;h3 id=&#34;信息被主动出卖&#34;&gt;信息被主动出卖&lt;/h3&gt;
&lt;p&gt;公司利用用户协议，用你产生的信息赚钱（&lt;a href=&#34;https://www.reddit.com/r/explainlikeimfive/comments/2m3f05/eli5_if_something_is_free_you_are_the_product/&#34;&gt;“如果你免费使用某个公司提供的服务，那么你输入上传的一切都&lt;em&gt;可以&lt;/em&gt;是公司的商品”&lt;/a&gt;）（当然公司要想办法赚钱）。不一定是公司本身，可能是公司内碰巧同时有坏心思和你的信息的访问权限的员工。&lt;/p&gt;
&lt;p&gt;软件业务流程设计中有个概念叫“数据的&lt;a href=&#34;https://stackoverflow.com/questions/378331/physical-vs-logical-hard-vs-soft-delete-of-database-record&#34;&gt;软删除&lt;/a&gt;（soft delete, logical delete）”，即不真正删除信息，而是标记为“不可用”。这个技术本来是用在比如“操作记录审计”，“误删除可恢复”等合适的地方，但现在被越来越多滥用在保存可牟利的用户信息、用户内容上。告诉用户手机号修改成功，但偷偷留着老的；告诉用户误发的推文删除成功，但其实没删——我不知道这算不算欺骗。&lt;/p&gt;
&lt;p&gt;这类最糟的情况目前仍是最常见的情况，真令人伤心。&lt;/p&gt;
&lt;h3 id=&#34;信息被骇客偷走&#34;&gt;信息被骇客偷走&lt;/h3&gt;
&lt;p&gt;欧盟发布的&lt;a href=&#34;https://gdpr-info.eu/&#34;&gt;GDPR&lt;/a&gt;保护了用户对个人数据的控制权（也许算只保护了欧盟网民），也推进了公司业务方面许多好的数据隐私改进。假如你所使用的平台是一家遵守GDPR的“好”公司，你可以随时删除你上传的任何数据，没有软删除的欺骗。或者你信不过公司，使用非盈利组织的服务或干脆自己搭建服务。服务器背后的人不会主动出卖你的信息，现在信息安全了吗？&lt;/p&gt;
&lt;p&gt;呃，还不安全。你看，当你还没删除时，信息仍留在服务器上。你是否记得，有一类不会遵守规则法律的人行网络行窃之事&amp;hellip;&amp;hellip;对，骇客（cracker）。骇客攻入服务器，把数据偷走（拷一份）拿去卖钱。在这个（信息不会被主动出卖的）情况里，你的信息是否安全=平台的安全防护工作做得好不好。除了自建平台外你无法控制这点，只得信任和期待。至于自建平台，服务器安全维护这份工作&amp;hellip;&amp;hellip;至少我个人能力做不到让我自己信服。&lt;/p&gt;
&lt;h3 id=&#34;如何保存非公开信息离线和加密&#34;&gt;如何保存非公开信息？离线和加密&lt;/h3&gt;
&lt;p&gt;“这样我就能安全分享（公开）信息了？” &lt;strong&gt;你不能分享了&lt;/strong&gt;，因为信息的特性，看过的人会记住（Who&amp;rsquo;s Lila?），再写到互联网上，不就又变成数字备份了&amp;hellip;&amp;hellip;保密协议是个可选方案，寄希望于对方是遵守规则的人。&lt;/p&gt;
&lt;p&gt;于是你咬咬牙决定不分享信息了，只有自己能查看。如果你决定只在一台设备上查看，把数据放在本地就足够安全，至少现在这个时代骇客比起有杀毒软件有防火墙的个人电脑，更倾向于捣鼓错误配置的服务器。如果你想借助平台在多个设备间传输信息，或想让保存在本地的数据更安全，你应该使用&lt;a href=&#34;https://boholder.github.io/blogs/individual-data-backup-summary-zh/#%E5%8A%A0%E5%AF%86&#34;&gt;&lt;strong&gt;加密技术&lt;/strong&gt;&lt;/a&gt;加密你的信息。&lt;/p&gt;
&lt;h2 id=&#34;相关想法&#34;&gt;相关想法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信息尤其个人信息，公开状态就是0和1，一旦上传过，默认算作（被出卖或攻击）公开，没有后悔药。要么永远捏得死死的不上传到公共领域（许多麻烦）；要么坦然面对，亡羊补牢，预防之后可能出现的身份盗用、骚扰等情况。我没足够地位和资源做到前者，只好选择后者。也可以准备很多套可弃用的身份，比如在中国手机号是网络身份证，可购买各运营商的虚拟手机号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是劝大家不要在网上公开透露个人信息，包括和网友聊天或推文发送自己的生活工作细节，和你共享生活（同城）或工作（同行）的网友真的从寥寥几句知道很多事，因为你们共享经验和上下文，相同信息量能触发更多关联知识。万一网友有坏心思，麻烦很大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息传递的本质不知道能否用熵增原理解释——质能守衡但信息熵不会减少。扯远了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/thought/">thought</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>大衍筮法脚本</title>
                <link>https://boholder.github.io/blogs/yarrow-divination/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/yarrow-divination/</guid>
                <pubDate>Tue, 17 May 2022 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;读音：大衍（yan3）筮（shi4）法。&lt;/p&gt;
&lt;p&gt;好奇，多搜点知识总结一下，再写个脚本模拟。&lt;/p&gt;
&lt;h2 id=&#34;相关知识&#34;&gt;相关知识&lt;/h2&gt;
&lt;h3 id=&#34;大衍之数&#34;&gt;大衍之数&lt;/h3&gt;
&lt;p&gt;搜到&lt;a href=&#34;https://www.zhihu.com/question/33646380&#34;&gt;这篇知乎文章里的答案&lt;/a&gt;讲了大衍之数的各种来历。&lt;/p&gt;
&lt;p&gt;“大衍之数”定义在《易传·系辞》（儒家整理记录的易经思想书，易经分好多流派，类似武术流派）里记录大衍筮法的原话开头，这是完整方法的原话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大衍之數五十，其用四十有九。分而爲二以象兩，掛一以象三，揲之以四以象四時，歸奇於扐以象閏。五歲再閏，故再扐而後卦。乾之策二百一十有六，坤之策百四十有四，凡三百有六十，當期之日。二篇之策，萬有一千五百二十，當萬物之數也。是故四營而成易，十有八變而成卦，八卦而小成，引而伸之，觸類而長之，天下之能事畢矣。（PS：古文没标点每间隔，这些标点是现代人加的）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么大衍之数是五十，为什么用四十九？请读第二个知乎链接。没有统一定论，各种引经据典一通计算得出这两个数，据说争论两千年了。最科学的解释大概是：计算概率发现从四十九（也有答案说四十七、四十八也行）开始执行过程，最终得到的阴、阳两大类结果的概率相似，巧了。我觉得《易经》可能也是古人从天地之数（五十五）或者大衍之数（五十）或者其他什么和天地相关的神秘数字推演，发现数字四十九的奇妙之处，所以也没提怎么变到四十九，实用主义，或者内法奥秘，不传外不成文。&lt;/p&gt;
&lt;h2 id=&#34;大衍筮法&#34;&gt;大衍筮法&lt;/h2&gt;
&lt;p&gt;知识1：中国古代说占、卜、筮是有区别的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/356420437&#34;&gt;[1]&lt;/a&gt; &lt;a href=&#34;https://new.qq.com/omn/20210117/20210117A0B15B00.html&#34;&gt;[2]&lt;/a&gt;，“占”是指算命，统称；“卜”是烧龟壳看裂纹；“筮”就是特指用这个蓍（shi1）草。所以把这个大衍筮法说成“蓍草占&lt;strong&gt;卜&lt;/strong&gt;”，严格意义上不对。&lt;/p&gt;
&lt;p&gt;知识2：龟壳比蓍草材料珍贵，所以“卜”比“筮”更严肃。有说法“卜、筮不相袭也。大事有时日，小事无时日，有筮。”——《礼记·表记》，白话解释是“大事有日程，用卜；小事随机突发，用筮”。（&lt;a href=&#34;https://read01.com/RM7NjJe.html&#34;&gt;研究:《 刘彬：子思与《易》关系新证》&lt;/a&gt;链接是谷歌搜到的内容农场网站上的复制，维普百科和知网的链接都不能直接下载PDF，咱也不知道内容农场怎么弄到这种文本的）&lt;/p&gt;
&lt;p&gt;知识3：蓍草是什么植物？看&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%93%8D&#34;&gt;维基百科&lt;/a&gt;，“菊科蓍属多年生草本植物”。多年生，我在搜索时看到说古人就是因为它多年生，生长周期长肯定吸收了天地灵气，所以用它做数占。口语英语翻译为&lt;a href=&#34;https://en.wikipedia.org/wiki/Achillea_millefolium&#34;&gt;yarrow&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;搜到&lt;a href=&#34;https://www.zhihu.com/zvideo/1383722112176238593&#34;&gt;这个动画&lt;/a&gt;讲了命令式的操作过程，7分钟建议一看。&lt;/p&gt;
&lt;p&gt;详细过程先不提，总之进行了复杂的过程（三变），最终得到6、7、8、9四个数字中的一个，称为爻（yao3）。爻有两种，八卦符号（例：坎 ☵）里的阴（中间断开的两短横）、阳（长横），但是在大衍筮法里分得更细：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 = 老阴 X&lt;/li&gt;
&lt;li&gt;7 = 少阳 —&lt;/li&gt;
&lt;li&gt;8 = 少阴 - -&lt;/li&gt;
&lt;li&gt;9 = 老阳 O&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;老少啥意思，不知道，动画说6最小所以是老阴，9最大同理老阳，7、8次第。但是老阴、老阳这两个被称为“动爻”，可以变成相反的类别（阴变阳、阳变阴，体现天地变化的）。虽然动画里每个动爻都变了，但继续搜索发现不是每个动爻都要变爻，是由解读者根据自身门派对易经的解读和各种环境变量（天干地支季节人际关系生辰八字balabala）决定变的子过程，有点抽象工厂模式的意思。原始卦象叫“本卦”，变之后叫“变卦”或“之卦”。这就是为什么说“起卦容易解卦难”，要我说就是故意往算法里加个专业知识黑盒，让普通人难以自行解卦，也增加了命运感神秘感随机性之类。我的脚本里打算让Python的&lt;a href=&#34;https://crypto.stackexchange.com/questions/39186/what-does-it-mean-for-a-random-number-generator-to-be-cryptographically-secure/39188#39188&#34;&gt;RNG&lt;/a&gt;API——&lt;a href=&#34;https://docs.python.org/3/library/os.html#os.urandom&#34;&gt;os.urandom()&lt;/a&gt;来帮我考虑是否变爻，扯远了说这RNG也是体现天地意志的，反正不受人意志影响。&lt;/p&gt;
&lt;p&gt;一个八卦是三个横杠，要三个爻组成。&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6&#34;&gt;六十四卦&lt;/a&gt;中一个卦象含上下两个八卦图案。所以总共要进行 十八变-六爻-两八卦-一卦象，那个复杂操作要循环十八次。&lt;/p&gt;
&lt;p&gt;个人认为大衍筮法就是一个手动操作的随机性算法。&lt;/p&gt;
&lt;h2 id=&#34;大衍筮法的结果概率&#34;&gt;大衍筮法的结果概率&lt;/h2&gt;
&lt;p&gt;资料 &lt;a href=&#34;http://www.360doc.com/content/18/0228/11/36557188_733116745.shtml&#34;&gt;[1]&lt;/a&gt; &lt;a href=&#34;http://202.194.14.19/CN/Y2018/V0/I1/47&#34;&gt;[2]&lt;/a&gt; &lt;a href=&#34;https://www.eee-learning.com/article/3368&#34;&gt;[3]&lt;/a&gt; &lt;a href=&#34;https://webcache.googleusercontent.com/search?q=cache:6qTcK5_2RfcJ:blog.sina.com.cn/s/blog_bfc84c450101l3bk.html&#34;&gt;[4 三变中的概率传递链]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我坦白，没看懂。但我似乎能总结：没有准确答案。这里要提到一个细节做前置知识：每一变中，都有一个“将整体的蓍草用左右手分成任意两堆”（“分而为二以象二”）的原子操作。理论计算概率时要用某种分布模型来代替这个操作的结果，用相等概率、二分、标准正态等不同模型代入概率传递链中计算出的概率是不同的。现实中这个操作由起卦执行者决定，其实是个真随机。所以结论是因为现实并不符合某种确定的分布模型，所以没有准确的理论答案。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&#34;https://www.zhihu.com/question/33646380/answer/131429959&#34;&gt;知乎答案&lt;/a&gt;，以等概率分布代入分两堆操作结果，爻的阴阳概率相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6 老阴 1/16&lt;/li&gt;
&lt;li&gt;7 少阳 5/16&lt;/li&gt;
&lt;li&gt;8 少阴 7/16&lt;/li&gt;
&lt;li&gt;9 老阳 3/16&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但因为卦象自身有二项分布的特点，比如六爻全阴或全阳的概率本来就比其他混合的卦象概率低，然后最终结果其实是三变的随机和卦象分布的叠加（概率传播），所以无论三变用什么分布模型，最后六爻概率总是接近卦象的二项分布。&lt;/p&gt;
&lt;p&gt;有些简单的起卦模拟程序会简化求出每个爻的流程，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一枚硬币，正面是阳，反面是阴。扔六次。&lt;/li&gt;
&lt;li&gt;参照大衍筮法，三枚硬币，正面是2，反面是3，求和得到6、7、8、9，扔六次。&lt;/li&gt;
&lt;li&gt;参照大衍筮法，三颗骰子，奇数是2，偶数是3，求和得到6、7、8、9，掷六次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为计算结果接近卦象分布，所以这爻用什么方法求，最终概率都差不太多。大衍筮法的优势在于：计算初始情况的结果基数多达四十九，我猜测这个基数越大，越计算随机。三变中的“随机分两堆”是大衍筮法的随机性的精髓，引入人工决策，即引入真随机。我的脚本也会碰到这个模拟问题，还是让RNG模拟人类执行者，情况基数沿用大衍筮法的四十九。&lt;/p&gt;
&lt;h2 id=&#34;程序&#34;&gt;程序&lt;/h2&gt;
&lt;p&gt;了解完理论，失去了一半动力，本质是弄个随机性算法再映射到六十四卦象，而且我又没专业知识解卦。但还是写了，不写不完整：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gist.github.com/boholder/a5bb81e17df0a4854ac9c8c0a5abd16c&#34;&gt;https://gist.github.com/boholder/a5bb81e17df0a4854ac9c8c0a5abd16c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://boholder.github.io/share/yarrow_divination.py&#34;&gt;下载（不更新补丁，请优先gist）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;了个心思。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>懒人做饭</title>
                <link>https://boholder.github.io/blogs/lazy-cooking/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/lazy-cooking/</guid>
                <pubDate>Tue, 03 May 2022 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近疫情动不动禁堂食，在家做饭的频率被迫提高了不少，总结出了点自己喂饱自己的经验，分享。想起来什么写什么。&lt;/p&gt;
&lt;h2 id=&#34;用品推荐&#34;&gt;用品推荐&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;电饭煲&lt;/strong&gt;。现代文明利器，蒸米，蒸面食，煮粥，熬汤。买普通的大小（家庭用），电饭煲做出来的菜都可以吃多顿，用单人电饭煲一顿饭一做，多处理几次食材还多刷几次锅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微波炉&lt;/strong&gt;。现代文明利器2，理论上只要水分含量控制好，能做出各种美食。至少能把生的变成熟的，味道？再调味呗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18寸不粘锅奶锅&lt;/strong&gt;，正好煮一人份。我买的16寸，但实际体验下来16寸略小，食材（主要是生蔬菜占空）多一点就凸出锅沿了，不方便翻动食材，很狼狈。奶锅下个面条，煮卤肉、火锅、乱炖，一顿一做，趁手的大小刷锅刷起来也省事。&lt;/p&gt;
&lt;p&gt;有说奶锅可以直接当碗省了刷碗的事，但是因为我的餐具是金属的，怕把不沾涂层刮坏，所以我不这样做。对了，注意不粘涂层的保养，比如别空烧、冷却后再刷锅、用塑料塑胶厨具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;煎锅（平底锅）&lt;/strong&gt;。懒，但是偶尔还想炒个菜煎个饼。奶锅锅底太小，炒起来不方便，还是用正儿八经的煎锅得劲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伸缩式洗菜金属筐&lt;/strong&gt;。我买的宜家的，就那种架在水池上的、用细铁丝网编成的筐。老家用的是塑料的双层盆，下面是实底的，上面带孔，这样能暂时把蔬菜泡在水里。这种我也买了，实践了几次发现，我根本不买需要浸泡的麻烦的蔬菜种类，所以不如金属网方便，就图洗菜时蔬菜有一个干净的临时放置的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;菜刀&amp;amp;案板&lt;/strong&gt;。菜刀不用买方正的传统的那种，买细一点的切肉刀或者尖刀就行，除非你菜谱上常有西瓜白菜金瓜之类个头大的家伙。一把刀什么都切了，不讲究。案板买大点，洗案板没土没油很方便不怕大，买小了切菜时没有足够的空间临时放置切下来后表面积变大（三维展开）的菜，需要另找一个容器放切好的菜，比较手忙脚乱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好大一个大碗&lt;/strong&gt;。以能单手不费劲抓牢为前提尽量买大碗。为了搭配微波炉，买不带金属装饰的陶瓷碗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;烤三明治机&lt;/strong&gt;。便宜的也要好几百，买不买见仁见智。上下两边铁盘加热，有定时功能，可以看作小号的电饼铛。方便是真方便，定时一拧不用管，铁盘够小洗刷也方便。除了面包片还可以煎鸡蛋、加热面食，操作两三次就凑够了一顿饭的面食量。另外我发现把面食加热到变干或出现金黄色，就会变得很好吃，可能是个人口味。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可食用洗洁精&lt;/strong&gt;。是最近才出现的产品吗？我使用它不到一年。可以直接洗蔬菜水果，有效平衡了懒得花时间处理蔬菜和对食材卫生程度的纠结之间的矛盾，让我和我自己和解。&lt;/p&gt;
&lt;h2 id=&#34;蔬菜&#34;&gt;蔬菜&lt;/h2&gt;
&lt;p&gt;如果你平时常买叶菜，NO，你不是真懒。真正懒如我的人会买方便洗菜的论个算的种类：萝卜、茄子、黄瓜、西红柿、西葫芦、柿子椒、洋葱&amp;hellip;&amp;hellip;这些菜比起叶菜多了一个上案板切块的步骤，但即使算上这个也比一叶叶小心翼翼地洗菜来得方便（个人体会）。超市切圆段的冬瓜、金瓜也是不错的选择，切切蒸煮一下就能吃。&lt;/p&gt;
&lt;p&gt;除了中餐的蘸酱拼盘和西式沙拉，我从东北同事那多知道了一些能生吃的菜，比如柿子椒，切条沾豆瓣酱和烧烤酱真的贼好吃。现在夏天了，懒得做菜但又不得不摄入蔬菜，调味生吃是一个好办法。冬天的话就水煮/微波炉加热+调味。&lt;/p&gt;
&lt;p&gt;单人买菜最难的问题是有意识地控制一次购买的量。如果你和我一样，一天不一定做一顿带蔬菜的饭，那一次购物买两三顿饭的量、一两种蔬菜就足够了，努力不要让蔬菜在冰箱里过一个星期。&lt;/p&gt;
&lt;p&gt;基于新鲜蔬菜的观点，我不看好袋装即食的沙拉，一袋至少吃两顿，水分多，叶菜，这些都不利于保存，在我冰箱里放三四天后就感觉不新鲜了（个人体会）。&lt;/p&gt;
&lt;p&gt;为了应对可能的疫情封锁，我还网购了几包压缩蔬菜片。和方便面里的菜包类似，开水冲泡食用，味道属实一般，但可贵在能保存6个月。其实我已经开始担心没有封锁怎么处理它了，怎么调味都盖不住那种泡发出来的泡水的味道，好难吃，做沙拉难以下咽，只能煮面条之类放点 :(。&lt;/p&gt;
&lt;h2 id=&#34;淀粉&#34;&gt;淀粉&lt;/h2&gt;
&lt;p&gt;除了米、面条，我还屯了压缩饼干、零食饼干、意面、燕麦片、罐装八宝粥、罐装玉米粒、黑芝麻糊、方便面。主食顿顿要吃，花样多一点比较好。这里面有一些是方便食品，懒得做饭吃饭时十分钟内填到不饿。我这还有几袋一时兴起买回来的肠粉粉、章鱼烧粉，通通和面煎饼，挺花时间，但煎饼的好吃程度值回时间成本。顺带一提淀粉因为水分少，储存时间挺长。&lt;/p&gt;
&lt;h2 id=&#34;蛋白质&#34;&gt;蛋白质&lt;/h2&gt;
&lt;p&gt;虽然说禁了堂食，但我还是会买了饭提回家吃，然后餐馆的饭不缺脂质和蛋白质（和淀粉），唯一缺的是蔬菜。自己做饭的话，我很少买肉，做法也只有微波炉烤鸡胸肉、炒、卤煮肉。购买食材的欲望来自于对成品菜的想象，大概我是因为脑中肉类菜谱少，所以对肉不感兴趣也说不定。&lt;/p&gt;
&lt;p&gt;各种豆子和大豆制品也是优质的蛋白质来源。我常买豆腐，タマモクロス说得好啊，这个豆腐，是万能的食材，很容易填饱肚子，和其他食材百搭，而且也符合我们的生吃策略。其他豆子比如超市能买到的冷冻豌豆或者豆罐头，吃起来很方便。&lt;/p&gt;
&lt;p&gt;为了应对疫情，理想的可以长时间存放的脱水蛋白质是肉干，但肉干好贵，买不起。所以我买了：豆浆粉、豆干零食、冷冻豆腐干，大豆真是好东西呀。另外一提，豆腐或者非零食的豆干等豆制品，保质期只有短短几天，当作蔬菜一样快买快吃比较好。&lt;/p&gt;
&lt;h2 id=&#34;维生素&#34;&gt;维生素&lt;/h2&gt;
&lt;p&gt;我买了综合维生素。搜了下在正常饮食时不需要吃它，甚至吃了还有点我讲不明白的坏处（某几种物质摄入过量会导致什么）。所以我会在一天没有正经吃饭时怀着想要补救的心情吃一粒。&lt;/p&gt;
&lt;h2 id=&#34;做菜&#34;&gt;做菜&lt;/h2&gt;
&lt;p&gt;这些是我现在能想起来的尝试过的简单菜谱，或者做菜的经验。或者你找个做饭APP，直接搜工具比如“微波炉”、“电饭煲”，它们能做的菜式可能超乎你想象的多。&lt;/p&gt;
&lt;p&gt;用有定时的电器“做饭”的好处是不需要时刻盯着，解放人力。奶锅煮东西也不麻烦，煮的好处是只占用一只手拿着厨具搅食材或者调节火力，另一只手可以玩手机。眼时不时瞟一眼锅别让水溢出，手敷衍地搅一搅防止食材粘锅底。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微波炉烤鸡胸肉片&lt;/strong&gt; 鸡胸肉切薄片，涂抹调味料，贴在大碗内测，微波炉高火转8分钟，没熟加钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微波炉茄子&lt;/strong&gt; 茄子横竖切四条再切段成块，加液体调味料和其他料，微波炉中火4分钟，拿出来（注意烫）用筷子让烤得有些干的茄子块沾一遍碗底部的液体调味料（料理的精髓之一是控制水分），让其保持水分，再中火4分钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微波炉地瓜&lt;/strong&gt; 地瓜洗干净一些，留点土也没事。厨房用纸沾满水包住地瓜（再一次，微波炉料理中的水分控制），微波炉中火4分钟，拿出来（注意烫）给变干的纸浇点水，再4分钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;卤肉&lt;/strong&gt; 排骨、鸡腿、鸡胸肉切大块，奶锅开水焯半熟。换水，加买的卤肉料，大火煮开卤水，确定水不会溢出也不会烧干后换小火，溜去做其他事一两小时，回来关火。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;肠粉粉蔬菜丝饼&lt;/strong&gt; 这个麻烦，算分享一个正常的菜谱吧，巨嫩巨好吃，信我。肠粉粉和面（麻烦），蔬菜切丝（麻烦）撒盐出水，蔬菜丝倒进面糊，煎饼（麻烦）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/life/">life</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>柯里化及相关延伸思考</title>
                <link>https://boholder.github.io/blogs/currying/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/currying/</guid>
                <pubDate>Thu, 27 Jan 2022 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;怎么理解&#34;&gt;怎么理解&lt;/h2&gt;
&lt;p&gt;看&lt;a href=&#34;composingprograms.com/pages/16-higher-order-functions.html&#34;&gt;这篇文章&lt;/a&gt;的1.6.6 Currying这一节。&lt;/p&gt;
&lt;h3 id=&#34;前提编程语言得支持这个玩法&#34;&gt;前提：编程语言得支持这个玩法&lt;/h3&gt;
&lt;p&gt;需要编程语言把函数当作first-class，一等成员，即允许函数被：用参数传递给函数、被函数返回、被赋值给变量。这种函数内定义的函数，可以捕获它们&lt;strong&gt;被定义时&lt;/strong&gt;（注意不是被调用时，记住这点就能弄明白）环境的变量定义，而且还能在被返回时保留这些定义（闭包）。于是我们可以用工厂模式一样的高级函数，输入一些配置参数，返回的是一个配置好的函数，然后我们再用这个参数去实际地用。&lt;/p&gt;
&lt;h3 id=&#34;柯里化&#34;&gt;柯里化&lt;/h3&gt;
&lt;p&gt;柯里化指，把接受多个参数的函数，变成一个连续的&lt;strong&gt;单个参数&lt;/strong&gt;的函数。
这样会弄出来一堆零碎的中间函数，不过中间函数都隐藏在最高阶（柯里化后只接第一个参数，返回接受其他参数的函数）的函数的内部了，外部只能看到这第一个函数的定义，所以从外部看起来不是很凌乱。&lt;/p&gt;
&lt;p&gt;有些语言（比如Haskell）的函数，只支持单个参数，于是只能用柯里化这种方式来积累参数，实现多个参数的函数定义。&lt;/p&gt;
&lt;h3 id=&#34;例子幂乘power&#34;&gt;例子：幂乘（power）&lt;/h3&gt;
&lt;p&gt;我直接用人家文章里的python代码吧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这是一个幂乘高阶（工厂）函数，你可以用这个函数生成计算特定幂乘数的函数（预先把第一个参数，即幂乘数，塞入生成后的函数的闭包）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;square&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cube&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样第一个参数就保留在这两个生成的函数的闭包里了，然后再拿着返回的函数去应用到实际的（业务逻辑）计算：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# curried_pow(2)(4) = 4^2 = 16&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sixteen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;square&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# curried_pow(3)(2) = 2^3 = 8&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;eight&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cube&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;扩展思考&#34;&gt;扩展思考&lt;/h2&gt;
&lt;h3 id=&#34;参数的位置亦代表了构造步骤先后&#34;&gt;参数的位置亦代表了构造步骤先后&lt;/h3&gt;
&lt;p&gt;你会发现，我们想用柯里化的时候，得把配置类（先固定好）的参数放在前面，计算变量类（后使用时填入）的参数放在后面，这样就能顺畅地先配置再执行，就像上面的例子。&lt;/p&gt;
&lt;p&gt;那要是反过来呢，函数的意思会变：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;# x,y颠倒顺序&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 对2做n次幂乘&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pow_on_2_with&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 对3做n次幂乘&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pow_on_3_with&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;curried_pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# curried_pow(2)(4) = 2^4 = 16&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sixteen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pow_on_2_with&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# curried_pow(3)(2) = 3^2 = 9&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;nine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pow_on_3_with&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;外部环境闭包在内部看来是不可变的&#34;&gt;外部环境（闭包）在内部看来是不可变的&lt;/h3&gt;
&lt;p&gt;之所以有上面的配置先后顺序的考虑，是因为本小节标题所示的特性。变量有不同范围的生命周期，内部环境能看到外部环境里的定义，想修改定义所绑定的值可以重新覆盖定义，但这个新定义的范围仅在本地环境，没法向上影响到外部环境。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# i还是0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我倒觉得把环境看成热塑塑料（或者更熟悉的502胶水）比较好，还在当前环境时，随便改定义捏形状，一旦退出环境或者深入到下一层环境（联想盗梦空间），环境固定死改不了了。比如函数一旦被构造出来，函数内的环境也就固定下来了。在调用函数的外部环境看来，函数内部环境直接一个黑盒，读都不能读；函数自己也不能修改硬编码的定义（比如上面i=1，不能下次调用让i定义为其他的值）。&lt;/p&gt;
&lt;h3 id=&#34;通过self-reference来绕开这个限制&#34;&gt;通过Self Reference来绕开这个限制&lt;/h3&gt;
&lt;p&gt;这节思路来自&lt;a href=&#34;https://inst.eecs.berkeley.edu/~cs61a/fa21/lab/lab03/#self-reference&#34;&gt;这道练习题&lt;/a&gt;。举个更简单的例子，我想构造一个count_down()函数，每调用它一次，它会打印内部环境中保存的数字，并且返回一个保存数字减了一的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;结合上一节的限制，这有点难，因为看起来count_down()函数的环境得自己处理每次调用把变量值减一的操作。其实还是有办法的，两种办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把函数使用变量的方式改为从外部（环境）获取定义，有点依赖反转的意思（但其实就是提前构造了下一轮的新的函数环境）：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;count_down_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;count_down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;利用Python提供的nonlocal修饰符，允许在本地环境修改外部环境中的绑定（看&lt;a href=&#34;https://www.python.org/dev/peps/pep-3104/&#34;&gt;官方文档&lt;/a&gt;里这个操作的起源和其他语言中的应用能多学到一些知识）。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;count_down_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;count_down&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;nonlocal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 不加nonlocal声明，这句赋值会报编译错误&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count_down&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>SRP提醒你不要盲目遵守DRY设计原则</title>
                <link>https://boholder.github.io/blogs/srp-against-dry/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/srp-against-dry/</guid>
                <pubDate>Thu, 23 Dec 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;首先提醒一下记得&lt;a href=&#34;https://en.wikipedia.org/wiki/Single-responsibility_principle&#34;&gt;单一职责原则（SRP）&lt;/a&gt;是面向对象实践下的设计原则，也是&lt;a href=&#34;https://en.wikipedia.org/wiki/SOLID&#34;&gt;SOLID&lt;/a&gt;五大面向对象设计原则之一。然后&lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;不要重复自己（DRY）&lt;/a&gt;原则则是更泛化的编程原则，也可以用在编程工作以外。这个短文讲两个原则的关系，总归还是把前提限定在了面向对象编程之内。&lt;/p&gt;
&lt;p&gt;我记得这是哪本书上的例子，大概是&lt;a href=&#34;https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882&#34;&gt;Clean Code&lt;/a&gt;，它是用这个例子来解释SRP的含义的，我稍微改一下，不翻原书了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求1：有三种员工，经理和普通员工和临时工，计算他们薪资的算法是相同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需求1映射到代码里就是，三个分开的员工类，然后三个类计算薪资的方法内部会调用同一个工具函数，DRY，对吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求2：计算经理薪资的算法变了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单嘛，我们会动手把经理类的薪资计算逻辑内化到经理类的薪资计算方法里，因为现在经理的薪资计算逻辑是“特例”的；然后员工和临时工维持不变，继续使用公共的工具函数，因为计算他们的薪资逻辑是“通用”的，完事。&lt;/p&gt;
&lt;p&gt;但实际上，实现需求1时就已经违反了SRP了。这个“薪资计算”是一个&lt;strong&gt;具体的业务逻辑&lt;/strong&gt;，即使三种员工是相同的算法，也应该把这个算法复制三份，粘贴到三个类的薪资计算方法里，抽成公共函数是个错误的选择。公共函数应该是与业务逻辑无关的。这就是SRP的含义，一段和业务相关的代码应该独一份存在，修改它不会影响到其他组件，或者说，&lt;strong&gt;这段代码只对一个修改理由负责&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;“与业务逻辑有关”的，为了DRY原则而抽取的函数也有，比如一个组件里被多次调用的私有函数，该函数只为该组件的修改而负责，因此没有违反SRP。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>组装台式电脑的经验总结</title>
                <link>https://boholder.github.io/blogs/introspection-of-pc-diy/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/introspection-of-pc-diy/</guid>
                <pubDate>Sun, 28 Nov 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;我不是装机发烧友，过程中也请教了不少朋友和互联网，但现在想想其实不是很麻烦，主要是没有整体的知识框架，是无知导致的畏手畏脚。所以把最近第一次组装台式主机的经历和总结记下来，如果能帮到其他人就更好了。&lt;/p&gt;
&lt;h2 id=&#34;选配件&#34;&gt;选配件&lt;/h2&gt;
&lt;p&gt;就算知道配件的知识，什么接口什么协议，那些都是抽象的行业标准，对选配件没太大帮助。比如你知道牛奶的国标，但还是在货架旁纠结买哪个品牌的牛奶。和买牛奶一样，选电脑配件就是选品牌，需要对品牌甚至品牌下的产品线有一个整体的了解，不是发烧友一般不会主动去获取这方面的知识。下面我会多次提到某个配件“竞争品牌多，勤搜索论坛和评测，注意别翻车”这类话，就是指，首先搜着看一些广谱的推荐文章，选定一些品牌型号，然后挨个在网上搜这个型号的评价。&lt;/p&gt;
&lt;h3 id=&#34;要注意的整体指标&#34;&gt;要注意的整体指标&lt;/h3&gt;
&lt;p&gt;选配件时整体指标有这几个：预算，期望的机箱大小，期望的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预算限制各个配件间的性能（=价格）平衡，有一个大概的认知，自己是在选高中低哪个层次的配置。配件间的性能平衡有点水桶效应的感觉，但其实有经验可以把预算向自己期望的功能上倾斜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立显卡不便宜，会吃掉相当一部分预算，最好认真考虑自己是否需要独立显卡，可能去了独显，给CPU配好点，用集显一样满足，还能空出不少预算给其他配件。&lt;/li&gt;
&lt;li&gt;我的预算没设上限，因为：1.我本来经验就不够，不想再花多余精力去学习如何平衡预算。2.电脑天天用，用使用时间折算下来每小时花费会很低，所以我想对自己好点，指着高端机配，价格铁定低不了，认了，多花点时间攒钱就是。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机箱大小会从物理上限制一些大块头配件的选择，比如想组i-atx或者m-atx的小机箱，三风扇显卡肯定塞不下。我发现，双风扇的显卡和同型号的三风扇显卡的性能差一截，价格却贵1000，于是放宽了自己组m-atx机箱的限制，决定用三风扇显卡组atx机箱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;期望的功能和各配件性能选择挂钩，比如想多任务就多加内存，想运行大型计算任务就选好的CPU，想玩3A游戏就配一个差不多的独显&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个的原则怎么说呢，和房子硬装修差不多，一是保证自己当前的需求，二是留下为未来升级时兼容的空间（免得日后发现不兼容，迫不得已再掏一笔钱买兼容的底层配件，比如主板）。我的需求是这样：能够给现在和未来5年的3A游戏开最高配置，能够无限期长地（做美梦）满足硬盘和内存容量之外的未来需求。&lt;/li&gt;
&lt;li&gt;可以看百度贴吧显卡吧的&lt;a href=&#34;https://tieba.baidu.com/p/7596093640?see_lz=1&#34;&gt;每月装机推荐贴&lt;/a&gt;了解更多配件和功能间的相关关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有顺序地选择配件产品&#34;&gt;有顺序地选择配件产品&lt;/h3&gt;
&lt;p&gt;我们都知道，主机机箱里头的东西有这几个配件：CPU、主板、内存、硬盘、显卡、电源、CPU风扇，然后还有外面保护它们的机箱。其实它们之间的型号、兼容性、需求是相互关联的，这样就可以固定下来一个选配件的顺序，减少型号选择范围：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 先选CPU和CPU风扇。&lt;/strong&gt; 台式机的CPU就两家公司的产品在竞争，Intel和AMD。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果买整盒的CPU，里面会附送官方设计的CPU风扇，但只买CPU散片+第三方CPU风扇DIY灵活度更高和价格更实惠一些。虽然我怕麻烦直接买了整盒就是了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（注意Intel的芯片针脚是平面，但AMD的是密密的针脚，装AMD的CPU要注意不手抖，针脚坏一个就报废了。其实这个对选哪家没影响。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我看这几年Intel老是被笑话挤牙膏，但是AMD的新的CPU架构却表现不错，值得期待。本着对未来升级CPU时的（主板）兼容，我选了AMD。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 选完CPU，对应的主板型号也固定了。&lt;/strong&gt; 因为&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%BB%E6%9D%BF%E8%8A%AF%E7%89%87%E7%BB%84/237571&#34;&gt;主板芯片组&lt;/a&gt;是和CPU相对应的。然后主板的品牌，御三家，华硕、微星、技嘉，三选一&lt;del&gt;选择你的神奇宝贝&lt;/del&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我选的华硕，因为我那个型号的主板华硕的有个额外功能，我看中了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 再之后独立地选内存和硬盘。&lt;/strong&gt; 这两个产品的竞争企业就多了，所以要勤搜索论坛，挑有口碑的大牌子买，注意选个没翻车的型号。也要注意数量不要超过主板上预留的对应接口数量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存注意买需要的容量除以2或4，两条或四条相同的内存条（组装双通道），然后两条内存就注意插主板的2，4两个插口（没搜到这个什么讲究，据说这样好），4条就1234四个插口都用上。品牌我选的金士顿FURY。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;年中时有段时间兴起Chia加密货币，用大容量HDD挖这个币性价比高，那段时间消费者级别的大容量（&amp;gt;3T）HDD直接断货。现在好像不火了，硬盘又有货了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在HDD厂商在推广&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%A0%E7%93%A6%E7%A3%81%E8%AE%B0%E5%BD%95&#34;&gt;叠瓦磁记录技术&lt;/a&gt;，虽然它有潜力，但目前性能不如老技术&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9E%82%E7%9B%B4%E7%A3%81%E8%AE%B0%E5%BD%95&#34;&gt;垂直磁记录&lt;/a&gt;，所以买HDD暂时别买新出的叠瓦盘产品。话说回来，这是不是这意味着垂直磁盘的存货越来越少了&amp;hellip;&amp;hellip;不知道厂商们是否还在运行垂直磁盘的流水线。HDD品牌我选的希捷酷鱼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有就是时间沉淀对于黑料爆料比较重要。我的SSD开始就是2021年年初从显卡吧的装机贴里的推荐表格选的，西数黑盘SN850，然后选完放一边了。之后要买的时候群友提醒我&lt;a href=&#34;https://www.youtube.com/watch?v=e5qjT-wRk1U&#34;&gt;SN850翻车了&lt;/a&gt;，我一搜，嘿，就2021年年中刚出的事，然后我换了三星的970。得亏群友提醒一句，也得亏我拖延买配件（等最后也没等来的显卡降价）的时机拖得久。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 大头来了，选独立显卡。&lt;/strong&gt; 设计显卡芯片的核心公司有两家，Nvidia和AMD，但是拿到芯片并制造显卡的制造商有很多家，注意别翻车。比较好的一线还是御三家华硕、微星、技嘉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以前的老主板存在主板PCI插口型号和显卡插口型号的兼容性问题，现在都是PCI-E可以不再顾虑了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近要特别关心挖矿（挖加密货币）导致的不良二手显卡流入市场的问题。有这几个建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;买新卡，别图便宜买网上的二手，风险大不值得。&lt;/li&gt;
&lt;li&gt;N卡的话，买V2版本芯片的显卡，即挖矿性能限制（LHR）版，包装上会标注V2，&lt;a href=&#34;https://new.qq.com/omn/20210703/20210703A040HP00.html&#34;&gt;芯片序列号也会与先前的未限制版有所不同&lt;/a&gt;。包装盒上和显卡内部都会有序列号，担心盒子被掉包的话，显卡内部的序列号要插上主板，用一些软件看（我是没预装驱动，主板不识别显卡，吓坏了以为显卡坏了，最后装完系统装上驱动用GeForce Experience看的序列号）。&lt;/li&gt;
&lt;li&gt;显卡出场日期尽量晚，可以给显卡制造商客服打电话，报序列号查询。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我最后买了华硕的30系N卡，因为看测评，新的A卡的性价比好像打不过N卡。价格，唉，回头和朋友一聊，我买了个较原价溢价40%的“双十一特惠价”，就这还是现在的中国大陆市场上比较便宜的价格，认了，不想等了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 主板和显卡，一横一竖，构成了对机箱的长宽高度要求。&lt;/strong&gt; 选机箱主要看大小和预留的配件位置数量。机箱这个技术门槛很低，竞争的厂家就更多了，注意搜评测避免翻车不好的设计。注意机箱预留的SATA口硬盘位置数量要满足之前对硬盘的选择。机箱上能搞得花样（附加功能）比较多，选什么看人，我选了先马的黑洞，图它的静音降噪设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 跟着机箱一起买的是机箱冷却配件。&lt;/strong&gt; 一般是风扇，用水冷的人一般知识丰富，应该不需要这篇文章的指导（偏见）。买几个风扇？得看配件的性能（发热量），这我搞不懂。所以我买机箱时直接选的满数量的风扇的组合套装，因为散热不足比散热溢出更危险，而且风扇耗电量并不高，没必要抠门。买什么样的风扇？我买的是不智能控制转速的恒定转速的静音风扇，风扇大小看机箱的设计允许。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 耗电的配件选好了，计算功耗选电源。&lt;/strong&gt; 电源技术门槛不高，竞争厂家很多，注意别翻车。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在搜索引擎上搜&lt;a href=&#34;https://www.google.com/search?q=Power+Supply+Calculator&#34;&gt;“Power Supply Calculator”&lt;/a&gt;有很多功耗计算器。也可以对用电大户比如独立显卡专门搜索一下功耗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电源的品质有一些层级，从铜牌、银牌到金牌、钛金&amp;hellip;&amp;hellip;整的跟MMORPG的装备品质一样。这个指的是转换效率的高低，直观体现就是高负载时发热少、耗电少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是注意！电源功率不足会损害硬件，而且电源的功率/价格比和其他配件的价格相比很不值得抠门，考虑到未来升级的兼容性，最好买功率溢出个一二百瓦的电源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我选择了安钛克的金牌HCG750，因为我搜索发现论坛对这个型号的表现比较满意。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终于选完了，现在看一眼候选表的总价，叹一口气，并开始攒钱。顺便时不时地关注一下配件的市场价格变动和新的黑料。有个好的时机就出钱买下来吧，可以独立地购买并更换不同配件。但是因为我是第一次装机，手边没有现成的机器，无法独立验证各配件的可用性，所以我只能一次全部买下来然后火急火燎地测试，争取在商家保证期内申请退换货。还好后来有惊无险，没有发生问题。&lt;/p&gt;
&lt;h2 id=&#34;走一步看一步的装机&#34;&gt;走一步看一步的装机&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;防呆不防傻，大力出奇迹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话是个梗，现在的配件间的接口都有防呆设计，比如换一个方向就插不上扣不上之类（不会出现USB接口的需要试插三回的量子态设计），但是不能避免装不上硬装，一使劲把脆弱的插口搞报废的情况，所以应该对自己的配件温柔点，想想它值多少钱。&lt;/p&gt;
&lt;p&gt;现在的配件都标准化了，简化了装机所需的必备知识量，不是专业人士也可以按着指导自己动手组装。其实装机就两种步骤交替做，把两个配件的接口插好，用螺丝把配件固定位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工具只有螺丝刀足够了，不过&lt;strong&gt;非常建议准备好头部带磁性的螺丝刀&lt;/strong&gt;，小螺丝没装好掉进缝隙间，粗粗的手指头是伸不进去的，只能用这种螺丝刀吸出来，而且磁性螺丝刀也能提高第一次拧螺丝就对好口的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境的话，首先要有一个高度合适方便长时间工作的平面，然后平面周围要有充足的光源。我趁着阳光充足的周末，把我们家的餐桌拉到窗户旁，作为临时的工作台。最后拖到日落都没装完，我又拿来一盏台灯做光源。光照对精密操作很重要，要看字号很小的标记，要对准很小的口拧很小的螺丝。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于装机指导材料，首先我推荐BiliBili上装机猿这个PO主的三集系列视频：&lt;a href=&#34;https://www.bilibili.com/video/BV17J411L7Rr&#34;&gt;【装机猿】学装机免费 学不会下期还免费&lt;/a&gt;，&lt;a href=&#34;https://www.bilibili.com/video/BV1TJ411j7xk&#34;&gt;【装机猿】装机免费学② 免费爽！一直免费一直爽！&lt;/a&gt;，&lt;a href=&#34;https://www.bilibili.com/video/BV15J4115774&#34;&gt;【装机猿】免费学装机③ 还用我帮帮你么？&lt;/a&gt;。别看人家插科打诨地讲，里面的知识足够我这种第一次接触的新手明白装机的顺序和要领。&lt;/p&gt;
&lt;p&gt;不过其实可以按装机步骤去针对性地搜索教程，视频为佳。比如一个空荡荡的机箱，装机的顺序应该是：往机箱上固定机箱风扇、硬盘、（提前插好线的）电源、主板（主板上最好提前插好CPU、CPU风扇、内存条、M.2接口的SSD）、显卡。每一步都可以搜索&amp;quot;机箱名字&amp;quot;+&amp;ldquo;配件名字&amp;rdquo;，学习如何把配件固定到机箱上。剩下的知识由装机猿的视频补足，比如主板上各种接口的连接方式，还有电源线的连接方式。主板的说明书会很详细地写明其他配件连接到主板的安装方式。&lt;/p&gt;
&lt;p&gt;注意装电源时，先把电源线插上电源，把线另一头穿过机箱上各种固定孔为下面的连接提供便利（搜索如何“走线”），再把电源固定到机箱上。电源如果是模组化的话，它包装盒里有好多各种连接线，但是你买的配件数量一般小于电源能供电的配件数量，所以这里见仁见智：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;把线都插上，但只连接需要数量的线，没用到的线小心地用轧带固定好，以备以后增加配件的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只插需要数量的线，没用到的线收起来，日后增加配件就把电源拆下来再插线（电源固定在机箱内时不太方便插线，那个线蛮难插拔的）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有就是主板上的M.2插口位（SSD位），我这个主板有两个，一个是裸露的，一个被一块金属板遮住了位置。我以为金属板是装饰，之后做数据迁移，迫不得已要插两条SSD，搜索拆掉金属板的方法，才得知金属板下有硅脂，这是一块散热板，就是为做系统盘的SSD准备的位置。&lt;/p&gt;
&lt;p&gt;从中午12点到晚上23点，从完全0经验、一地没拆封的配件，到装好主机、配件盒子在杂物间里摞得连死亡搁浅的配送员都要称赞的整齐。装完后没有满足感，反而有点害怕，因为马上就要检验成果了——点亮。&lt;/p&gt;
&lt;h2 id=&#34;点亮先装临时系统检查配件情况&#34;&gt;点亮！先装临时系统检查配件情况&lt;/h2&gt;
&lt;p&gt;提心吊胆的时刻来了。这个“点亮”什么意思，我也没搜到，有说是显示器、有说是硬盘灯、有说是RGB。我这个机子比较奇怪，不用BIOS设置，自动切到独显（查过说这个是现代主板的默认操作），所以插主板的HDMI口，显示器不亮，吓了一身冷汗，换成插显卡的HDMI口就接通了。&lt;/p&gt;
&lt;p&gt;只要主板、CPU、内存、显示器正常，我们就能进BIOS。BIOS里就能显示各配件的参数，如果一个配件没能被主板识别，那就麻烦了。比如我这次BIOS不识别显卡，吓得我当场就先提交了换货申请，然后继续排查问题。还有就是如果BIOS不能正常启动，会提示一些英文错误，比如我就马虎地把CPU风扇插错了主板接口（没插CPU_FAN插成了CHA_FAN，俩接口一样），BIOS就提醒“cpu fan error（检测不到CPU风扇转速）”。&lt;/p&gt;
&lt;p&gt;我预先准备了一个Windows装机U盘（对我是Windows用户），所以我直接在BIOS上把引导切到装机U盘，在空白的硬盘上装了个Windows。赶紧联网下载Nvidia的支持软件Nvidia Control Panel，装显卡驱动。然后虚惊一场，显卡可以正常被识别，序列号也没有问题。然后我用这个临时的Windows系统（之后要恢复成我笔记本上的系统）运行了那些跑分软件，比如&lt;a href=&#34;https://geeks3d.com/furmark/&#34;&gt;FurMark&lt;/a&gt;跑显卡压力测试、&lt;a href=&#34;https://crystalmark.info/en/software/crystaldiskinfo/&#34;&gt;CrystalDiskInfo&lt;/a&gt;看硬盘情况&amp;hellip;&amp;hellip;看指标一切正常，我松了口气，开始准备数据迁移，完全没有预料到数据迁移才是整个装机过程中最艰难的阶段。&lt;/p&gt;
&lt;h2 id=&#34;艰难的数据迁移之路&#34;&gt;艰难的数据迁移之路&lt;/h2&gt;
&lt;p&gt;这里多嘴说一句，现在的SSD厂商会提供从HDD把Windows系统迁移到SSD的实用工具程序，比如三星的&lt;a href=&#34;https://www.samsung.com/semiconductor/minisite/ssd/download/tools/&#34;&gt;Data Migration Software&lt;/a&gt;，如果你的需求就是这个，直接用这类软件做迁移，非常方便。&lt;/p&gt;
&lt;h3 id=&#34;windows系统还原机制因远古的硬盘发现逻辑意外失效了&#34;&gt;Windows系统还原机制因远古的硬盘发现逻辑意外失效了&lt;/h3&gt;
&lt;p&gt;我本来想用Windows自带的系统还原机制，直接用装机盘执行高级启动，然后还原我在笔记本上用“备份和还原(Win7)”做的备份（我一直用它做备份，以前用的SyncToy不能备份系统分区，只能备份文件）。之前我的笔记本上有两个盘，SSD做系统盘（C区），HDD做数据（其他区），现在我的新电脑上也是一个SSD一个HDD，而且临时Windows在SSD上。我想聪明的微软的工程师们写的系统还原程序，一定可以正确地运行吧。想法很好，事实上它运行的也很好，但我一觉醒来傻眼了：我的SSD里装的是数据分区，而HDD变成了系统盘。&lt;/p&gt;
&lt;p&gt;为什么？我又运行了一次装机盘，发现了问题所在：Windows装机程序将我的SSD认成了第二块硬盘（Disk 1），而把HDD认成了第一块（Disk 0），我本应在装临时系统时就注意到这个问题的。我搜索到了看起来匹配的&lt;a href=&#34;https://support.microsoft.com/en-us/topic/disk-drive-numbers-may-not-correspond-to-the-sata-channel-numbers-when-you-install-windows-on-a-computer-that-has-multiple-sata-or-raid-disks-864bae20-e7dd-6b4e-7cdd-359be0a6d546&#34;&gt;原因&lt;/a&gt;，但遗憾地发现没有可用的解决方案。简单来说，Windows对硬盘的排序逻辑是越过BIOS通过硬盘驱动遍历请求硬盘，并根据它们的响应顺序确定硬盘次序。SSD，你为什么响应跑不过HDD，是你的驱动不够快吗？唉。&lt;/p&gt;
&lt;p&gt;事后诸葛亮的猜测，此时我直接用实用工具把系统从HDD迁到SSD，再单独把文件恢复，这事就结了。&lt;/p&gt;
&lt;h3 id=&#34;尝试耍聪明骗windows还原程序失败&#34;&gt;尝试耍聪明骗Windows还原程序，失败&lt;/h3&gt;
&lt;p&gt;我思考了一下，我的数据盘仅仅是数据盘，没有任何其他系统分区，所以我可以手动给HDD分区，通过Windows的文件还原的机制来还原文件。只想办法往SSD里还原系统就好了。现在问题是识别硬盘顺序颠倒，好，我把HDD拔了，只恢复系统分区和C盘，这一对一，能成功吧？结果是不行，系统还原程序报错不执行，说“错误0 指定不存在的设备”。&lt;/p&gt;
&lt;p&gt;我想是不是这次备份牵扯到两个硬盘，所以备份里有相关信息记着有两个硬盘，只恢复C盘和系统分区，它也要求有两块硬盘。我再做一个只有C盘和系统盘的备份，只涉及一块硬盘，可以吗？结果是，不行，它还是报那个错。事后诸葛亮地猜测，如果当时我把笔记本的机械硬盘线拔了再备份C盘和系统盘，也许就能成功。&lt;/p&gt;
&lt;h3 id=&#34;上pe和diskgenius复制硬盘成功&#34;&gt;上PE和DiskGenius复制硬盘，·成功&lt;/h3&gt;
&lt;p&gt;实在不行啊，上终极方案：直接对数据动手。我把笔记本里的SSD拆了，装在新电脑主板上，然后插上我的PE盘（这里推荐使用&lt;a href=&#34;https://www.wepe.com.cn/&#34;&gt;WinPE工具箱&lt;/a&gt;，可惜里面DiskGenius是32位，我需要64位的，又自己加了一个），用&lt;a href=&#34;https://www.diskgenius.cn/&#34;&gt;DiskGenius&lt;/a&gt;强行复制硬盘数据，然后重新引导了MBR。这下成了，看起来注册表和高级系统变量还在，但有部分程序不能启动，比如Office套件，NodeJS之类，重装软件就好了。光这个迁移来来回回折腾了三天。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;现在可以愉快地使用新电脑了。我对新电脑做了一次“备份和还原(Win7)”，备份成功了，那下次是不是这个备份会往Disk 1上还原系统盘呢，我不知道。只能希望这个台式机不会出现需要还原系统的大错误了。😬&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/thought/">thought</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>白话解释单元测试中的Mock概念</title>
                <link>https://boholder.github.io/blogs/mock-in-nutshell/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/mock-in-nutshell/</guid>
                <pubDate>Thu, 25 Nov 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文旨在配合图示帮助读者理解单元测试中的“Mock”这个技巧概念，希望下次开发时大家可以用到这个技巧。&lt;/p&gt;
&lt;p&gt;简单说一下单元测试的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试对象通常是（单个模块的）单个方法。&lt;/li&gt;
&lt;li&gt;目标是用代码把对方法的行为的期望固定成能重复执行的脚本，以实现自动化测试。&lt;/li&gt;
&lt;li&gt;通过预先定义输入值与对应的&lt;a href=&#34;https://en.wikipedia.org/wiki/Test_assertion&#34;&gt;断言(assertion)&lt;/a&gt;
这种二元组，来检查某个状态值是否符合预期。（语义即：我期望给方法传值A时，返回值|输入值变成|实例的某个依赖收到值B）&lt;/li&gt;
&lt;li&gt;断言是另一个二元组，即&lt;strong&gt;期望值&lt;/strong&gt;和&lt;strong&gt;实际值&lt;/strong&gt;，常用&lt;code&gt;except&lt;/code&gt;和&lt;code&gt;actual&lt;/code&gt;两个变量名。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用方法会产生两种行为，两种行为可同时发生，但至少发生一种，要不它就失去了作为方法的方生意义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;方法根据输入值“只读”地返回对应输出值，非常直白，没有改变包括输入值在内的其他数据。通常把这种方法称为“无副作用(side-effect)”的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法根据输入值，&lt;strong&gt;改变了&lt;/strong&gt;输入值本身，或者方法所属的模块实例（this,self），或者模块实例所包含（has-a）的依赖的状态（，并返回结果）。通常称为“有副作用”的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的测试要覆盖这两种行为，尤其要注意不太直观的第二种行为。（但是说测第二种行为，也会忽略方法对模块实例本身状态的改动，毕竟这个算模块自己的私事，我们强行去测就破坏封装性了（比如在Java里用反射去看类私有字段的值，也不是不能做到）。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://boholder.github.io/img/postimg/2021/mock-0.svg&#34; alt=&#34;一张展示一个看起来人畜无害的add方法可以背地里偷偷删库的图片&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;不用mock技巧直接测试方法的返回值或输入值的改变&#34;&gt;不用Mock技巧，直接测试方法的返回值或输入值的改变&lt;/h2&gt;
&lt;p&gt;我们可以直接用断言测试这两种值。很普通，大家都会，没什么好讲的，但是还是要写出来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 测返回值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;testAdd&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;assertEquals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;changeName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 测输入值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;testChangeName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;assertEquals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;changeName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;用mock技巧获知被测组件对依赖的调用&#34;&gt;用Mock技巧获知被测组件对依赖的调用&lt;/h2&gt;
&lt;p&gt;返回值和输入值，我们能直接拿到，关键是怎么“看”到模块的依赖的改变，这就是Mock机制的意义所在。&lt;/p&gt;
&lt;p&gt;关于Mock概念本身什么意思，&lt;a href=&#34;https://stackoverflow.com/questions/2665812/what-is-mocking&#34;&gt;这个Stackoverflow的问题&lt;/a&gt;
被回答得很好，建议一读。简单总结，就是给被测模块注入一个模拟的依赖，一个25仔，让它给我们通风报信被测模块对它做了什么。谁让方法自己不给我们说的。&lt;/p&gt;
&lt;p&gt;这里使用Java语言中的&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; 库 演示Mock机制，这个技巧不容易徒手实现，需要借用现成的库。&lt;/p&gt;
&lt;p&gt;一个坏坏的计算模块要在add方法中加入删库的逻辑，但它的返回值表现得就像普通的add方法一样。可惜根据单一职责原则，它不能独立执行删库这个操作，要调用另一个删库组件DbDeleter的delete()
方法。我们会配合使用Mock技巧来编写对删库操作的期望。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EvilCalculator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 删库组件依赖。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DbDeleter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 这是Java的类构造方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EvilCalculator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DbDeleter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;deleter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;deleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 坏！
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;删库成功！&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;deleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;生产环境数据库&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 开瓶香槟庆祝
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 但仍然伪装自己是正常的add方法。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 借助Junit框架让Mockito库可以自动扫描这个测试类中的注解，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 减轻编码工作量
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@RunWith&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MockitoJUnitRunner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;getEntitiesByCategoryTests&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MethodTestsClass&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 被测模块所需的依赖
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 一般都给Mock的实例名前面加上Mock前缀。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// @Mock注解生成一个对应类型的Mock实例。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@Mock&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;DbDeleter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mockDeleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 被测模块
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// @InjectMocks注解把生成的Mock删库实例（通过调用构造方法自动地）注入到坏计算模块中。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 即，让25仔打入坏蛋内部。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@InjectMocks&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;EvilCalculator&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;calculator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;withNormalResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 设置Mock删库实例被调用doIt()方法时的返回值，让坏计算模块以为删库成功了。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// Mockito的话，不设这个调用时会返回null。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;given&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mockDeleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;doIt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;willReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;删库成功！&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 调用坏计算模块，同时也把返回值测了。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;calculator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 让我们看看坏计算模块对Mock删库模块说了什么
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;captor&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 捕获（查看）坏计算模块传给Mock删库模块的delete()方法的参数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 顺便期望坏计算模块只调用了一次删库模块的delete()方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;verify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mockDeleter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;capture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 早就料到（期望）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;生产环境数据库&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://boholder.github.io/img/postimg/2021/mock-1.svg&#34; alt=&#34;一张展示用Mock技巧回避删库的图片&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;延伸&#34;&gt;延伸&lt;/h2&gt;
&lt;p&gt;特别的，Mockito含有断言Mock组件行为的API，比如上面示例中断言方法调用次数。一般单独的Mock技巧只能用来取值，还要结合其他断言库去验证值的正确性。Mock不仅可以让我们取得被测模块传给依赖的值，还能让我们设定依赖对被测模块调用的返回值，我称之为“第二种输入”，比如让依赖抛异常，看被测模块能否妥善处理。&lt;/p&gt;
&lt;p&gt;Mock技巧不止局限于单元测试层面，这是一个通用概念。假如上面的坏计算模块不再依赖删库模块，而是自己实现了删库操作&amp;hellip;&amp;hellip;没事，我们还能往数据库里导&lt;a href=&#34;https://mockaroo.com/&#34;&gt;假数据&lt;/a&gt; 或者一整个的&lt;a href=&#34;https://springtestdbunit.github.io/spring-test-dbunit/&#34;&gt;数据库实例&lt;/a&gt; 都是假的，这是在集成测试中应用Mock概念的一个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://boholder.github.io/img/postimg/2021/mock-2.svg&#34; alt=&#34;展示单元测试需要设置输入值和依赖的返回值，而要断言输入值、输出值和被测对依赖的调用值的图片&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/unit-test/">unit-test</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>编程所需要的东西</title>
                <link>https://boholder.github.io/blogs/what-you-need-for-programming/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/what-you-need-for-programming/</guid>
                <pubDate>Mon, 16 Aug 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文试图通过介绍编程工作中的部分技能和知识，帮助新进入程序员职业的朋友熟悉未来的工作。特别的，本文将额外提供以Java编程语言下的Spring框架开发Web应用后端逻辑的工作相关的介绍。&lt;/p&gt;
&lt;p&gt;因本文实在冗长，建议你结合目录挑选自己感兴趣的部分阅读。如果你想通过文本做跳板寻找优质学习资源，希望附录部分我精心挑选的网站和书籍推荐让你满意。&lt;/p&gt;
&lt;p&gt;对读者的要求：打算把程序员作为职业，还尚未入行的朋友。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;h3 id=&#34;ide与文本编辑器&#34;&gt;IDE与文本编辑器&lt;/h3&gt;
&lt;p&gt;文件格式分两种，人能读懂的文本文件，和机器能读懂的二进制文件。源代码是文本文件。&lt;/p&gt;
&lt;p&gt;编程其实是在用文本编辑器（Text Editor）修改一个个文本文件（源代码文件）的内容，就像你用Windows记事本打开txt文件敲一些文字一样。理论上你可以用记事本写源码，实际上，有一些电脑达人们喜欢用Linux下的&lt;a href=&#34;https://www.vim.org&#34;&gt;Vim&lt;/a&gt;和&lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt;写源码，它们相当原始，但若用好快捷键与定制功能，它们会变得非常强大。&lt;/p&gt;
&lt;p&gt;虽然可以，但是你往往不想用记事本写代码，因为它们不是“专业写代码”的工具软件，用起来不顺手。你需要的是专业帮手——IDE。IDE全称&lt;a href=&#34;https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524&#34;&gt;集成开发环境（Integrated Development Environment）&lt;/a&gt;，是用于提供程序开发环境的应用程序，包括代码编辑器、编译器、调试器等工具，集成了代码编写、语法分析、编译、调试等额外功能。IDE本质上是一个挂载了许多协助编程的额外功能的文本编辑器。&lt;/p&gt;
&lt;p&gt;一款，你只需要选择并熟练使用一款文本编辑器，你便有了编写源代码的趁手工具。无所谓它是否属于IDE，自己喜欢就好，因为那些编译调试之类的工具大可以在文本编辑器外单独使用。不同文本编辑器的基本功能（即文本编辑功能）大同小异，我们在意的是附加的功能（或丰富的插件市场）、以及完备的快捷键集合（快捷键对程序员来说很重要，可以让我们手不离开键盘完成代码编写，时不时抓鼠标会减慢速度且打断思路）。&lt;/p&gt;
&lt;p&gt;我目前用了三款文本编辑器以适应不同需求。下面我给出一些我知晓的文本编辑器供你浏览，你也可以自行搜索&amp;quot;editor for programming&amp;quot;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vim.org&#34;&gt;Vim&lt;/a&gt;和&lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; 这两个文本编辑器很特殊，你可能会在任意一款热门编辑器上看到这两个编辑器的快捷键替换插件。它们的狂热用户们（也同样是业内的老前辈、扛把子们）不愿意因切换文本编辑器而学习新的快捷键，因为快捷键已经变成了某种肌肉记忆，很难改变。这时你应该注意到了，快捷键是某种门派一样的东西，同时学两套快捷键会形成冲突，你只能选一套并把它变成肌肉记忆。快捷键会伴你整个职业生涯，因此慎重选择你的文本编辑器（或者直接学这两款文本编辑器之一的快捷键）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轻量级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://notepad-plus-plus.org&#34;&gt;Notepad++&lt;/a&gt; 它有一些用户插件来提供额外功能。因为它的启动速度很快，我用它作为最轻量级的文本编辑器，用来临时记录或粘贴一些文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sublimetext.com/&#34;&gt;Sublime Text&lt;/a&gt; 大概是和notepad++并列的一款轻量级文本编辑器，我没用过，我有一个朋友把它作为轻量编辑器使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中量级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt; 简称vscode，中量级的全能文本编辑器（全能指什么编程语言都支持），有丰富的插件市场，你可以把它改造成编写任何编程语言的IDE。我最近发现自己修改格式化的配置文本文件的频率变高了，因此选择了它作为中量级的编辑器，用它阅读与修改markdown（现在正在用它写这篇文章）、json、toml、yaml等格式的文件。事实上许多前端开发者使用vscode作为编写经典前端代码（HTML+CSS+JavaScript）的IDE。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt; 大概是与vscode相对的中量级编辑器，还是我的那个朋友会用它，我个人并不了解，姑且列出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重量级（IDE）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://visualstudio.microsoft.com/&#34;&gt;Visual Studio&lt;/a&gt; 微软出品，商业产品，被戏称为宇宙第一IDE（但我没搜到原因）。据我所知可以编写.Net、C、C#、C++、Python、Android语言。体积超级大，启动超级慢，用起来&amp;hellip;我感觉不到好在哪里，可能我没有深度使用。有插件市场。当你看到安装界面中各种数据分析、机器学习等高大上的可选项时，你会感受到这IDE真的体现了微软一如既往的商业又专业的味道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/&#34;&gt;JetBrains IDEs&lt;/a&gt; JetBrains是一家公司，它旗下有诸多用于编写不同语言程序的IDE：IntelliJ IDEA，GoLand，PyCharm，WebStorm，RubyMine&amp;hellip;用来编写Java、Go、Python、JavaScript、Ruby等主流编程语言。这些IDE基本共用一套快捷键。有插件市场。我是JetBrains的忠实用户，因为我感觉JetBrains的IDE开发者们懂得开发者需要什么，产品中的小细节和功能体现着人性化的用心。我用JetBrains IDEs作为重量级编辑器，因为它们启动要好一会。我还选择了JetBrain IDEs快捷键“门派”，还在vscode上安装了&amp;quot;IntelliJ IDEA Keybindings&amp;quot;插件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/eclipseide/&#34;&gt;Eclipse IDE&lt;/a&gt; 开源的多编程语言IDE，有插件市场。因为它是开源的，有不少商业第三方定制化IDE都是基于它改造的。我在大学时一直用它编写Java和C++，真的很不错，直到我在实习时试着换了IntelliJ IDEA，之后再也没启动过它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/install&#34;&gt;Android Studio&lt;/a&gt; 谷歌出品，看名字就知道是编写安卓系统应用程序的IDE。我用过一点，只知道它因为时不时要连接谷歌的网站更新索引之类的什么东西，在国内想用它要配置好离线依赖。另外关于它有许多meme损它启动慢吃内存多，比如：我是安卓工程师，我每天早晨来公司先启动Android Studio，然后把咖啡壶放在机箱上煮咖啡，等我喝完整壶咖啡，我就可以开始工作了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/cn/xcode/ide/&#34;&gt;Xcode&lt;/a&gt; 这是苹果公司推出的编写苹果各产品上的应用（现在苹果产品有了共用芯片，只需编译出一种应用）的IDE，我没有用过，也没有用它的苹果开发者朋友，所以我不知道它怎么样。按照苹果一贯的风格，也许这个IDE很顺滑，搜了下也没找到太多说xcode本身不好用的抱怨。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;java-ide&#34;&gt;Java IDE&lt;/h4&gt;
&lt;p&gt;主流Java IDE有两款，&lt;a href=&#34;https://www.eclipse.org/eclipseide/&#34;&gt;Eclipse IDE&lt;/a&gt;和&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;，而且从2018年开始，&lt;a href=&#34;https://visualstudio.microsoft.com/&#34;&gt;Visual Studio&lt;/a&gt;也能够（通过连接vscode）支持Java了。从上文你可以看出，我是属于IDEA派的。&lt;/p&gt;
&lt;p&gt;在我看来，Eclipse比不过IntelliJ IDEA的关键不在功能上，它快捷键和插件市场都很完备，甚至因为是开源的，所以你可以把它DIY成符合自己习惯的专属IDE。但它败也败在开源上：没有漂亮又符合人机交互理念的界面（这需要专业的UI设计师参与，而开源项目成员中往往只有程序员）；默认配置较不合适（可定制化和开箱即用不冲突，但需要认真琢磨出厂默认配置）&amp;hellip;细节，它败在了细节上，“The devil is in the detail”。&lt;/p&gt;
&lt;p&gt;截至撰文我已经快三年没有用过Eclipse了，因此不了解它的近况，也许你可以给它一个机会，试用一下？还有宇宙第一IDE&amp;hellip;也可以试一下，我猜配置会很麻烦。&lt;/p&gt;
&lt;p&gt;另外，如果你选择使用IDEA，IDEA从2016年开始内置了一个学习快捷键的插件Learn，可以看&lt;a href=&#34;https://blog.jetbrains.com/idea/2016/12/ide-features-trainer/&#34;&gt;这篇官方介绍&lt;/a&gt;学习如何使用。&lt;/p&gt;
&lt;h3 id=&#34;浏览器搜索引擎与搜索思维&#34;&gt;浏览器、搜索引擎与搜索思维&lt;/h3&gt;
&lt;h4 id=&#34;浏览器&#34;&gt;浏览器&lt;/h4&gt;
&lt;p&gt;你在用火狐（FireFox）浏览器吗？建议从Mozilla官网（https://www.mozilla.org/zh-CN/firefox/new/ ）下载，而非北京谋智火狐信息技术有限公司的网站（http://www.firefox.com.cn/ ），这两个的区别可以看&lt;a href=&#34;https://zhuanlan.zhihu.com/p/138034888&#34;&gt;此文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你必然已会使用浏览器和搜索引擎，我在此补充几个浏览器的别样用法，也许可以帮助你更好的使用浏览器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给PDF阅读材料加书签。现代浏览器内置了PDF阅读器，配合创建用读书笔记作为标题的书签，你可以为本地硬盘上的某个PDF格式的电子书建立自己的书签目录，方便以后连同互联网书签一同查阅。（遗留问题：那个PDF文件不方便随意更换位置，因为浏览器书签的地址是文件系统的路径）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件市场。主流浏览器都有自己的插件市场，你可以用插件让上网体验更好。值得一提的是&lt;a href=&#34;https://www.tampermonkey.net/&#34;&gt;Tampermonkey&lt;/a&gt;插件，它是JavaScript脚本管理器，有自己的脚本市场。你可以把脚本理解为轻量的插件，毕竟在浏览器中就是Js脚本在操作页面。通过Tampermonkey，你可以向某个网页中添加额外的脚本来实现额外功能，而浏览器插件可以为浏览器本身添加额外功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;书签功能。主流浏览器支持同时打开一个书签目录下的所有书签，这样你可以用一个目录来代表一个工作环境，需要时一键开启所有Tab。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器快捷键。页面内查找，Tab左右切换显示，将光标置入搜索栏、切换搜索所使用的搜索引擎&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索栏。主流浏览器的搜索栏可以同时搜索书签和历史记录或使用搜索引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史记录。历史记录很重要，虽然它会泄露隐私，但我从不清理它。只要有历史记录，我就能搜到曾经浏览过的网页，节省了重新搜索的时间。（如果我想进行隐私上网，我会打开虚拟机中的Tor浏览器&amp;hellip;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;搜索引擎&#34;&gt;搜索引擎&lt;/h4&gt;
&lt;p&gt;为什么我不使用百度？有几个原因，仅就编程方面的搜索来说，使用百度会搜索到大量&lt;a href=&#34;https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%86%9C%E5%9C%BA/6651503&#34;&gt;内容农场&lt;/a&gt;网站，浪费时间却找不到有用的信息。&lt;/p&gt;
&lt;p&gt;我使用微软的Bing（ &lt;a href=&#34;https://cn.bing.com/&#34;&gt;https://cn.bing.com/&lt;/a&gt; 这是国内特供版网址，Bing的通常网址是 &lt;a href=&#34;https://www.bing.com/&#34;&gt;https://www.bing.com/&lt;/a&gt; ，猜测微软是根据GeoIP来判断该重定向到哪一个网址）。Bing搜索引擎&lt;a href=&#34;https://help.bing.microsoft.com/apex/index/18/en-US/10002&#34;&gt;有一些简单的高级搜索语法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外Bing有两个版面：国内版和国际版，你可以简单理解为国内版搜索结果中的中文结果优先，而国际版是其他语言的结果优先。你可以轻松切换两个版面来实现同时搜索一个关键字的中文和英文搜索结果。就编程方面的搜索来说，你不能肯定一个问题在&lt;a href=&#34;https://www.csdn.net/&#34;&gt;CSDN&lt;/a&gt;或&lt;a href=&#34;https://www.cnblogs.com/&#34;&gt;博客园&lt;/a&gt;上没人写过踩坑文章，也不能肯定&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;上必然有现成的回答。既然我们会中文和英文两种语言，就应该利用这种优势，同时使用两种语言搜索同一个问题（用中文关键字搜中文结果，vice versa），这样找到答案的概率会更高。&lt;/p&gt;
&lt;p&gt;用Bing搜索中文编程内容能逃避内容农场吗？不完全能。但是因为百度和Bing是两个公司单独计算网页排名，而刷排名的坏东西的目标一般是百度排名，因此Bing比百度的情况好一些。事实上不止中文搜索结果有内容农场这个坏现象，几乎所有语言的搜索结果都有，这需要搜索引擎公司们自己想办法反制。&lt;/p&gt;
&lt;h4 id=&#34;搜索思想&#34;&gt;搜索思想&lt;/h4&gt;
&lt;p&gt;记得把使用搜索引擎查找互联网内容的思想迁移到各个使用场景上。想找存在电脑上的文件？Windows系统可以按一下Win键打开搜索栏。想在网页内找关键字？使用浏览器的网页内搜索。想在文本编辑器里搜索本文件中的内容？文件内搜索。在IDE里搜索整个项目目录的内容？项目内搜索。&lt;/p&gt;
&lt;p&gt;小提示，本文中所有超链接标注的名词都可以作为搜索关键字，我只是每个名词搜了一个质量差不多的网页附上链接&amp;hellip;多花点时间应该能搜到质量更好的。&lt;/p&gt;
&lt;p&gt;搜索的最大目的始终不变：节约寻找答案的时间，因为寻找答案过程本身没有产出。&lt;/p&gt;
&lt;h2 id=&#34;编程语言&#34;&gt;编程语言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文本命令：&amp;ldquo;老王 吃 苹果&amp;rdquo; -&amp;gt; 执行动作：老王在客厅桌子上找到一个苹果，吃掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编程分为两个部分，人编写文本格式的&lt;a href=&#34;https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969&#34;&gt;源代码&lt;/a&gt;，编译器|解释器（下面统一使用编译器做指代，即使实际上是解释器）负责将源码编译成机器能看懂的&lt;a href=&#34;https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130&#34;&gt;指令&lt;/a&gt;。你可以为任何有结构的文本编写一个编译器，文本就是命令的内容，简单说明了要做什么事，编译器按着文本写出详细指令，计算机按着详细指令做事。举个例子：打仗，司令部传达过来的命令很简单，然后战场上的指挥官会以一两行命令为大纲来拟定详细的计划，士兵们可以按照详细计划行动。&lt;/p&gt;
&lt;p&gt;编译器和战场指挥官一样，帮你补足你在源码中没有提到的细节。注意看上文那句老王吃苹果，源码里没有提到老王在吃苹果前需要找到苹果，也没提到如何找苹果，但最后执行的动作中是存在找苹果的步骤的。这引出了目前主流的两类&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B/1475451&#34;&gt;编程范式&lt;/a&gt;：命令式（imperative）和声明式（declarative），按命令式编程设计的编程语言需要指明执行的细节，比较唠叨，而声明式只需要指定要做什么事，细节由编译器补足。事实上现代语言都混合了不同的编程范式，更加灵活。上面老王吃苹果的例子是偏向于声明式的。&lt;/p&gt;
&lt;p&gt;依我看，编译器越“聪明”，越懂得从寥寥数行源代码里猜测程序员的意图并产生出程序（如JavaScript，尽一切努力不报编译错误，即使会输出很离谱的结果）；反之，编译器越“木头脑袋”，越要求源代码“符合语法语义规则”，源代码越冗长（Java，说的就是你）。要么人写源码多费功夫，要么编译器编译源码多费功夫，仅此而已。编译这门手艺的术语叫&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4194&#34;&gt;编译原理&lt;/a&gt;。如果你有一个无限智能的编译器，就可以用自然语言即中文英文等，去指挥计算机做事。可惜，编译器是有极限的，语言越复杂，编译器所要做的工作越多，人就越难去编写这个编译器（编译器是个特殊的程序，终究还是要人来写），最后我们折衷得到了目前这些编程语言和对应的编译器。&lt;/p&gt;
&lt;p&gt;不同编程语言适合做不同的事，就像木匠工具箱里不同工具用来做不同的工作，没有高下之分，也没必要搞工具崇拜。因为有些编程语言底层设计特性是相互冲突的，而且现在已有这么多用得好好的不同语言编写的程序支撑着我们的世界，所以从设计理论和改造成本上看永远不会有一个全能的编程语言可以代替所有语言。顺带一提，每个编程语言的命令表达能力都是相等的，因为它们都是&lt;a href=&#34;https://www.zhihu.com/question/20115374&#34;&gt;图灵完备&lt;/a&gt;的，所以“一个语言可以代替另一个语言完成某个具体工作”这种论断是正确的，只是用不同语言间写源码完成相同的某功能花的力气可能差个几倍几十倍都有可能。&lt;/p&gt;
&lt;p&gt;编程语言本身，和编程语言下的框架、第三方库，只是工具而已。它们一般有个说明书教你如何使用，你可以在网上搜索（官方教程或注释生成的API文档）。有时你能在IDE里看它们源码的注释，注释也会详细地解释这个代码要做什么，就不用搜索了。事实上，在商业编程刚刚起步时，每个程序员手边都有一本关于所用编程语言提供的库API与语法的手册，他们要像查字典一样使用这本工具书，因为那个时候没有互联网，没有在线文档。不要过多花时间在了解工具的使用上（通读文档，试图记住所有库API，类似背诵字典），有需要就用关键字去搜索，越用越熟，就能记住了。&lt;/p&gt;
&lt;h3 id=&#34;学一门编程语言&#34;&gt;学一门编程语言&lt;/h3&gt;
&lt;p&gt;自然语言有听说读写四个技能要求，编程语言是书面语言，学习一门编程语言仅要求读写两个方面，另外额外多一个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习它的编程思想、语法和关键字，即读法写法。&lt;/li&gt;
&lt;li&gt;知道语言的原生库提供了哪些API（帮你省事的现成的功能），知道如何使用或去哪查如何使用这些API（小提示：库代码的注释，网上的在线文档，或教程）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐一个入门图书系列——&lt;a href=&#34;https://baike.baidu.com/item/Head%20First/13972734&#34;&gt;Head First&lt;/a&gt;。由 O&amp;rsquo;Relly 出版社发行的一系列教育书籍，它强调以特殊的方式排版，由大量的图片和有趣的内容组合构成，而达到非疲劳的沉浸式学习效果。我读过它的&lt;a href=&#34;https://book.douban.com/subject/2243615/&#34;&gt;设计模式&lt;/a&gt;书，很有趣。&lt;/p&gt;
&lt;p&gt;还有几个在线中文教程网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/archives.html&#34;&gt;阮一峰的网络日志&lt;/a&gt;，&lt;a href=&#34;https://www.liaoxuefeng.com/&#34;&gt;廖雪峰的官方网站&lt;/a&gt; 这两位为中文互联网提供了大量易懂的入门级IT方面的教程，如果你想通过中文教程了解一个新东西，可以先在搜索栏前面输上&amp;quot;阮一峰&amp;quot; &amp;ldquo;廖雪峰&amp;rdquo;+新东西关键词，看他俩有没有写过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/&#34;&gt;菜鸟教程&lt;/a&gt; 特别的，如果你想通过中文教程学习某种编程语言|工具，并快速写出能跑的程序|运行环境，建议阅读这个网站上的教程，这上面基本涵盖了所有常用的编程语言和工具的快速入门教程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;java编程语言&#34;&gt;Java编程语言&lt;/h4&gt;
&lt;p&gt;Java中规中矩，有一套严格的语法规则。通过学习复杂的语法规则，新手可以了解编程语言的一些共性，我还是比较推荐新手通过Java了解面向对象编程的。最近几年Java想要变年轻，迭代变快了（半年一个新版本），也&lt;a href=&#34;https://dzone.com/articles/a-guide-to-java-versions-and-features&#34;&gt;引入了不少其他语言中好用的特性&lt;/a&gt;。你可以把它理解为保守谨慎的，只会在一个特性被其他语言实践验证后才考虑引入。但是&lt;a href=&#34;https://www.zhihu.com/question/360985479&#34;&gt;业内不少公司都停留在了Java8&lt;/a&gt;，主要是公司们不想还遗产代码的债。&lt;/p&gt;
&lt;p&gt;如果你工作项目使用的是Java8，推荐你了解一下Java8引入的&lt;a href=&#34;https://www.w3cschool.cn/java/java-stream-api.html&#34;&gt;Stream API&lt;/a&gt;。如果你需要Java语言的工具书，建议使用&lt;a href=&#34;https://book.douban.com/subject/26880667/&#34;&gt;Java核心技术&lt;/a&gt;，上下两卷两本大厚书，你也可以通过通读它来学习Java。&lt;/p&gt;
&lt;h3 id=&#34;第三方库&#34;&gt;第三方库&lt;/h3&gt;
&lt;p&gt;在现代，没有任何编程项目是从零开始的。每个编程语言都有自己的第三方库仓库（repository），比如Python的&lt;a href=&#34;https://pypi.org/&#34;&gt;pypi&lt;/a&gt;，Java的&lt;a href=&#34;https://mvnrepository.com&#34;&gt;Maven Repository&lt;/a&gt;等。有些公司为了保证项目所使用的第三方库的稳定，会建立并维护内部的仓库。库（library）或者叫包（package），就是别人写好的功能。你可以把库从在线的仓库下载到本地，就不需要自己编写了对应的功能了。这算盗窃吗？事实上，每个库（每个开源软件项目，库属于一种特殊的专门给程序员用的项目）都有&lt;a href=&#34;https://zhuanlan.zhihu.com/p/322438947&#34;&gt;许可证&lt;/a&gt;，许可证是一个声明，它规定了该库可在什么情况下使用，比如有些许可证就禁止商业使用。&lt;/p&gt;
&lt;h4 id=&#34;框架&#34;&gt;框架&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/1471931&#34;&gt;框架（framework）&lt;/a&gt;是一种特殊的项目，顾名思义，它提供了编写某类程序的大致框架。当你自己动手写练手的项目，你会发现写项目最难的在于如何组织各个组件间的关系，我该把这个文件放在哪个目录？我该把这段逻辑放在哪个组件？谁调用谁？选择一款框架，了解它关于组织组件的建议，你便只需专注你的功能。&lt;/p&gt;
&lt;h4 id=&#34;架构&#34;&gt;架构&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/86052051&#34;&gt;架构（architecture）与框架的联系与区别&lt;/a&gt;，&lt;a href=&#34;https://zhuanlan.zhihu.com/p/3455520&#34;&gt;微服务架构&lt;/a&gt;和单体架构。如果想了解更多，请自行搜索。&lt;/p&gt;
&lt;h5 id=&#34;java下的spring框架&#34;&gt;Java下的Spring框架&lt;/h5&gt;
&lt;p&gt;“&lt;a href=&#34;https://baike.baidu.com/item/spring/85061&#34;&gt;Spring框架&lt;/a&gt;（&lt;a href=&#34;https://spring.io/&#34;&gt;官方网站&lt;/a&gt;）是最受欢迎的企业级 Java 应用程序开发框架。” 听听，它可没吹牛。目前Spring已经发展成了完整的生态（我不喜欢这个词，它代表封闭，但Spring是很开放的），绝大部分新的Java应用项目选择Spring生态作为基础框架是相当自然的事。&lt;/p&gt;
&lt;p&gt;使用Spring对程序员编程有很多实际的好处，不仅是企业级的那些什么可伸缩之类的高大上特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring有完备的基础功能，可以让你只写几行代码就配置好一个复杂的功能，如果不用Spring，也许需要一整天去下载配置相同功能的库或其他外部系统。&lt;/li&gt;
&lt;li&gt;Spring开箱即用，简化了项目配置的过程（配置真是一个消磨精力的事）。&lt;/li&gt;
&lt;li&gt;Spring统一了Java业界的标准，你会发现各种项目和库都支持对Spring的兼容，不需要你来单独做兼容了。&lt;/li&gt;
&lt;li&gt;Spring对原本代码的侵入相当少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring增加了学习成本。我已经见过好几个人，当他们听到除了学Java还要学Spring时，眉头突然皱起来了&amp;hellip;但是&amp;hellip;总要多学一些工作中会用到的常用库，只是Spring稍微有点大，稍微。而且你这样想，学了Spring，就能享受上面提到的大量好处，很值。最低限度的学习，只需要了解Spring配置文件和Spring MVC的注解就行了。&lt;/p&gt;
&lt;h4 id=&#34;工具库&#34;&gt;工具库&lt;/h4&gt;
&lt;p&gt;按照我的分类，工具库通过API提供对象处理功能，你可以像使用语言本身的原生库API一样使用这些工具库。举个例子，因为Web应用的普及，每个语言都会遇到对&lt;a href=&#34;https://baike.baidu.com/item/JSON/2462549&#34;&gt;Json格式&lt;/a&gt;文本的解析、映射等操作的功能需求。比如Java语言没有在其原生库中提供这些Json格式数据的操作，于是Java社区中应需求出现了好几个Json处理工具库。&lt;/p&gt;
&lt;h5 id=&#34;java常用的工具库&#34;&gt;Java常用的工具库&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Json处理：&lt;a href=&#34;https://github.com/FasterXML/jackson&#34;&gt;Jackson&lt;/a&gt;，&lt;a href=&#34;https://github.com/alibaba/fastjson&#34;&gt;FastJson&lt;/a&gt;，&lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理（狭义上的工具类）：&lt;a href=&#34;https://github.com/dromara/hutool&#34;&gt;HuTool&lt;/a&gt;，&lt;a href=&#34;https://mvnrepository.com/artifact/org.apache.commons/commons-lang3&#34;&gt;apache commons-lang3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志记录：&lt;a href=&#34;https://www.tutorialspoint.com/slf4j/slf4j_vs_log4j.htm&#34;&gt;slf4j&lt;/a&gt;（它是接口，不能独立工作），&lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34;&gt;log4j&lt;/a&gt;（它是一种实现，可以独立工作）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一类有其中之一就满足需要了（slf4j除外）。如果你中途加入一个项目组，你需要辨别该项目使用了哪些工具库，并继续使用，不要添加相同功能的其他工具库。&lt;/p&gt;
&lt;h4 id=&#34;依赖管理工具&#34;&gt;依赖管理工具&lt;/h4&gt;
&lt;p&gt;当你使用某个第三方库或框架，你便对它产生了“依赖”，有时我们把它名词化，项目依赖的第三方库就起个别名叫“依赖”（dependency）。当然你使用的第三方库本身也可能有依赖，于是会形成一个以你的项目为根的依赖树。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1122163&#34;&gt;依赖管理工具&lt;/a&gt; 源自人们想要自动化（程序员爱自动化）依赖管理的需求。一般依赖管理工具和第三方库仓库是相辅相成的，本地的依赖管理工具会将第三方库仓库的网址作为远程仓库，从上面下载第三方库文件。部分依赖管理工具还拥有工程构建的功能，你简单理解为编译、打包与部署项目。&lt;/p&gt;
&lt;h5 id=&#34;java依赖管理工具&#34;&gt;Java依赖管理工具&lt;/h5&gt;
&lt;p&gt;主流的Java依赖管理工具有两个：&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Apache Maven&lt;/a&gt;和&lt;a href=&#34;https://gradle.org&#34;&gt;Gradle&lt;/a&gt;。区别？看&lt;a href=&#34;https://cloud.tencent.com/developer/article/1122163&#34;&gt;这篇中文文章&lt;/a&gt;或者&lt;a href=&#34;https://gradle.org/maven-vs-gradle/&#34;&gt;这篇Gradle自己写的对比&lt;/a&gt;或者&lt;a href=&#34;https://www.zhihu.com/question/276078446&#34;&gt;这篇知乎回答&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;往项目里添加依赖&#34;&gt;往项目里添加依赖&lt;/h4&gt;
&lt;p&gt;以Java语言项目为例，单个现代项目往往被分成多个包（package，对，就是上面提到的第三方库的一种别名），包之间的有一定的隔离性，依赖也是各个包独立管理的。&lt;/p&gt;
&lt;p&gt;在编程工作中，你会碰到想使用某个第三方库（或者同一个项目的另一个包）的功能，而目前项目里还没有这个依赖的情况。此时你应该斟酌一下你想在哪个包的代码中使用第三方库，对应要把新的依赖放在哪个包的依赖配置文件里。这个问题没有固定答案，原则就是尽可能少增加复杂度。如果你拿不准，咨询一下有经验的程序员的意见。&lt;/p&gt;
&lt;p&gt;有一个编程原则叫“针对抽象而非具体编程”，我们应该尽可能减少程序中不必要的依赖，因为它会妨碍未来的变更的灵活性。反面例子：依赖是一个树型结构，有些库没有好好遵守这个原则，依赖于某个具体的库，导致使用该库的其他库也&lt;a href=&#34;https://zhuanlan.zhihu.com/p/34427614&#34;&gt;传递依赖&lt;/a&gt;了那个具体库。结果越来越少的库为了避免麻烦选择使用这些库，最终维护者因无人使用放弃了维护，项目死亡了。不可在未来灵活替换的依赖对项目来说是致命的病毒。&lt;/p&gt;
&lt;h2 id=&#34;单元测试与debug&#34;&gt;单元测试与Debug&lt;/h2&gt;
&lt;p&gt;关于单元测试的定义与用途，读&lt;a href=&#34;https://baike.baidu.com/item/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/1917084&#34;&gt;百度百科的介绍&lt;/a&gt;。关于单元测试思想方面的内容，可以读&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/&#34;&gt;这篇文章&lt;/a&gt;。简单说，单元测试是程序员为了检测自己写的功能是否合乎预期而编写的额外的代码。把这种测试的行为用代码持久化下来有不少好处，比如可以重复运行。单元测试不是必须的，写它可能要费不小的事，所以有时要斟酌是否值得写单元测试，主要看写测试的时间能否弥补未来一遍遍手动测试的时间。&lt;/p&gt;
&lt;p&gt;一般使用现成的单元测试库来编写单元测试用例。单元测试库属于工具库，也是百花齐放多种多样。现代的框架，比如&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html&#34;&gt;Java的Spring&lt;/a&gt;，&lt;a href=&#34;https://projectreactor.io/docs/core/release/reference/index.html#_testing_a_scenario_with_stepverifier&#34;&gt;Java的Project Reactor&lt;/a&gt;（我相信其他语言的编程框架也有，奈何我没用过无法举例）都会比较贴心地随框架附带专用的测试工具包，帮助你更顺利地使用框架。如果一些热门的库本身没有提供测试工具包，也会有热心程序员提供第三方的辅助测试包&amp;hellip;社区就是这个样子，有需求就往往有对应的现成解决方案。&lt;/p&gt;
&lt;p&gt;单元测试库的API是额外的学习成本，所以部分程序员不喜欢写单元测试，或者写的单元测试无法自动化运行，需要人盯着看日志输出结果。还有一种不写单元测试的情况是，不知道怎么写、或者没有单元测试库的依赖（内网开发时会遇到）或项目使用特殊的商业框架，因此有心无力写不出单元测试。对于前者，斟酌一下学习并写出单元测试的成本；对后两者&amp;hellip;默哀，放弃单元测试吧，争取用其他工具把集成测试的测试用例自动化。&lt;/p&gt;
&lt;p&gt;Debug，或者叫调试，是在程序尚未被打包部署前，把程序在本地的环境里通过调试器等工具的帮助下运行起来，细致观察程序内部的每一步行为，以确定程序行为符合预期。现代IDE中一般会集成调试器和Debug功能，因此通常的实践是在IDE中，以debug模式运行单元测试用例或整个程序。具体怎么用要查IDE的官网文档或自己动手试用，别忘了学习对应的快捷键。&lt;/p&gt;
&lt;h3 id=&#34;java的单元测试包和idea的debug功能&#34;&gt;Java的单元测试包和IDEA的Debug功能&lt;/h3&gt;
&lt;p&gt;我会介绍我现在用的测试库，你也可以选择自己整理一套喜欢的测试库。自从我学会借助测试库写单元测试后只用过两种语言：Java和JavaScript。写JavaScript单元测试我是用FaceBook开源的&lt;a href=&#34;https://jestjs.io/&#34;&gt;Jest&lt;/a&gt;，本身功能就挺全的，有时会安装基于它的插件包来扩展功能。&lt;/p&gt;
&lt;p&gt;Java就复杂点了，我现在有一套会用的Java测试库，搭配使用它们可以完成基于Spring框架的应用的各种单元测试工作。关键是它们可以用一个&lt;a href=&#34;https://stackoverflow.com/questions/61117933/whats-the-difference-between-spring-boot-test-vs-spring-boot-starter-test&#34;&gt;spring-boot-starter-test&lt;/a&gt;依赖全部导进来，省事（而且公司的内部仓库里大概率会有）。主要有这么几个包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://junit.org/junit5/&#34;&gt;Junit&lt;/a&gt; 它是一个测试框架，很多其他测试包会基于它编写，角色类似上面的Jest。公司项目中有些用Junit4，但它比较老（10年以上），现在出了Junit5，注意两者间用法的&lt;a href=&#34;https://www.baeldung.com/junit-5-migration&#34;&gt;不同&lt;/a&gt;(&lt;a href=&#34;https://www.baeldung.com/junit-5-runwith&#34;&gt;@Runwith兼容&lt;/a&gt;，&lt;a href=&#34;https://www.baeldung.com/mockito-junit-5-extension&#34;&gt;Mockito in Junit5&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html&#34;&gt;Spring提供的测试组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/features.html&#34;&gt;Spring Boot提供的测试组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; Mock，嘲弄，在测试中我们说mock被测试组件的依赖，是指把调用被试和被被试调用的组件，全部用测试库提供的API换成假的空壳子。这样我们可以控制输入被试的数据，和被试调用其他组件时其他组件的反应。举个例子，我们可以mock一个数据库API，然后写明如果被试调用该API，抛出异常，测试被试在数据库异常时的异常处理逻辑。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hamcrest.org/JavaHamcrest/&#34;&gt;Hamcrest&lt;/a&gt; 小巧的断言（assertion）框架，作为Junit断言API的替换品，提供可读性更高的API。（Hamcrest仅是判断一个对象的值怎样怎样，如果想判断其他的比如抛出异常，用Junit的API更方便。）断言是单元测试自动化的核心：自动判断运行结果是否符合预先编写好的结果。例子：assertThat(result,is(&amp;ldquo;expected-output&amp;rdquo;))，期望result这个变量是个字符串格式，值是&amp;quot;expected-output&amp;quot;。如果没通过判断，断言API会抛出异常，让这个测试用例失败，并打印出失败的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写Java的测试用例时要留意一下IDEA Auto Import的哪个库的注解|API，不能无脑回车导入。因为都是用在测试场景，不少库有同名或名称相似注解|API（例：org.junit.Test和org.junit.jupiter.api.Test）。注解|API间需要搭配使用，混用可能使某个注解|API失效导致测试运行失败，报错也总是云里雾里，无法快速发现是注解用错的原因。这个需要多读点教程和文档弄明白常用的注解|API间的关系，又是一笔额外的学习成本。&lt;/p&gt;
&lt;p&gt;顺带一提，上面的Hamcrest基于的测试理念是“基于用例的测试”，即提前写好预测的结果，一个用例只能预测一种行为的一个输入和对应的结果。现在业内出了一个还没流行起来的新测试理念——“基于特性的测试”，简单说就是测试框架根据给定的范围，自动生成测试数据，一个测试用例可以用大量的随机数据测试被测组件的抽象行为。但是这种测试用例特别难写，主要是难以抽象总结被测组件的行为。感兴趣的话，可以阅读&lt;a href=&#34;https://boholder.github.io/blogs/unit-test-methods/&#34;&gt;这篇文章中的后两节&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;IDEA的debug功能挺强大的，尤其是debug中途修改变量值，可以作为写不出单元测试时的替代操作。它还允许现改代码并编译替换运行中的类文件，允许drop堆栈来实现“反悔”回到上一步调用处，使得程序可以在一段逻辑中反复运行，测试各种情况。可以用上文提到的Learn插件学习IDEA的debug功能，或者读&lt;a href=&#34;https://www.jetbrains.com/help/idea/debugging-code.html&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编程思想&#34;&gt;编程思想&lt;/h2&gt;
&lt;h3 id=&#34;编程原则&#34;&gt;编程原则&lt;/h3&gt;
&lt;p&gt;编程原则（principle）是一些抽象化的格言，用来规范提醒程序员的编程行为实践。比如提到面向对象编程实践就是&lt;a href=&#34;https://www.baeldung.com/solid-principles&#34;&gt;SOLID五大原则&lt;/a&gt;。还有什么ETC（easy to change）原则，DRY（do not repeat yourself）原则，FEP（fail early，不够仨单词的原则会把原则的P也算进缩写）等，&lt;a href=&#34;https://coolshell.cn/articles/4535.html&#34;&gt;这里有一篇&lt;/a&gt;解释了部分常用编程原则的文章。这些原则不是术语，算是程序员间的共识（或者叫黑话），而且可能同一原则有不同解释方式和缩写变体。&lt;/p&gt;
&lt;p&gt;编程原则试图从抽象层面对抗未来必然会出现的代码变更，尽可能让代码变更变得容易，少修改已经写好的代码。我借用一下忘了哪本书中提到的观点：把软件开发学科与建筑学科相类比的观点（软件架构architecture一词是从建筑学借来的，软件设计模式也是基于建筑学典著&lt;a href=&#34;https://book.douban.com/subject/1157145/&#34;&gt;建筑模式语言&lt;/a&gt;启发出现）已经过时，因为开发流程不再是严格遵守计划表的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/81383161&#34;&gt;瀑布式开发&lt;/a&gt;。软件开发更像园艺，你把种子种在花园里，不能控制植物的自然生长（未来的需求变更），只能通过园艺技术（&lt;a href=&#34;https://book.douban.com/subject/4262627/&#34;&gt;代码重构&lt;/a&gt;）修剪、梳理花园。&lt;/p&gt;
&lt;p&gt;编程原则无关编程语言，甚至在编程之外的工作和生活中都能借鉴，算是一种行为哲学。希望你能聆听这些编程原则，写出易于变更的代码。&lt;/p&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式&lt;/h3&gt;
&lt;p&gt;请看这篇文章了解设计模式：&lt;a href=&#34;https://draveness.me/holy-grail-design-pattern/#fnref:5&#34;&gt;圣杯与银弹 · 没用的设计模式&lt;/a&gt;。以我的经验而言，设计模式最大的用途是减少沟通成本，冲这个用途值得花时间学一些常用的设计模式的概念。设计模式在不同编程语言上的实现会因为编程语言的特性而不同，所以你也会看到诸如“Xxx语言的Yyy设计模式”的标题。&lt;/p&gt;
&lt;h2 id=&#34;完成编程工作所需的外围技能&#34;&gt;完成编程工作所需的外围技能&lt;/h2&gt;
&lt;p&gt;你可以在网络上搜索什么&amp;quot;Xxx职业技能树|知识图谱|技术栈&amp;quot;，有许多人试图总结出这么一个东西，但是要我说，看看&lt;a href=&#34;https://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html&#34;&gt;这位有10年间有多岗位经验的reddit老哥&lt;/a&gt;是怎么描述这个行业的技术栈的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;英语&#34;&gt;英语&lt;/h3&gt;
&lt;p&gt;四级，英语四级水平的英语读写绝对够用了，只要日常工作没有听说英语的需求。除开每次写方法名都要愣一下单词怎么拼（记得在IDE上安装拼写纠正插件，别闹了笑话）以外，编程工作不是太要求英语水平。编程相关的问答、教程、官网、文档&amp;hellip;都不会用很生僻的单词，大家都倾向于用最简单的单词表达意图。唯二的例外是博客和论文。博客是口语化的文章，我碰到过不少次作者想举个例子或者玩笑幽默一下，但把我卡住用字典查里面的生词，继续读下去明白了只是一个例子|玩笑的无奈情况。论文&amp;hellip;论文的生词主要是术语，数学术语、机器学习术语、数据分析术语等。&lt;/p&gt;
&lt;p&gt;有些中文程序员不喜欢英语材料，可能是因为不习惯或者读得慢浪费时间。其实我读得也不快，有时候也因为怕浪费时间选择找中文材料去读。但是如果你去读，你会发现英语材料是可以读懂的，读懂就足够了，多读一些就能克服不习惯的心理障碍，也能慢慢提高阅读速度。&lt;/p&gt;
&lt;p&gt;你还可以借助科技的辅助：&lt;a href=&#34;https://www.deepl.com/en/translator&#34;&gt;DeepL Translate&lt;/a&gt;等翻译网站、浏览器翻译插件和IDE翻译插件等可以帮你弥补英语能力的不足。&lt;/p&gt;
&lt;h3 id=&#34;版本控制工具&#34;&gt;版本控制工具&lt;/h3&gt;
&lt;p&gt;源代码是文本文件，对吧。&lt;a href=&#34;https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/3311252&#34;&gt;版本控制工具&lt;/a&gt; 是用来管理文本文件的内容变更的功能，类似Microsoft Office Word里的Review（审计？）功能，就是写论文时导师用来帮你打批注、改论文的那个。我见过有写手用它管理txt格式的小说文件，写代码真的和写作很像啊。版本控制工具不仅会记录哪个人对哪个文件做了什么改动，还允许你独立地管理这些改动，确保多人协作的同时维护源代码文件不会被搞成乱糟糟的“源码-v02的副本(1)(2)(1)”这副模样。&lt;/p&gt;
&lt;p&gt;有两款主流的版本控制工具工具：&lt;a href=&#34;https://www.runoob.com/git/git-tutorial.html&#34;&gt;Git&lt;/a&gt;和&lt;a href=&#34;https://www.runoob.com/svn/svn-tutorial.html&#34;&gt;SVN&lt;/a&gt;（曾经还有&lt;a href=&#34;https://baike.baidu.com/item/CVS/405463&#34;&gt;CVS&lt;/a&gt;，SVN成功取代了CVS）。两者区别？打开Git的链接阅读介绍。另外我想分享一个写得不错的&lt;a href=&#34;https://www.atlassian.com/git/tutorials/what-is-version-control&#34;&gt;英文的Git教程系列&lt;/a&gt;，它不仅讲命令，还总结命令间的区别，还稍微讲了一些git的实现原理，让你对git命令的执行过程有更深的认识。&lt;/p&gt;
&lt;h3 id=&#34;linux命令行操作&#34;&gt;Linux命令行操作&lt;/h3&gt;
&lt;p&gt;现在有三种主流的个人计算机操作系统，微软的Windows，苹果的macOS，和开源的（各种发行版的）Linux。服务器操作系统就很多了，五花八门的商业产品，比如Windows的&lt;a href=&#34;https://www.microsoft.com/en-us/windows-server/&#34;&gt;Windows Server&lt;/a&gt;，还有各种Linux。Linux系列操作系统因为其内存占用小、运行稳定、开源（即，免费，服务器版本的操作系统超贵）等特点，成为了主流的应用服务器的宿主操作系统。就是说，我们编写的应用在编译打包后，最终要部署到运行着Linux操作系统的服务器上。&lt;/p&gt;
&lt;p&gt;如果你在Windows或MacOS操作系统上编程，一般你会使用Linux服务器做这两种工作：&lt;/p&gt;
&lt;p&gt;部署（也称发版，发布新版本）程序。有时会有专门的运维职业的人员负责这方面工作，或者有自动化构建流水线，有时现实没那么美好，要程序员自己干。部署的操作流程视编程语言而定，在中途加入的项目组中，一般会有其他程序员写好的部署脚本（&lt;a href=&#34;https://www.runoob.com/linux/linux-shell.html&#34;&gt;Shell脚本&lt;/a&gt;）来简化部署操作。&lt;/p&gt;
&lt;p&gt;查看日志文件。当程序打包部署后，我们就不能以debug的形式查看程序内部的运行情况了。因此我们会在程序中各处插入打印日志的语句，日志会被打印到一些文本文件中，我们通过查看日志文件来判断程序是否正常运行。看日志文件基本是程序员的职责，比如当自己负责的功能出问题时&amp;hellip;就会有电话联系你“看一下某请求的情况”，你就要去对应的服务器上查看日志，来判断到底是你的功能出bug了，还是其他系统或功能形成的异常数据致使你的功能运行不正常（这种情况也要增加异常处理补丁去防止再次发生，编程原则：永远不要信任外部系统）。如果只是看日志文件的话，最低限度需学习的命令有&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/cd.1p.html&#34;&gt;切换目录的cd&lt;/a&gt;，&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/ls.1p.html&#34;&gt;查看目录内容的ls&lt;/a&gt;，&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/grep.1p.html&#34;&gt;使用正则过滤查看日志文件的grep&lt;/a&gt;。当然你还需要咨询同组其他人、或阅读程序中的日志输出配置文件来了解日志文件的位置。&lt;/p&gt;
&lt;p&gt;如果你不熟悉命令行界面，看&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal&#34;&gt;这篇英文介绍&lt;/a&gt;或者&lt;a href=&#34;https://www.runoob.com/linux/linux-tutorial.html&#34;&gt;菜鸟教程的中文Linux教程&lt;/a&gt;。另外，在命令行中输入“man”（代表manual）+其他命令，可以打开命令的说明书；或输入命令+&lt;code&gt;-h&lt;/code&gt;或&lt;code&gt;--help&lt;/code&gt;参数，打印命令的简单说明。你也可以在网上搜索在Linux中应该使用哪个命令做你想做的事。&lt;/p&gt;
&lt;p&gt;特别的，从我们自己的电脑连接到服务器来使用服务器的命令行界面，需要使用&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&#34;&gt;SSH&lt;/a&gt;这么一种命令行工具（同时它也是工具原理的同名协议）。一般不需要直接使用它，有多种图形界面软件供你选择，这里不再列举，请自行搜索。关于服务器的IP、端口、用户名与密码等连接所需的信息，你需要咨询同组的其他人。&lt;/p&gt;
&lt;h3 id=&#34;对各种外部系统的配置&#34;&gt;对各种外部系统的配置&lt;/h3&gt;
&lt;p&gt;提问！上文中出现了几次“配置”？（提示：使用搜索快捷键）开个玩笑，其实我是想说，编程离不开对外部系统的配置。编程项目不是从零开始的，对吧，我们要使用许多已有的系统来省事，比如&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728&#34;&gt;数据库&lt;/a&gt;、&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240&#34;&gt;中间件&lt;/a&gt;、框架、日志系统（打日志是一件很复杂的事）&amp;hellip;这些系统都需要我们通过配置来调整它们的行为，以适应我们项目的需要。&lt;/p&gt;
&lt;p&gt;一般我们说配置一个系统，指的是编写配置文件，配置文件是一种遵守某种&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849&#34;&gt;标记语言&lt;/a&gt;（xml,json,toml,yaml&amp;hellip;）的文本文件，它就是系统的设置项，和手机设置一样。系统一般在启动时读取配置文件，基于此调整行为。注意，系统一般只会在启动时读取配置文件，所以如果系统启动后你想修改配置文件并让它生效，往往需要重启系统。当然这有很多例外&amp;hellip;比如你可以多开一个&lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835&#34;&gt;守护进程&lt;/a&gt;专门监控配置文件的变化，若出现变化，就重启系统让系统读新的配置文件。另外在我看来，配置文件的内容是只能被该系统识别并解析的“语言”（&lt;a href=&#34;https://www.infoworld.com/article/2077865/core-java-creating-dsls-in-java-part-1-what-is-a-domain-specific-language.html&#34;&gt;领域特定语言&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为了写出配置文件，要去读说明书。可以读官方的配置说明文档（往往详细又冗长），也可以省事读简化版的第三方文档，比如中文翻译、博客记录等。这个工作最麻烦的步骤就是要硬着头皮读大篇幅的文档。读哪个都行，能明白怎么写完成工作就好，我推荐配合网页内搜索读官方文档，毕竟最详细。注意配置与软件一样都是有版本的，要读自己项目所用的版本的对应说明书，或者有些文档只有一版，但会在每个配置项下标注从哪个版本开始生效。&lt;/p&gt;
&lt;h2 id=&#34;总结太多了先学哪个&#34;&gt;总结：太多了，先学哪个？&lt;/h2&gt;
&lt;p&gt;不好意思，我没收住字数，写太多了。咚地一下全摆在面前是挺吓人的，而且说实话本文仍未涵盖我所认定的所有“必备技能”，如正则表达式等。&lt;/p&gt;
&lt;p&gt;总之先学编程语言吧，然后是熟悉框架和几个常用的库的用法，此时就能完成工作了。然后如果你对这个职业仍有兴趣，可以学习单元测试、debug和编程思想（看书看博客），还有外围的技能，这些可以慢慢来。额外的知识会提高你的专业性，让你能够有底气地承认自己被付钱来编写程序，你对自己写出的程序有信心且对它负责。&lt;/p&gt;
&lt;p&gt;如果你对这个职业不感兴趣，学到足够工作使用的知识就可以停止了，你也可能会发现其他兴趣和职业的知识会迁移性地对编程工作产生意想不到的帮助，很多抽象的原则和知识是共通的。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;
&lt;h3 id=&#34;有用的网站&#34;&gt;有用的网站&lt;/h3&gt;
&lt;p&gt;下面是通用的几个网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt; 它是&lt;a href=&#34;https://stackexchange.com/&#34;&gt;StackExchange&lt;/a&gt; 问答网站中分离出的编程问答板块。如果想解决程序报错、想知道某个API怎么用、不知道如何完成一个功能、想了解一种编程实践的理念&amp;hellip;一切关于编程的东西，基本上你不是第一个碰到这个问题的人，stackoverflow上大概率会有对应的提问和专业亲切的回答。为了不限制搜索引擎的能力，不建议使用网站内部的搜索功能，而是直接在搜索引擎的搜索栏上开头写&amp;quot;stackoverflow&amp;quot; + 你的问题描述（用英文）。关于这个网站有不少meme赞美它的便利，比如：在没有stackoverflow之前程序员怎么可能顺利写完程序呢。PS: stackoverflow需要从&lt;code&gt;ajax.googleapis.com&lt;/code&gt;域名加载Js脚本，因为GFW封禁了该域名，在国内网络打开该网站的速度会慢得不可忍受。如果你没有网络代理，你可以使用浏览器的广告屏蔽插件规则将该脚本的加载屏蔽，进而恢复正常的网页打开速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web&#34;&gt;MDN(Mozilla Developer Network) Web docs&lt;/a&gt; 这是实质上的互联网唯一的Web前端开发参考文档，附带翔实有趣的教程（多语言翻译，有中文）。你可以不走出这个网站而学习完前端开发所需要的大部分基础知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt; 结合&lt;a href=&#34;https://boholder.github.io/blogs/learn-from-source-code&#34;&gt;这篇文章&lt;/a&gt;从Github里找点感兴趣的项目看一下，感兴趣优先，真的什么千奇百怪的项目都能搜出来。另外有一个小诀窍，如果你拿不准某个库的某个API怎么用，而注释、文档和stackoverflow又没能让你满意，你可以在github中搜索使用了该api的代码片段，学习使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://old.reddit.com/r/ExperiencedDevs/&#34;&gt;Reddit-ExperiencedDevs&lt;/a&gt; 这版块只允许3年以上从业经验的开发者发帖，版块里聊的都是职业规划、公司中发生的事等等，很少涉及技术。看这里面的帖子就像一群大佬围着聊闲天时你凑进去听，只是听就能学到不少东西。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是Java方面的网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/&#34;&gt;Baeldung&lt;/a&gt; 这网站上有内容充实的关于Java与Java生态（如Spring框架）的教程，质量比那种内容农场网站高出一截。不需要刻意在网站中搜索，当你搜索Java相关教程时，这个网站往往排在搜索结果前面&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blogs.oracle.com/javamagazine/&#34;&gt;Oracle Java Manazine&lt;/a&gt; 因为Java不太受同行待见（这是真的吗？），所以不怎么能看到关于Java语言的公开讨论。虽然（仅在中国？）工作上用Java的程序员很多，但讨论Java语言俨然是个小圈子。这时我们要借助学术界中小圈子交流的方法：研讨会和期刊。研讨会&amp;hellip;至少我不够格参与，因此我选择邮件订阅Oracle公司组织编撰的免费杂志，进而一窥Java行业的动向，学点新东西。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;之前没接触过it行业的基础知识&#34;&gt;之前没接触过IT行业的基础知识？&lt;/h3&gt;
&lt;p&gt;基础知识体系无法突击补习，这是慢活，更别提还会遗忘。目前大学的软件工程|计算机科学专业会开设大约10门左右的IT专业课程，也就是说你和科班出身的IT专业本科毕业生的差距在10本左右的教科书，以及几个练手的小项目。&lt;/p&gt;
&lt;p&gt;不补基础知识体系的前提下完成公司要求的编程工作是可以的，现在的编程语言和工具已经把底层实现都封装起来了。但它会在工作上限制你的思考：不知道原理，就没法想象你的程序如何运行，也就没法深入地思考一个解决方案的细节，心里很不舒服。或者&amp;hellip;小心&lt;a href=&#34;https://droidyue.com/blog/2019/03/24/cargo-cults-programming/&#34;&gt;货物崇拜编程&lt;/a&gt;，它是指新手程序员常犯的那种“网上找解决方案复制粘贴下来”的不良编程实践。越不熟悉基础知识，越可能在工作中出现货物崇拜编程现象，这可能会在程序里埋下炸弹，最终伤害你或身边的程序员。&lt;/p&gt;
&lt;p&gt;这里有一些好的起步课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1HJ411q7bm&#34;&gt;【中英字幕|2019 CS50|哈佛大学编程入门】 CS50 Harvard University2019&lt;/a&gt; 用非术语讲解IT行业里的一些知识体系。真正的0基础开始学。可惜课不太全。&lt;a href=&#34;https://www.bilibili.com/video/BV1dx411i7dW&#34;&gt;【哈佛大学-编程入门】 CS50 Harvard University（2016）11集（全）&lt;/a&gt; 这个课全了，可惜没中文字幕。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://awe.berkeley.edu/2020/04/23/guide-to-declaring-cs/&#34;&gt;A Guide to Declaring Computer Science at Berkeley&lt;/a&gt; UC伯克利大学的EECS（我理解为国内的软件工程）的教学资源在&lt;a href=&#34;https://inst.eecs.berkeley.edu/&#34;&gt;它的官网上&lt;/a&gt;都有公开分享，包括Youtube上的讲课录屏、教义、实验等。起步课程是CS61A（适合没有编程经验的学生上手编程，且为学生灌输来自&lt;a href=&#34;https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs&#34;&gt;SICP&lt;/a&gt;神书的关于计算机程序的一系列抽象概念（概念成了体系，日后可以帮你事半功倍地理解更复杂的模型）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;我推荐的阅读材料&#34;&gt;我推荐的阅读材料&lt;/h3&gt;
&lt;p&gt;API的使用方法可以通过关键字去搜索文档和问答，但职业经验就不方便搜索了，它们恰恰是重要的东西。IT行业很有意思，我没见过除此之外哪个行业在遵守工匠道路的同时，又不吝啬甚至乐于向同行分享自己的经验。有许多人会写经验类的博客，比热门博客更系统化也更著名的是出版成书的著作。下面是我读过的，能打包票的经验方面的阅读材料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/3032825/&#34;&gt;Clean Code 代码整洁之道&lt;/a&gt; 讲细小层面（语句级别）的编程技巧。当用某种编程语言写了一个练手项目或几个功能时就可以开始看了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/6114900/&#34;&gt;The Clean Coder 程序员职业素养&lt;/a&gt; 很薄的一本书，对的，和Clean Code是同一系列， 该系列还有两本：架构整洁之道，敏捷开发实践，等级比较高，我还没看¯\_(ツ)_/¯。不涉及技术细节，指导程序员在某件工作乃至职业规划上应该如何做。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/35006892/&#34;&gt;The Pragmatic Programmer: From Journeyman to Master 程序员修炼之道（第2版）&lt;/a&gt; 分了许多小章节，每个章节用一个比喻做标题。两个作者想把他们的职业经验讲给你听，内容涉及方方面面。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/3324516/&#34;&gt;实现模式&lt;/a&gt; 书不厚，类似Clean Code，讲细节的编程技巧，但是对读者的经验要求比Clean Code高一些。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/zer4tul/44ac7d145a4342d876f3&#34;&gt;如何成为黑客&lt;/a&gt; 不，hacker不是你想象的那个意思，你指的是cracker。这篇文章是一位温和派的开源运动领导者写的关于实践开源精神的一些建议，里面一些原则值得以程序员的角度去理解学习。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/35043034/&#34;&gt;计算机简史（第三版）&lt;/a&gt; 学校里没有开设关于IT行业的历史课，我倒觉得该开一门。了解历史能多明白一些为什么现在的IT行业是这副样子。比如，开源运动如何让行业内出现了可自由使用的第三方库，让软件研发行业对人员专业素质的要求大幅降低，进而让提供了大量岗位。随着科技的发展和商业需求、社会环境的演变，曾经的一些黄金实践原则已经过时或不合时宜，也出现了适应时代的新的原则。举个例子，你不会在50年前要求程序员编写单元测试，因为他们连编译个程序都要等好几个小时，而现在的算力如此廉价，在一台个人笔记本上运行整个项目的整套单元测试只需要几分钟，这也让&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&#34;&gt;持续集成&lt;/a&gt;成为可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/25956450/&#34;&gt;人件&lt;/a&gt;、&lt;a href=&#34;https://book.douban.com/subject/1102259/&#34;&gt;人月神话&lt;/a&gt;和&lt;a href=&#34;https://book.douban.com/subject/25881855/&#34;&gt;大教堂与集市&lt;/a&gt; 这三本是软件开发组织架构方面的理论书，结合对应的年代和历史事件，它们会让你了解软件开发行业是怎样从瀑布式开发转向敏捷开发的，开发团队的组织规模为何从大部队分散成灵活的小组。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>译文：从源码中学习（阅读源码，初学者的有效成长方式）</title>
                <link>https://boholder.github.io/blogs/learn-from-source-code/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/learn-from-source-code/</guid>
                <pubDate>Tue, 25 May 2021 00:00:00 &#43;0000</pubDate>
                
                <copyright>all rights reserved</copyright>
                
                    <description>&lt;p&gt;这是一篇译制博客文章，原博客为
&lt;a href=&#34;https://coderscat.com/learn-from-source-code/&#34;&gt;Learn from Source Code (an Effective Way to Grow for Beginners)&lt;/a&gt;
，原作者为&lt;a href=&#34;mailto:nickmose8@gmail.com&#34;&gt;Nick Mose&lt;/a&gt; 。
&lt;a href=&#34;mailto:bottleholder@anche.no&#34;&gt;我&lt;/a&gt; 向Nick申请获得了此文的中文翻译权与中文翻译文章发布权。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;上周我在和一位年轻程序员聊天时，他问到我：“如何阅读源码？”，我们讨论了一段时间，我还列举了几种有效阅读源码的方式。
然后他说：“你应该就这个话题写篇文章，这对初学者很有帮助，而且这种经验无法从书籍和教程中获得。”
那么开始吧，下面是我关于阅读源码的小技巧。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要读源码&#34;&gt;为什么我们需要读源码&lt;/h2&gt;
&lt;p&gt;我们程序员每天都要和源码打交道。经过数年的学习，大多数程序员可以“写”代码，或者至少是拷贝并修改代码。
而且，我们教授编程的方式强调编写代码的艺术，而不是如何阅读代码。
当我说“阅读代码”，我是指&lt;strong&gt;有意地专门阅读代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;众所周知，编程和写作有诸多相同之处。
唐纳德·克努特甚至引入了&lt;a href=&#34;https://en.wikipedia.org/wiki/Literate_programming&#34;&gt;文学编程(literate programming)&lt;/a&gt; 编程范式。
编程与写作有相同的理念：&lt;a href=&#34;https://www.coderscat.com/how-to-learn-all-pl&#34;&gt;表达我们的想法&lt;/a&gt; 。
还记得你在学校是怎么学习写作的吗？我们的写作能力来源于从小学开始直到现在的大量的文本阅读。
多年以来，我们阅读了不同难度的伟大作家的作品，并练习了多种写作技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果你没时间读，你就没时间（或工具）写，就这么简单。”
—— 斯蒂芬·金，&lt;a href=&#34;https://book.douban.com/subject/3888123/&#34;&gt;《写作这回事：创作生涯回忆录》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如斯蒂芬·金所观察到的那样，一个作家必须广泛而频繁地阅读，才能形成自己的声音，
并学会写出促使读者拿起书并痴读的句式和故事结构。
&lt;strong&gt;和读书一样，有意地阅读代码可以帮助程序员加速成长，尤其是对中级(intermediate)程序员而言。&lt;/strong&gt;
这样做有三个好处。&lt;/p&gt;
&lt;h3 id=&#34;站在巨人的肩膀上&#34;&gt;站在巨人的肩膀上&lt;/h3&gt;
&lt;p&gt;我们从他人身上学习。优秀的源代码就像文学杰作，它不仅仅只提供了知识和信息，还提供了启迪。&lt;/p&gt;
&lt;p&gt;通过浏览Linux内核、Redis、Nginx、Rails或其他著名项目，
你可以从全球范围的成千上万的顶级程序员那里汲取智慧。
在这些项目中可以找到无数的良好编程示例、编程范式选择、设计和架构。
向他人学习的另一个好处是能够避免常见的坑，大多数坑早已被他人踩过。&lt;/p&gt;
&lt;h3 id=&#34;解决困难问题&#34;&gt;解决困难问题&lt;/h3&gt;
&lt;p&gt;在你的职业生涯中，你终将会碰到谷歌都无法解决的问题。
如果你还没碰到过这种问题，这只是因为你编程的时间还不足够长 :)。
阅读源码是调查这类问题的好方法，也是学习新东西的好机会。&lt;/p&gt;
&lt;h3 id=&#34;扩展你的边界&#34;&gt;扩展你的边界&lt;/h3&gt;
&lt;p&gt;大多数程序员只在少数特别领域编过程。
一般而言，如果你不时常推自己一把，你的编程技能会维持在你同事间的平均水平。
不要满足于修补bug或在现有系统中添加琐碎特性的工作。
相反，你可以试着扩展到一个新的领域，持续尝试找到一个你在日常工作中接触不到、但你感兴趣的领域。
这将从整体上拓宽你对编程的理解。&lt;/p&gt;
&lt;h2 id=&#34;应该读什么样的源码&#34;&gt;应该读什么样的源码&lt;/h2&gt;
&lt;p&gt;综上，阅读源码是有益的。
那么下一个问题，有这么多优秀作品可供选择，我们该选择并阅读什么样的源码呢？
你必须从选择目标开始。如果不在这个步骤上下点功夫，你从源码中学习的效果就会打折扣。
这里有一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当你想学习一门新语言。学新语言可&lt;a href=&#34;https://coderscat.com/how-to-learn-all-pl&#34;&gt;不只是学会语法&lt;/a&gt; 。
不管怎样，阅读源码是一个非常有效的学习新语言的方式。我从&lt;a href=&#34;https://github.com/rust-rosetta/rust-rosetta&#34;&gt;rust-rosetta&lt;/a&gt;
项目中学到了很多Rust语言知识。&lt;a href=&#34;http://rosettacode.org/wiki/Category:Programming_Languages&#34;&gt;Rosetta Code&lt;/a&gt;
是一个收集同一批通用任务在不同语言上的解决方案的项目，这是一个可用来学习新语言的有用资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想了解一个特殊的算法或实现。
例如，我们都会使用标准库中的sort函数，你有没有好奇过它是怎么实现的？
或者当你要使用Redis中的Set结构，它是用什么数据结构实现的？
为了解决这些疑惑，你只需要读源码中与之相关的实现部分，通常只有很少的文件或函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在特殊的框架中编程。这意味着你对该框架已经有了一定的经验，
这是个阅读一些框架本身的源码的好机会。
很显然，了解框架的源码有助于提高你对框架的理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想拓展进入新的领域，你可以阅读这个领域的经典著名的项目的源码。
比如说，如果你在做Web开发的工作，你对分布式系统感兴趣吗？
如果你的答案是“是”而且你懂Golang，也许&lt;a href=&#34;https://github.com/etcd-io/etcd&#34;&gt;etcd&lt;/a&gt;
是你的选择。你想钻研操作系统的内部构成吗？那么也许&lt;a href=&#34;https://github.com/mit-pdos/xv6-public&#34;&gt;xv6&lt;/a&gt;
是一个好的开始。我们处在一个许多优秀开源项目都托管在了Github的好时代，请试着寻找一些这种项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记住，&lt;strong&gt;选择与你当前的编程技能与知识水平相当的项目。&lt;/strong&gt; 
如果你选择了远超你当前技能水平的项目，最终你会感到沮丧。
读一些相对较小的项目，接着读更大的项目。
如果目前你不能理解某些特定的代码片段，这意味着你有个知识缺口(knowledge gap)。
把代码放到一边去，试着读一些相关的书、论文或其他文档，当你更有信心时再回来接着读代码。
我们总能在一个模式中取得进展：读（代码、书、论文），写，更多的读，更多的写。&lt;/p&gt;
&lt;h2 id=&#34;如何读源码&#34;&gt;如何读源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095&#34;&gt;《How to read a book》&lt;/a&gt;
是一本指导人进行明智地阅读的书。作为初学者，我们值得投入时间和精力去思考我们应该如何阅读代码。
&lt;strong&gt;阅读代码不是件容易的事。&lt;/strong&gt; 光是阅读源码是不够的，你要试着去理解他人的设计和想法。&lt;/p&gt;
&lt;h3 id=&#34;预先准备&#34;&gt;预先准备&lt;/h3&gt;
&lt;p&gt;为了更有效率地阅读代码，你需要提前在手边准备这些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个你可以熟练使用的编辑器。你需要拥有快速搜索关键字或变量名的能力。
有时你需要查找函数的引用和定义。和你的编辑器相处融洽些。
为了更加有效率，试着学习仅使用键盘操作编辑器。
这会使你专注于代码而不受打扰（译：指额外思考编辑器操作）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握基本的Git或其他版本控制工具的技能，这样你就能比较代码在版本间的差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与源码有关的文档。文档可以为你的阅读提供参考，尤其是设计文档、编码规范等文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有一定的编程语言与设计模式的知识和经验。这对（阅读）大项目是强制性的。
如果你很了解一门编程语言，你也会了解关于源码组织与编程范式的最佳实践。
当然，这需要时间来积累。要有耐心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流程与技巧&#34;&gt;流程与技巧&lt;/h3&gt;
&lt;p&gt;阅读过程不是线性的。你不会就那么一个接一个地读源文件。
相反，大多数时候我们会从顶到底地阅读代码。
下面是一些更有效率阅读代码的小技巧：&lt;/p&gt;
&lt;h4 id=&#34;结合上下文阅读代码&#34;&gt;结合上下文阅读代码&lt;/h4&gt;
&lt;p&gt;当你阅读代码时，请持续提出问题。
例如，如果一个应用有缓存策略，一个好问题就是：如果键无效了会怎样？缓存中的值如何更新？
带着这些问题阅读代码，就是结合上下文。或者说因为你有了一个目标，你会变得享受阅读的过程。
你甚至可以自己做一些假设，然后在代码中寻找验证。&lt;/p&gt;
&lt;p&gt;你有点像侦探：&lt;strong&gt;你想发现代码的真相，代码的逻辑，代码是如何像故事一般上下流动的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;把实例跑起来并与之交互&#34;&gt;把实例跑起来并与之交互&lt;/h4&gt;
&lt;p&gt;源码就像乐高积木，只是已经组装好了。
如果你想了解它们是怎么组装在一起的，你需要和它交互，有时甚至要把它拆开。
阅读同一模块的老版本同样有帮助。从Git中阅读版本差异，试着弄清楚特定的特性是如何实现的
（修改日志在这个场景很有用）。
举个例子，我发现Lua的第一个版本相当简单，这可以帮助我了解作者最初的设计理念。&lt;/p&gt;
&lt;p&gt;Debug是另一种与代码交互的方式。试着在代码中加一些断点（或打印一些变量值），
然后弄明白打印到控制台中的所有输出。&lt;/p&gt;
&lt;p&gt;如果你对代码了解比较透彻了，试着对代码做一些修改，重新build并把它跑起来。
最简单的方式是试着调整配置项，去看不同配置的运行结果。
之后你可以试着添加一些细微的特性。
如果这些特性对其他人也有用，你应该把代码贡献到上游。&lt;/p&gt;
&lt;h4 id=&#34;了解数据结构间的关系&#34;&gt;了解数据结构间的关系&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;“糟糕的程序员担心代码，优秀的程序员担心数据结构和它们的关系。”
-Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据结构是一个程序中最重要的元素。用笔或者你喜欢的其他工具画出数据结构间的关系。
这个图就是源码的映射。你会在阅读过程中时常参考这个图。一些工具比如&lt;a href=&#34;https://scitools.com/&#34;&gt;scitools&lt;/a&gt;
可以用来生成UML类图。
（译：这个方法用在写代码中能节约翻Model声明文件的时间，推荐用纸笔，不占屏幕）&lt;/p&gt;
&lt;h4 id=&#34;了解模块间的依赖关系与边界&#34;&gt;了解模块间的依赖关系与边界&lt;/h4&gt;
&lt;p&gt;大项目中会包含许多模块，一个模块经常只拥有单一职责。
这有助于我们减少代码复杂度，在适当的层级上做抽象。
模块的接口是抽象的边界，我们可以一个接一个地阅读模块。
如果你在阅读一个使用Make构建的C/C++项目，Makefile是了解模块间如何组织的好切入点。&lt;/p&gt;
&lt;p&gt;边界本身也很有用。优秀的代码组织得很好，变量名与函数名的命名风格体现着可读性。
你不需要阅读全部源文件，你可以&lt;strong&gt;忽略不重要的或你熟悉的部分&lt;/strong&gt;。
如果你确定一个模块是仅仅是为了被解析而设计的(just designed for parsing)，
那么你已经大致了解了它的功能；那么你就可以跳过不读这个模块。
当然，这将大大节约时间。&lt;/p&gt;
&lt;h4 id=&#34;使用测试用例&#34;&gt;使用测试用例&lt;/h4&gt;
&lt;p&gt;测试用例也是帮助代码理解的一个很好的补充。&lt;strong&gt;测试用例就是文档。&lt;/strong&gt;
当你在阅读一个类时，试着把对应的测试代码一起读了。
测试用例能帮你弄清一个类的接口，和该类的典型用法。
集成测试用例可以让你顺着走过程序的整体流程，适合输入一些特殊值并debug运行。&lt;/p&gt;
&lt;h4 id=&#34;点评&#34;&gt;点评&lt;/h4&gt;
&lt;p&gt;为什么不在花了不少时间阅读一个项目后，写一篇代码点评呢？就像写一篇书评一样。
你可以写下代码中好的和不好的部分，还可以记下你从中学到了什么。
攥写这类文章可以帮助你阐明自己的理解，也有助于其他人阅读源码。&lt;/p&gt;
&lt;h2 id=&#34;一些好书&#34;&gt;一些好书&lt;/h2&gt;
&lt;p&gt;我发现阅读代码是一个远超我想象的广泛话题。没有系统性训练该技能的方法。
总而言之，不断练习，找到你自己的方式。下面是一些帮助你提升代码阅读能力的好书：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/&#34;&gt;《Design Patterns: Elements of Reusable Object-Oriented Software》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/0134494164/&#34;&gt;《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095/&#34;&gt;《How to Read a Book: The Classic Guide to Intelligent Reading》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啊哈，这本书对程序员也很有用。&lt;/p&gt;
&lt;h2 id=&#34;译者的话&#34;&gt;译者的话&lt;/h2&gt;
&lt;p&gt;这篇文章是为苦于不知从何开始阅读陌生项目代码的人（包括我）准备的。
截止撰文时间为止，我认为这篇文章是在同话题中较为务实的一篇，
不仅包含理念，还包含不少具体可实践的建议，因此我想把它分享给更多人。
而且我想如果它有中文版本，愿意读下去的人会多一些，我也方便向周围的人分享，于是我向Nic申请了翻译权。
我把标题改了改，这样搜索“源码”“学习”、“阅读源码”都能搜到。&lt;/p&gt;
&lt;p&gt;这篇文章对我而言，最大作用是帮我突破了“不需要有意地专门阅读代码”的心理障碍。
我一直以为既然“写代码的时间中十之六七都是花在读既有代码上”（语出《Clean Code》），
就没必要再花时间专门读代码，我大错特错。&lt;/p&gt;
&lt;p&gt;个人经验：驱动我“专门读代码”的最大动机是好奇心，和小孩拆小物件为了看内部构造差不多。
学习OO设计模式，我建议阅读&lt;a href=&#34;https://book.douban.com/subject/2243615/&#34;&gt;《Head First 设计模式》&lt;/a&gt;
，这本书超有趣，比四人帮那本删减了一些不常用的模式，但是你能轻松读下去。&lt;/p&gt;
&lt;p&gt;阅读了解项目代码是参与（开源）项目的第一步，希望这篇文章能帮助你参与到心仪的项目中去。
这也可以帮助你在工作中了解同组同事的工作，而&lt;a href=&#34;https://laike9m.com/blog/jin-ji-nian-wo-zai-zhi-chang-cai-guo-de-keng,143/#-4&#34;&gt;“了解同组同事的工作对工作有诸多潜在益处”&lt;/a&gt; 。
来吧，花点时间挑一个看上眼的项目（或者就读你手头的项目别人写的部分），
找到你最感兴趣的功能，读一读它是怎么实现的。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>单元测试的不同方式</title>
                <link>https://boholder.github.io/blogs/unit-test-methods/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/unit-test-methods/</guid>
                <pubDate>Sun, 23 May 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;对读者的知识要求前言&#34;&gt;对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;h3 id=&#34;要求&#34;&gt;要求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;掌握任一编程语言，明白“单元测试”即相关概念定义和作用，写过单元测试。&lt;/li&gt;
&lt;li&gt;&lt;del&gt;王婆卖瓜：如果不确定自己是否明白“单元测试的定义”，
请看&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#41-%E4%B8%BA%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95&#34;&gt;这段解释“为编码测试”的文字&lt;/a&gt; 。&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;现在&lt;a href=&#34;https://martinfowler.com/articles/2021-test-shapes.html&#34;&gt;单元测试和集成测试的定义因学派、组织和团队而异&lt;/a&gt; ，
我预先说明，本文中“单元测试”指“程序员为编码而编写的，
可能会使用mock技术的，针对单个类(组件？)的，总运行时间在几分钟内的测试”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;在本文中我将介绍编写单元测试(和组件测试，实践中这两个概念拆不开)时可使用的三种调用-期望方式，用途各不相同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对运行时间的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：调用被测函数，并记录调用前后时间差值，计算运行时间。&lt;/li&gt;
&lt;li&gt;目的：测试运行时间表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于用例的测试(example-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：写明特定的桩(stub)的反应(mock::given&amp;hellip;thenReturn&amp;hellip;)，
写明调用被测函数时的测试数据，期望(expect,assert)特定的输出。&lt;/li&gt;
&lt;li&gt;目的：确认模块对特定输入的输出符合预期的特定值
(包括对被测在运行中调用桩时传入的参数，和对调用本身的返回值两方面)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试(property-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：基于函数与调用者的契约(contract)，生成随机的测试数据并反复调用被测函数，
期待被测因没有正确根据输入修正自己的行为，抛出被测逻辑中没有考虑到的异常。&lt;/li&gt;
&lt;li&gt;目的：测试被测函数是否满足契约。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有研究（没找到论文链接）显示，人脑对信息的记忆和理解不仅发生在接受时，还发生在接受后的一段时间。
我打算先介绍运行时间测试（很短很容易理解），再讲“基于用例的测试”（我们都熟悉的那种），最后试着让你理解一个新概念：“基于特性的测试”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章结构是头轻脚重，篇幅比例是2:3:5，运行时间测试这部分的存在非常突兀，但我不想把这部分剔除。&lt;/li&gt;
&lt;li&gt;标题包含“单元测试”就是想说明，下文介绍的内容都能在单元测试层面实现，并指导编码。&lt;/li&gt;
&lt;li&gt;“基于特性的测试”在网上有诸多争议性观点，我试着对其中一些给出基于自己理解的解释。&lt;/li&gt;
&lt;li&gt;文中唯一的举例代码所用的编程语言为Java，无需担心的是，不同语言到撰文止都已有各自的成熟的基于用例的和基于特性的测试库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-对运行时间的测试&#34;&gt;1. 对运行时间的测试&lt;/h2&gt;
&lt;p&gt;解决方案是在&lt;a href=&#34;https://book.douban.com/subject/11614538/&#34;&gt;《The Clean Coder(程序员的职业素养)》&lt;/a&gt; 中读到的。
书里的一段对测试用例的协商对话（7.2验收测试）无意间描述了这个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试人员A：该函数运行时间不应超过两秒。&lt;/li&gt;
&lt;li&gt;测试人员B：无法为“不应超过两秒”编写测试，我们可以引入概率，即保证99.5%情况下符合。&lt;/li&gt;
&lt;li&gt;测试人员A: 如果要编写循环1000次测试，期望超时次数小于5，这个用例将耗时1小时，不现实。&lt;/li&gt;
&lt;li&gt;测试人员B: 可以执行15次操作，期望运行时间确切为2秒的
&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%88%86%E6%95%B8&#34;&gt;Z-score（标准分数）&lt;/a&gt;
大于2.57。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述对话提到了两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要用概率约束关于性能的需求，这种需求才可编写测试体现。&lt;/li&gt;
&lt;li&gt;合理运用抽样统计思想可减少测试所需的重复运行次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;在勉强把它归为一类吗&#34;&gt;在勉强把它归为一类吗？&lt;/h3&gt;
&lt;p&gt;嗯，有自觉。在单元测试层面，因测试框架对程序的控制权有限，能测的所谓“性能”仅仅指运行时间。
这个方式本质算作第二种“基于用例的测试”，但它的期望目标比较特殊，所以单独提出来介绍印象会比较深。&lt;/p&gt;
&lt;p&gt;虽然提起性能就是集成测试，需求中对性能要求的范围也往往是整个流程链路，
但这个确实能在单元测试层面实现。
比如每个高级些的语言都会有查看当前时间戳的库函数，
调用前后计算差值，就能得到与真实情况偏差不大的运行时间。
注意测试框架往往提供方式限制单个测试用例的运行时间，
那个的设计意图是防止单个用例影响整体测试运行，
不适合用来测运行时间，因为不能测量重复运行，单样本在统计学上不能验证假设。&lt;/p&gt;
&lt;p&gt;在单元测试中测试运行时间有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要等到集成测试时发现问题再打回来优化，fall fast嘛，至少保证这部分没有拖后腿。&lt;/li&gt;
&lt;li&gt;根据“单元测试指导编码”的原则，如果对模块的内部的函数有不同实现方案，
该函数运行负担较重且可测试，就可计算并利用运行时间作为方案取舍的参考。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-基于用例的测试example-based-testing-ebt&#34;&gt;2. 基于用例的测试(example-based testing, EBT)&lt;/h2&gt;
&lt;p&gt;用例本该用来翻译case或use case，这是术语，
但想了想还是把example翻译成用例合适，搜了下中文的博客也都用的这个翻译。
清楚与明确，就是EBT的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于计算类函数，可以做边界值测试。&lt;/li&gt;
&lt;li&gt;对于功能类函数（后端CRUD工作），可以写个冒烟测试（冒烟是集成测试的术语，在此借其定义）检查代码能否正常工作。
或者输入异常测试数据、给桩mock异常反应，测试被测函数的异常处理流程。&lt;/li&gt;
&lt;li&gt;TDD时需要故意写使测试失败的测试用例以启发编码，这是标准操作流程。&lt;/li&gt;
&lt;li&gt;再比如你想逐步debug，使用EBT可以让你清楚地知道程序走到每一步时应有的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;运用设计模式简化构造复杂测试数据实例的过程&#34;&gt;运用设计模式简化构造复杂测试数据实例的过程&lt;/h3&gt;
&lt;p&gt;在MVx架构模式族中，中间模块的方法的参数通常是领域定义的Model，Model的某种集合，甚至主Model嵌套属性Model。
关于如何简生成过程，有以下内容供参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java语言，&lt;a href=&#34;https://stackoverflow.com/questions/12568742/generating-test-data-for-unit-test-cases-for-nested-objects&#34;&gt;StackOverFlow上的这个问题&lt;/a&gt;
可能对你有所帮助。你也可以用&lt;a href=&#34;https://projectlombok.org/&#34;&gt;Lombok库&lt;/a&gt; ，
它的&lt;code&gt;@Builder&lt;/code&gt;注解可以生成Builder模式的对象构造代码。
或者IDEA编辑器，也有生成Setter方法的功能，但Builder模式比调用Setter构造对象方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非Java语言，&lt;a href=&#34;http://www.natpryce.com/articles/000714.html&#34;&gt;这篇博客&lt;/a&gt; 中提到的几个设计模式，
比如&lt;a href=&#34;http://wiki.c2.com/?ObjectMother&#34;&gt;Object Mother(数据生成工具类)&lt;/a&gt; ，&lt;a href=&#34;https://wiki.c2.com/?TestDataBuilder&#34;&gt;Builder&lt;/a&gt;
可以简化重复的构建语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示范代码&#34;&gt;示范代码&lt;/h3&gt;
&lt;p&gt;下面示例代码使用Java语言及其下的测试框架与库：
&lt;a href=&#34;https://junit.org/junit5/&#34;&gt;Junit&lt;/a&gt; ，&lt;a href=&#34;http://hamcrest.org/&#34;&gt;Hamcrest&lt;/a&gt; ，
&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; 。
目的是测试MVC模型中一个Service的getEntitiesBy()方法的正常逻辑(略去部分代码)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设定环境&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;假设DB中存在（对Mapper进行mock）与输入Request内容对应的记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;期望&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 桩：该方法会使用输入的Request中的索引值&amp;quot;normal&amp;quot;调用Mapper查询数据库，获取对应记录包装成的Entity Model。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 返回值：该方法应返回一个消息代码为&amp;quot;ok&amp;quot;的Response对象，其数据应为一个Entity对象的列表，首个元素的状态应与Mapper返回的对象相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// -------service.ServiceTest
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Given-When-Then - Behavior Driven Development (BDD)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;withNormalResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;normal&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// given, Mockito
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;given&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;willReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// when
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// then, Hamcrest, 对调用的返回值的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ok&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Mockito, 对被测调用桩时传入的参数的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;verify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;capture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 构造Mapper桩所返回的测试数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Collections&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;singletonList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dto.Response
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Lombok
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dao.entity.Entity
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Entity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-基于特性的测试property-based-testing-pbt&#34;&gt;3. 基于特性的测试(property-based testing, PBT)&lt;/h2&gt;
&lt;h3 id=&#34;名词解释&#34;&gt;名词解释&lt;/h3&gt;
&lt;p&gt;实在不好意思，我得先让你读一些难懂的名词定义，
关键内容大多是从&lt;a href=&#34;https://book.douban.com/subject/35006892/&#34;&gt;《程序员修炼之道(第2版)》&lt;/a&gt; 抄来的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例程（routine）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“例程是某个系统对外提供的功能接口或服务的集合。
比如操作系统的API、服务等就是例程；
Delphi或C++Builder提供的标准函数和库函数等也是例程。” &amp;ndash;&lt;a href=&#34;https://baike.baidu.com/item/%E4%BE%8B%E7%A8%8B/2390628&#34;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;契约式设计（development based on contract, DBC, 或contract-driven development）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出自&lt;a href=&#34;https://archive.org/details/objectorientedso00meye_0&#34;&gt;《面向对象软件构造(Object-Oriented Software Construction)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前置条件：例程期望自己运行前环境的状态符合它运行的需求。&lt;/li&gt;
&lt;li&gt;后置条件：例程保证自己退出时，环境的状态是什么样子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的不变式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从调用者的角度来看，类会确保不变式始终为真。&lt;/li&gt;
&lt;li&gt;在例程的内部处理期间，可以不遵守不变式，但退出时不变式需为真。&lt;/li&gt;
&lt;li&gt;因为Eiffel是OO语言，所以《OOSC》的作者将该概念命名为“类”的不变式，
实际上这个名词指的是例程所依靠的模块的内部状态，在OO语言里，就是类实例的状态。
《修炼之道》作者指出，在函数式语言中，状态是在函数间传递的数据本身，不变式概念依然有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例程与调用者的契约：
&lt;ul&gt;
&lt;li&gt;如果调用者满足例程所有前置条件，则例程保证退出时所有后置条件和不变式为真。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果任一方没有履行契约，就会调用（之前同意的）补救措施——抛出异常，或程序终止。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《修炼之道》：契约和不变式放在一起并称为特性，我们基于它做自动化测试。&lt;/li&gt;
&lt;li&gt;PBT库Hypothesis的作者的&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;解释PBT概念的文章&lt;/a&gt; ：
&lt;ol&gt;
&lt;li&gt;内部对调用者透明(&lt;a href=&#34;https://hypothesis.works/articles/referential-transparency/&#34;&gt;referential transparency&lt;/a&gt;))&lt;/li&gt;
&lt;li&gt;指定随机实例的类型(types)&lt;/li&gt;
&lt;li&gt;随机生成(randomization)&lt;/li&gt;
&lt;li&gt;对相关工具的使用(the use of any particular tool or library)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;只有ebt还不够&#34;&gt;只有EBT还不够&lt;/h3&gt;
&lt;p&gt;EBT优点在精准，缺点在太精准。一言以蔽之，EBT引入了太多主观且与需求无关的细节，且能测试到的代码运行路径的覆盖率及其有限。&lt;/p&gt;
&lt;p&gt;甚至个别用例会导致类似机器学习过拟合的效果，让代码偏离了原本的意图。
这更多是错认为“测试所表达的意图不会变且一直正确”的思维陷阱所导致的。
在EBT中，测试用例就是主观对需求的理解，需要在修改功能时不断检查无法通过的测试是否仍具有意义。
比如TDD实践中所使用的单元测试方式就是EBT，
在这篇记录两个开发者使用TDD流程结对编程实现一个Kata的
&lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/home/articles/the-bowling-game-an-example-of-test-first-pair-programming&#34;&gt;文章&lt;/a&gt;
中，两人会讨论“是否该把之前写的一个测试用例删除，因为它所代表的操作已不会在现实发生，虽然之前是有意义的”，还好他们凭经验避开了。&lt;/p&gt;
&lt;p&gt;从EBT转向PBT，像从&lt;a href=&#34;https://en.wikipedia.org/wiki/Programming_paradigm&#34;&gt;命令式(imperative)编程范式&lt;/a&gt; 到声明式(declarative)编程范式的转变。
命令式是给出具体过程的实现，就像EBT要明确构造调用被测函数时的测试数据的状态。
而声明式只是声明想做什么，具体过程交给解释器，
PBT也是只对特性的假设下准确定义，但关于在抽象定义的特性的限制下如何生成大量测试数据，交给PBT库。
这样我们仅仅给出了足够定义特性的信息，而没有引入对具体取值的依赖，符合&lt;a href=&#34;https://en.wikipedia.org/wiki/Interface_segregation_principle&#34;&gt;ISP原则&lt;/a&gt; 。
两者仅在对测试数据的构造方式上有差别，而对于被测函数的期望两者是相同精确的，都要明确写成assert, expect&amp;hellip;语句。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://increment.com/testing/in-praise-of-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 里不仅有关于EBT与PBT的代码级比较，还有使用PBT发现EBT难以暴露的bug的两个真实案例。&lt;/p&gt;
&lt;p&gt;不过我个人认为，PBT并不能完全取代EBT，比如边界值这个案例，
如果不是CI那种持续地测，没准儿只运行一次单元测试没能随机出特定的边界值呢。
而且两者也不互斥，可以针对同一个API写两种测试，更可靠。&lt;/p&gt;
&lt;p&gt;另外，我看到不止一个地方这样描述PBT：它会给你带来惊喜。&lt;/p&gt;
&lt;h3 id=&#34;pbt和fuzzing概念的区分&#34;&gt;PBT和Fuzzing概念的区分&lt;/h3&gt;
&lt;p&gt;PBT很像小到被测函数范围的&lt;a href=&#34;http://en.wikipedia.org/wiki/Fuzzing&#34;&gt;Fuzzing&lt;/a&gt; ，
目的是用大量随机输入无情地对待代码，尝试找出它代码上没有体现到，但是需求上承诺要做到的特性
（对于Fuzzing来说，被测软件应该承诺做到尽可能的鲁棒性和安全性）。
&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 阐述了两者间差别与相同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fuzzing是完全由计算机控制的随机过程，而PBT在随机的范围上基于特性进行了人为限定。&lt;/li&gt;
&lt;li&gt;PBT工具与Fuzzing工具在运行流程上高度相似，两者可相互替代使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个区别上我们也能看出，PBT不仅会利用计算机的随机与自动化摆脱思维对需求的偏见，
还能反过来促使开发人员思考总结并用代码表达出函数真正的、广范围的契约与不变式。
PBT可作为单元测试的一种方式，在单元测试层面，其最重要目的也是“启发编码”。&lt;/p&gt;
&lt;h3 id=&#34;pbt到底在哪个概念层级&#34;&gt;PBT到底在哪个概念层级&lt;/h3&gt;
&lt;p&gt;我认为PBT的明确对立概念应该是EBT，发生混淆的原因有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EBT已与太多的熟悉的概念绑定：TDD实践中明确使用EBT，谈起单元测试就是EBT；
谈起集成测试、QA以及更高层的测试，也是用具体的测试集去书面化需求文档，
测试集大多为EBT（但同时也存在引入随机测试数据的测试平台）。&lt;/li&gt;
&lt;li&gt;PBT运行时间多于EBT，不符合单元测试或者TDD要求的秒级结果反馈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可能会看到有观点说单元测试、TDD和PBT是对立的概念，《修炼之道》里部分文字也有这个意思。
当人们使用对比手法介绍PBT时，如果无法把EBT这个细类概念从大类概念中抽出，并明确地指出来，就会无意中造成这种表达理解上的误差。&lt;/p&gt;
&lt;p&gt;也有观点说PBT独立于单元测试、集成测试等测试层级概念，是“额外的一类测试”，我反对这个观点。
首先，我了解到的几个现有的PBT库都兼容在了原先存在的为EBT编写的成熟测试框架下，
或者应该说是测试框架逐渐变成了无关测试方式的抽象框架，这是事实依据。
其次从定义上区分，测试层级描述的是项目活动，区别主要在参与该活动的&lt;a href=&#34;https://en.wikipedia.org/wiki/Project_stakeholder&#34;&gt;项目干系人(stakeholder)&lt;/a&gt; 
的类别，和运行时对系统覆盖的范围，和PBT所定义的东西相差甚远。
PBT可以用在单元测试中，也可以用在集成测试中，它描述的仅仅是一种构造测试数据的思路。&lt;/p&gt;
&lt;h3 id=&#34;我认为单元测试中可以使用pbt&#34;&gt;我认为单元测试中可以使用PBT&lt;/h3&gt;
&lt;p&gt;在编程实践而非项目管理定义上，单元测试（和组件测试，组件测试在定义上比单元测试多涉及一个mock）有几个共识的特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由开发人员为指导编码所写。&lt;/li&gt;
&lt;li&gt;被测代码范围最大为单个模块，我们会使用Mock技术编写模块所依赖的桩，
模拟上层调用者调用模块的API，模拟被测模块的上下文。&lt;/li&gt;
&lt;li&gt;自动化与可重复运行。&lt;/li&gt;
&lt;li&gt;测试粒度比集成测试等包含多模块的层级更细。&lt;/li&gt;
&lt;li&gt;测试反映了开发人员对代码行为的期望。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以判断说PBT没有违反上述单元测试的定义。PBT与单元测试的矛盾大概在运行时间上。&lt;/p&gt;
&lt;h4 id=&#34;单元测试运行时间的大部分受不可控因素影响&#34;&gt;单元测试运行时间的大部分受不可控因素影响&lt;/h4&gt;
&lt;p&gt;TDD等倡导测试优先的学派，为了实践需要，额外为单元测试增加了“测试集运行速度需缩短到秒级”的要求。
这个要求是基于现代电脑的高性能前提提出的，而且我猜测，单元测试被TDD概念反过来影响，加之开发人员们主观感受，
认为单元测试就是而且应该是很快的。&lt;/p&gt;
&lt;p&gt;但我们在实践中已经了解到，一旦引入Mock机制，运行一次某个类对应的单元（严格来说是组件）测试的总时间，
绝大部分为测试框架执行mock加载上下文的时间，正比于我们想测的模块所涉及的依赖的启动复杂程度。&lt;/p&gt;
&lt;p&gt;举例，以我的经验（大概只是工作电脑性能低），对于Java的Spring-boot应用中的单个Junit测试类，
使用&lt;code&gt;@RunWith(MockitoJUnitRunner.class)&lt;/code&gt;最快，大概启动10秒左右；
如果要用&lt;code&gt;@RunWith(SpringRunner.class)&lt;/code&gt;，&lt;code&gt;@SpringBootTest&lt;/code&gt;就要启动30多秒；
如果被测代码还包含从配置文件中读取配置的内容，需要额外用&lt;code&gt;@TestPropertySource&lt;/code&gt;在启动时导入测试配置文件，
又要加个10秒左右。
不管测一个方法还是测所有方法也是加载同一个上下文，最小化上下文还是需要这么多启动时间。
肯定每次运行时都要看控制台里application启动时慢慢输出的log，然后刷刷两下所有用例都测完，测试退出。
这类代码从实践上考虑就无法使用TDD开发，但这些测试就是它们的单元测试。&lt;/p&gt;
&lt;p&gt;我个人认为，正确理解单元测试的速度要求需要&lt;strong&gt;相对于&lt;/strong&gt;集成测试来说，
单元测试相比集成测试运行时间低至少一个数量级，这种说法是对的。
同时通过Mock这个例子，我们发现单元测试的运行时间取决于代码的依赖的复杂度、电脑性能等不可控因素上
（有些牵强？哈哈抱歉，大概就是想表达这么个意思，没讨论到的因素还有很多）。&lt;/p&gt;
&lt;h4 id=&#34;单元测试中能否用pbt取决于具体欲测特性的复杂度&#34;&gt;单元测试中能否用PBT，取决于具体欲测特性的复杂度&lt;/h4&gt;
&lt;p&gt;这个说法真模糊啊，但我只能拿出这种说法了。
你看，单个PBT用例相比单个EBT用例，慢就慢在要测多于一个测试数据，加上生成数据的时间，关键在运行时间。
但是生成数据的范围和单个数据测试的时间又是由特性决定的，下面分别对两方面解释一下。&lt;/p&gt;
&lt;p&gt;关于大家和PBT库认为单个PBT用例的运行次数，或者说生成测试集的大小，我搜索的结果是，
从提供限定大小的参数的库，到默认100个的固定数量的随机测试集的库，
到正统的不许设定数据集大小，粒度只能指定到数据类型，需要持续运行测试的看法，都有。
首先，肯定运行越多越好，持续集成里的测试可以这么写。其次，单元测试肯定受不了相对较长的运行时间。&lt;/p&gt;
&lt;p&gt;《修炼之道》给的介绍PBT的例子有这两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行100次，随机列表作为输入，测试排序方法调用前后列表长度没变，排序结果正确，运行时间0.95秒。&lt;/li&gt;
&lt;li&gt;运行100次，从大小为4的集合中随机取元素作为输入，测试“库存始终大于0”不变式，找到了bug，没写运行时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;嗯，第二个例子100次不算多，能找到bug是因为这个bug比较“容易”被引爆，“容易”是个主观定性的词，描述了这个特性的复杂度。
&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;这篇文章&lt;/a&gt; 里介绍了一些PBT常见模式，
不少模式（所代表的特性）复杂度并不高。&lt;/p&gt;
&lt;p&gt;鉴于我们的单元测试时间可能大部分还是会消耗在执行mock上，花10秒运行1000次测试来测试一个特性，
这样对整个模块的PBT单元测试大概要跑几分钟（共十几个特性），似乎是可以接受的。&lt;/p&gt;
&lt;h3 id=&#34;如何构造pbt所需测试数据&#34;&gt;如何构造PBT所需测试数据&lt;/h3&gt;
&lt;p&gt;基本&lt;a href=&#34;https://hypothesis.works/articles/quickcheck-in-every-language/&#34;&gt;每个编程语言都有PBT库&lt;/a&gt;
（这篇2016年的文章信息稍有过时），
这类PBT测试库通常会提供，对其服务的语言的原生库内的类的实例的随机构造方法。
有点绕，用Java下的&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/basic-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 
库举例就是：该库会提供对Java基本类型、String、常用集合类、Date等类的随机构造方法。
这种构造方法因库而异，在提供给用户使用的方式上稍有不同，
比如&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/other-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 使用参数上的注解，
Python下的&lt;a href=&#34;https://hypothesis.readthedocs.io/en/latest/quickstart.html&#34;&gt;Hypothesis&lt;/a&gt; 使用方法上的注解。&lt;/p&gt;
&lt;p&gt;这样方便你写测试时进一步构造自己软件所在领域的Model之类的实例。
构造方式与PBT相似，还是要运用上文EBT部分所述的技巧自己手工编写，
只是把Model的属性赋值部分换成库提供的随机生成方法。
具体到代码，可以参照&lt;a href=&#34;https://dev.to/quii/property-based-testing-in-real-life-4db8&#34;&gt;这篇文章&lt;/a&gt; 的做法。&lt;/p&gt;
&lt;h3 id=&#34;更多关于pbt的参考内容&#34;&gt;更多关于PBT的参考内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个叫jqwik的Java PBT库的&lt;a href=&#34;https://jqwik.net/property-based-testing.html&#34;&gt;介绍页面&lt;/a&gt; 给出了不少关于PBT的资料。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;文章 Property-based Testing Patterns&lt;/a&gt; 
易懂地说明了PBT中可遵守的一些模式，可根据这些模式来指导总结代码中的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;希望这篇文章给你讲明白了，或者至少你可以把所有参考资料读一遍，自己形成理解。
试试在工作中把PBT用起来，如果害怕擅自导入PBT包被发现，不提交至VCS就行。
顺带一提我还没实践过，打算下次迭代时试试。我预计即使是后端日常CRUD功能，
根据那篇&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;PBT Patterns文章&lt;/a&gt; 
，针对数据变换或判断的方法都可能能总结出特性。&lt;/p&gt;
&lt;p&gt;抛砖引玉，欢迎在评论中指点指正，或给出另一个角度的看法，好让我对这些概念了解更深。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/unit-test/">unit-test</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>对适用于个人的电子数据备份体系的总结</title>
                <link>https://boholder.github.io/blogs/individual-data-backup-summary/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/individual-data-backup-summary/</guid>
                <pubDate>Mon, 07 Dec 2020 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;数据保存在电子介质上，且只能通过电子设备读写，这意味着可能需要购买额外设备以满足对其保存、处理的需要。本文在引用所有没有对应术语级定义的自创名词时，将使用大括号高亮该名词，防止读者迷惑（例：【自创名词】）。同时本文使用反引号引用上文已提到的有对应术语的名词（例：&lt;code&gt;术语名词&lt;/code&gt;）。本文为我因愚蠢与意外，丢失了四个半月工作数据的反思总结文。本文内容仅个人见解，欢迎指点与讨论。&lt;/p&gt;
&lt;h2 id=&#34;数据重要性分级&#34;&gt;数据重要性分级&lt;/h2&gt;
&lt;p&gt;数据按重要性（丢失后的损失大小）分为几个等级。&lt;/p&gt;
&lt;h3 id=&#34;一级&#34;&gt;一级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密密钥：
&lt;ul&gt;
&lt;li&gt;用于解密被加密的大块数据，但数据丢失对应加密密钥也没用了&lt;/li&gt;
&lt;li&gt;即它与它所加密的数据（在使用上）相互依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TOTP(Time-based One-Time Password)的seed：
&lt;ul&gt;
&lt;li&gt;保有它本身能生成TOTP6位数字，即它不依赖于其他（已经被输入验证器APP中且无法提取出的）数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台账户、软件激活序列号、平台登录Licence&amp;hellip;&amp;hellip;统称“凭证”：
&lt;ul&gt;
&lt;li&gt;等同于&lt;code&gt;加密密钥&lt;/code&gt;，是“access大块数据的凭证”。&lt;/li&gt;
&lt;li&gt;它对应的“加密”数据通常不由个人保存（平台服务）或易于再取得（付费软件）。&lt;/li&gt;
&lt;li&gt;即它不依赖于其“加密”的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积小，通常很难超过10MB甚至1MB，该特征对&lt;code&gt;多副本备份&lt;/code&gt;要求有利，易于保存在多个存储媒介上。&lt;/li&gt;
&lt;li&gt;价值大，该类数据的确认丢失通常伴随着不可挽回的巨大损失，欲哭无泪的那种心情。
（还好平台账户还能找回密码！）&lt;/li&gt;
&lt;li&gt;你不想让它公开（需要加密），也不想彻底丢失它（多副本备份）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存&lt;/li&gt;
&lt;li&gt;多副本备份，包括本地存储专用设备（移动硬盘，家庭NAS）和网盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二级&#34;&gt;二级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;个人信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常被以“个人隐私”统称，因个人经历生成、或包含可识别特定个人的身份信息，多为文档、多媒体类型。&lt;/li&gt;
&lt;li&gt;此处只且只能关心你&lt;strong&gt;可以控制&lt;/strong&gt;的部分，至于上传到外部或在外部平台上产生的，最好在源头控制它，即永远上传最无关自己现实身份的最少信息，相信我，遵守该原则不会影响正常的网络社交。&lt;/li&gt;
&lt;li&gt;属于【个人信息】的文件举例：求职简历等“个人信息汇总型文档”（求职简历真的富矿），包含本人脸部（哪怕是低分辨率的非正脸）的照片视频；与他人在网络上的交流记录（聊天记录、邮件、别人发来的内含自己信息的文档等）&lt;/li&gt;
&lt;li&gt;【个人信息】和&lt;code&gt;凭证&lt;/code&gt;的差别在于文件体积大小和含义，&lt;code&gt;凭证&lt;/code&gt;就像钥匙，而【个人信息】就是宝藏本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他因人而异的想保密的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如虽然和狭义上的【个人信息】无关，但仍包含在广义的“个人隐私”中的部分（比如与个人兴趣相关的数据）。&lt;/li&gt;
&lt;li&gt;所有你不想让它公开或泄露的数据（不管它是否不宜公开，你有天然的权利使它保密，至少是权力）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;体积不定且随年龄增大（经历增多）而增大，视个体兴趣性格职业差异，
体积多数可控制在500G之内（爱拍照摄影的时尚达人们可能仍不满足这个已经被高估的容量）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;价值不定，但对你来说这些是重要的，这就足够作为执行备份的理由了。
（对你有兴趣的坏东西和好朋友通常也对这些信息感兴趣。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存（加密所用密钥可保存在【一级数据】中）&lt;/li&gt;
&lt;li&gt;至少一份完整的本地备份，和可选的网盘备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三级&#34;&gt;三级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在电子设备使用过程中积累在硬盘中的一般数据，包括程序和操作记录、文档等。加密与否无关紧要，但一般来说不会想丢失它。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积非常大，但只需要购买容量适合自己需求（包括未来几年的潜在需求）的额外存储设备。&lt;/li&gt;
&lt;li&gt;价值较小，但值得花费钱和精力加一道保险。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少一份完整的本地备份&lt;/li&gt;
&lt;li&gt;还要考虑定期将仅仅是存储在硬盘中但不常用的大文件转移到存储专用设备中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他与加密和备份相关的个人见解&#34;&gt;其他与加密和备份相关的个人见解&lt;/h2&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;p&gt;来推荐工具吧！我已使用好几年且现在仍然在使用&lt;a href=&#34;https://www.veracrypt.fr/en/Home.html&#34;&gt;VeraCrypt&lt;/a&gt;作为所有加密相关操作的工具软件，开源、多平台且功能完备，而且曾经停滞过几年的它现在又活跃起来了！还有什么比一个长久又仍在活跃的开源软件项目更棒的呢。VeraCrypt既可以加密整个Driver，又可以建立一个强加密的“文件型Driver”，解密挂载时是一个可存取文件的盘，卸载后就是一个Portable的文件。Portable=可以当作普通单一文件进行备份处理，完美。有个非程序小缺陷，直接从官网下载时非常慢，50kb/s(35M total)，且只能单线程请求数据。别担心，我们还有&lt;a href=&#34;https://sourceforge.net/projects/veracrypt/&#34;&gt;sourceforge的分流&lt;/a&gt;。（注意！不要被VeraCrypt的文件Driver功能迷惑了眼睛，我就是因为不读文档没做备份鲁莽试用Bitlocker时，将备份密钥存入文件Driver，忘记了该文件本身储存在设置了Bitlocker的Driver中，迷惑操作。）&lt;/p&gt;
&lt;p&gt;对于Windows专业版用户来说，&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview&#34;&gt;Microsoft Windows BitLocker&lt;/a&gt;也是一个趁手的工具，作为商业级软件，它使用方便，且有微软的持续质量支持。但它只能加密Driver，因此与备份操作结合时不太方便。使用BitLocker软件加密的Driver，在备份前需要手动解密，或设置开机（登录）后自动解密，这样备份操作才不会因读取Driver失败而失败。作为副作用，这会让加密文件在备份过程中暴露在可被读取的未加密状态下，因此对备份时环境的安全性（断网关服务）要求严格些。&lt;/p&gt;
&lt;p&gt;不好意思，我对Mac和Linux的常用软件集合了解不多，无法介绍对应其上的平台独有软件，VeraCrypt是多平台的，或许你可以先试试它。&lt;/p&gt;
&lt;p&gt;特别的，对【一级数据】而言，加密保存指使用另外一个人类可读的密钥（俗语：密码）加密存有【一级数据】的独立的Driver（或其他可独立转移的“数据集合结构”）。这要求你至少记住这么一个“主密钥”，“主密钥”用来解密出其他密钥。我使用VeraCrypt提供的文件Driver保存此类信息，该方法很原始，但我固执认为它“更安全”。市面上还有许多诸如&lt;a href=&#34;https://1password.com/zh-cn/&#34;&gt;1Password&lt;/a&gt;等直接提供此类信息加密与备份服务的软件，甚至连Firefox，Chrome等现代浏览器中就内置了网站密码管理服务，或者你可以买一个U盘大小的硬件（比如Yubikey）随身携带。稍加尝试就能找到合你口味的。&lt;/p&gt;
&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;
&lt;p&gt;考虑备份要首先识别需要被备份的数据主体，可以认为一个主体是一个包含多个同类文件的，可独立转移的集合。举例，对于我来说，有一个【一级数据】，两个【二级数据】（个人保密文档和工作保密文档），五个【三级数据】（家里台式机，家里笔记本，工作笔记本，手机，平板电脑）（手机和平板电脑是独特的，它们实际上是备份在电脑硬盘的【三级数据】部分中，它们本身属于一二三级混合，我的方案是将它们的备份加密（作为【二级数据】处理），但随电脑的【三级数据】备份。）&lt;/p&gt;
&lt;h4 id=&#34;备份位置&#34;&gt;备份位置？&lt;/h4&gt;
&lt;p&gt;因为数据保存在电子介质上，是基于物理存在的存储设备的，因此对于备份位置的选择，我没有考虑过同存储位置内的冗余备份，而是做到硬件级隔离，先不管地理位置（在抽屉里的移动硬盘还是地上的NAS还是网盘服务的主机集群中），至少是硬盘级别的隔离。&lt;/p&gt;
&lt;p&gt;我本人讨厌网络存储服务且没有多设备大量转移数据的需求（主观+客观原因），因此没有使用客观来讲确实经济实惠又方便的网盘服务。我也没有设置家庭NAS，只是购买了两块大容量移动硬盘，定期把【二级数据】和【三级数据】备份在两块硬盘上，一块在公司柜子里，一块在家里，四舍五入也算异地容灾了，容个火灾和人祸。至于【一级数据】，保存在家里台式机、家里笔记本电脑、两块移动硬盘、公司笔记本电脑，共五个备份。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经过这次意外后我决定将【一级数据】和【二级数据】额外上传到Microsoft OneDrive上，
反正加密了，备份数量多多益善，而且大小不是很大，能快速完成备份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：【一级数据】最好存在于每个【二级数据】所在的备份位置中，因为两者相互依赖，可以理解为钥匙配得比宝箱数量多，钥匙放在每一个宝箱旁，还有“主密钥”做为钥匙的保护机制。（像我这种使用独立加解密软件的人，还需要额外将加解密软件的免安装便携版与【一级数据】和【二级数据】放在一起。&lt;/p&gt;
&lt;h4 id=&#34;备份频率&#34;&gt;备份频率？&lt;/h4&gt;
&lt;p&gt;这是我本次经历的人祸所暴露出的备份体系中的最大问题&lt;strong&gt;备份不够频繁&lt;/strong&gt;，准确的说是对于公司笔记本电脑备份不频繁。我决定将之后的备份频率设置到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家中和公司的本地移动硬盘上每周备份一次（顺便备份手机与平板电脑）。&lt;/li&gt;
&lt;li&gt;家中和公司的两个移动硬盘每月交叉形成两份完整备份。&lt;/li&gt;
&lt;li&gt;【一级数据】和【二级数据】在电脑上设置自动网盘上传，每次更改过后就上传。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;备份间的自动化同步问题&#34;&gt;备份间的（自动化）同步问题&lt;/h4&gt;
&lt;p&gt;这个问题又要体现网盘的优势了，经过体验，OneDrive在Windows上可以做到实时备份，可以使用该特性保证联网存储设备上备份间的一致性。如果不想使用网盘服务，也可自建家庭NAS，只要是能保证储存设备间相互联网，总能有现成的解决方案建立起自动化的数据同步系统。比如Windows10系统自带的&amp;quot;备份&amp;quot;功能，可做到目录级粒度最短每10分钟同步一次。但是无法联网的设备，比如我那两块移动硬盘，我把它看作商业级方案中的“磁带仓库”——容量大且便宜，保存介质稳定，但无法通过网络读写。只能通过手动操作的方式对其进行备份更新，但最多也只是按时把它拿出来插在电脑，剩下的应交给只需手动配置一次的电脑上的软件级备份工具。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;本来作者的备份频率是一个月一次，在家里有好好遵守设定好的TODO为设备备份，但公司的电脑因为嫌沉发懒，一直没带回家，加之上班就是工作下班就是回家，这几个月都没在公司专门为工作笔记本备过份。更灵异的是，在出事前的昨天晚上，作者看视频时脑中突然蹦出“好像工作笔记本好久没备过份了”，随即被视频的精彩打消了顾虑，或许是冥冥中注定一劫让我清醒过来吧。还是要感谢这次意外的，因为虚假的安全比不设保险更危险。另外一个基于SRE理论的感悟是，重要操作前先备份，但别忘了&lt;strong&gt;无法做到先备份则应停止继续重要操作，Process fall in safe&lt;/strong&gt;。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/thought/">thought</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/sre/">SRE</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>TDD实践经验分享与对TDD实践程度的讨论</title>
                <link>https://boholder.github.io/blogs/tdd-tips/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/tdd-tips/</guid>
                <pubDate>Fri, 17 Jul 2020 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;0对读者的知识要求前言&#34;&gt;0.对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;p&gt;要求：简单掌握任一编程语言，明白“软件测试”的定义、类别与各测试类别的作用。&lt;/p&gt;
&lt;p&gt;去年刚写这篇文章（20200717）时，我第一次在《代码整洁之道》系列书中读到TDD的概念与好处，
并试着在工作中实践了一个月，写这篇文章的目的是分享实践中摸索与网上搜索到的TDD实践技巧。
今年我读了更多的书，感觉对TDD的理论与实践多了解了一些，更新打的“补丁”字数也不少，
于是把标题改成更宽泛的“对TDD的实践的讨论”。&lt;/p&gt;
&lt;p&gt;本文分成几大部分：
第一部分，对TDD的实践技巧分享，我建议跳过第4小部分的经验细节，先把后面更新的观点类的文字读一读。
第二部分，给出“严格遵守TDD在实践上很困难”、“TDD部分流程不太‘务实’”的观点以及理由；
第三部分，摘录大量书籍《程序员修炼之道(第2版)》中的文字，给出可利用TDD优势而不会陷入教条的折中实践方案，
与对于“测试”概念的新颖理解方式。&lt;/p&gt;
&lt;p&gt;希望本文能消除你对于TDD概念与实践的疑惑，让你在平时编码时能够从TDD的思维方式中获得好处，而不必苦苦承受遵守TDD流程实践中的重复与艰难。&lt;/p&gt;
&lt;h2 id=&#34;1什么是tdd&#34;&gt;1.什么是TDD&lt;/h2&gt;
&lt;p&gt;TDD的全称是 “测试驱动开发（Test-driven development）”&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;
，“是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名”。&lt;/p&gt;
&lt;p&gt;一个TDD循环的简单流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个需求对应的测试，该测试以一个功能方法的 &lt;strong&gt;一部分逻辑&lt;/strong&gt; 为目标。&lt;/li&gt;
&lt;li&gt;编写简洁的业务逻辑代码，以通过测试。&lt;/li&gt;
&lt;li&gt;回归测试，运行和这部分逻辑相关的所有测试（或者简单的把整个测试类run一下），确认全通过。&lt;/li&gt;
&lt;li&gt;重构代码，修正步骤2中因思考逻辑而忽略的设计原则|设计模式（比如if-else中重复的代码可以提取成一个方法）。&lt;/li&gt;
&lt;li&gt;重新执行步骤3，确保重构没破坏功能。回到步骤1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2tdd的好处&#34;&gt;2.TDD的好处&lt;/h2&gt;
&lt;p&gt;在此引用Uncle Bob的《代码整洁之道-程序员的职业素养》（另，推荐阅读此系列书）一书中他第一次看到TDD的回忆：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;首先，他写了一个单元测试的一小部分，没几行代码。然后，他写了刚好能使那个测试通过的代码。
接着，他又写了些测试，然后再写一些代码&amp;hellip;从编码到运行的周期如此之短&amp;hellip;Kent居然每30秒运行一次（测试）程序&amp;hellip;
忽然，我发现这种周期似曾相识！许多年前，当我还是孩子的时候&amp;hellip;解释型语言,无需编译构建，你要做的只是添加一行代码，
然后执行，再添加，再执行&amp;hellip;使用这些语言的编程效率极高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（我看到“30秒”那里，就对TDD感兴趣了。）Bob大叔说得对，我们在刚开始编程时都有一个时期，小心翼翼，一次只加一行代码， 然后运行看看print出的变量值发生了什么变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;符合预期的变化会给我们信心，而且直白的目标使下一行要加的代码“呼之欲出”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是TDD的魔力所在。它鼓励你拿出勇气去重构（烂）代码，因为你不再害怕重构它有破坏功能的风险， 快速方便的回归测试集的re-run报告帮你撑腰。&lt;/p&gt;
&lt;p&gt;TDD还有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试的代码覆盖率接近100%。&lt;/li&gt;
&lt;li&gt;这些测试不仅是单元测试的一部分，也是代码形式的用例和文档。&lt;/li&gt;
&lt;li&gt;便于执行自动化回归测试（单元测试层面）。&lt;/li&gt;
&lt;li&gt;测试间相互隔离，鼓励每次循环时编写的新逻辑间保持松耦合。&lt;/li&gt;
&lt;li&gt;TDD要求测试先行，这有助于帮助开发人员拆解需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3我认为的实施tdd的知识要求&#34;&gt;3.（我认为的）实施TDD的知识要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;熟练使用当前项目所用语言的特性与类库，和单元测试工具。 前者减少因为不熟悉语言而卡壳愣住的概率，后者是使用TDD的硬性要求。&lt;/li&gt;
&lt;li&gt;会拆解需求，从理想情况到需求所定义的限制性条件，一步步增加条件。（第4部分中详细解释）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4实施tdd过程中的困惑和解决方案&#34;&gt;4.实施TDD过程中的困惑和解决方案&lt;/h2&gt;
&lt;p&gt;TDD理论说来容易，但如果自身技能不够扎实，只是从头疼怎么写业务代码转到头疼怎么写测试而已。 测试先行意味着，测试写得不够“好”，则直接影响开发人员进一步的思考方向，严重时会把开发人员带进思考泥潭。&lt;/p&gt;
&lt;h3 id=&#34;41不需要在编写测试时编写非法输入测试&#34;&gt;4.1.不需要在编写测试时编写非法输入测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：如何在使用TDD时保证代码的健壮性？是否需要考虑非法输入？&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：TDD时不需要。TDD之后，部分代码会需要，再加上就是。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;的第二个回答，&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;1.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;编写非法输入测试(比如输入NULL，空对象指针etc，这不是一个正规名词但涵盖范围正确）是QA（测试人员）的任务， 当他们测试时，会在至少是单元测试的层面的封装（或者调用链）上测试非法输入，这意味着 &lt;strong&gt;不是每个方法都要考虑非法输入&lt;/strong&gt; ，
而TDD的测试会覆盖到每个方法。 另外，在TDD之后而不是TDD时考虑这个部分，修改代码会更头脑清晰更方便（回归测试给的信心）。&lt;/p&gt;
&lt;p&gt;同时应该注意的是，如果业务逻辑本身要求“分情况考虑”， 那么像是数组长度=0，以及由“情况”的排列组合得出的对应的“合法的”边界测试（edge cases），就要在TDD时覆盖到。 正确实例：&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;
（这是一个优雅如禅宗公案的“kata”）最后，为了考虑逻辑的“周全性”而添加的两个测试。（一个输入情况对应一个测试）&lt;/p&gt;
&lt;h3 id=&#34;42避免错误的步子大的测试&#34;&gt;4.2.避免错误的步子大的测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我写出了下一个测试，但在编业务代码时卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：先排除自身编码不熟练的因素，然后检查这个测试，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是不是覆盖的逻辑太大了，重新写一个小一些的测试（4.3详解）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;3.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;酒要一口一口地喝，路要一步一步走，步子迈大了，容易_ _ _。————《让子弹飞》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在TDD过程中，业务逻辑编码只需要恰好满足使测试通过， 如果坚持住这个原则，那么唯一使编程步骤卡壳的原因就在于： 开发人员不能快速想出通过测试的方案，又陷入了使用TDD前的窘境————没有短又直白的编码目标，头疼怎么一步到位。
这个测试不能驱动编码思路&lt;em&gt;呼之欲出&lt;/em&gt;，说明这个测试有问题，需要重新换一个。 两个资料里都提到了这样含义的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免一个测试覆盖太大的逻辑范围，这违反了TDD单个测试对应小目标的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误实例：就像文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;中“我”在第一次分析需求时，选择了不明朗的测试“演化”方向， 导致最后一步测试，实质上对应的是一步到位处理超过一种的新加入的情况，无法延续现有的代码继续修改以通过测试。&lt;/p&gt;
&lt;p&gt;现在的问题转换为“如何写出下一个测试”，请接着读4.3。&lt;/p&gt;
&lt;h3 id=&#34;43简化问题场景-逐步添加限制条件&#34;&gt;4.3.简化问题场景-&amp;gt;逐步添加限制|条件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我无法写出下一个测试，卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：接着上一步测试的目的，继续分析需求，我们走到哪了？或者我们应该换个思路重新分析需求？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;2.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;When faced with a problem you do not understand, do any part of it you do understand,
then look at it again.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;给出的引用，来自一部科幻小说。下面我要写的是我根据文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;和其他kata解决需求的思路悟出的门路， 总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要按步骤1-2-3线性流程切分需求，而是按套娃，
从理想的简单状态机（简单输入简单处理输出|复杂输入简化处理输出）到有条件|限制的复杂状态机（复杂处理+复杂输入|输出），
一步步完善处理逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你手边有《计算机网络》这类书，看看每个层的第一个教学使用的理论协议的假设条件有多理想，以数据链路层的协议为例： 单工，发送方和接收方的网络层总是准备就绪，数据处理不计时间， 可用缓存无限大，信道不会在物理层损坏|丢失。
这种理想协议只会在教科书上存在，但它形象地描述了该层协议 &lt;em&gt;可能的风险|考量&lt;/em&gt; 。 之后的篇幅逐渐引入各种机制来解决理想协议中忽略的考量，最终一个能在现实场景中使用的协议完成了。&lt;/p&gt;
&lt;p&gt;咱们的测试也应该像设计协议一样，每次只测试一个考量|一种情况， 修改少量代码通过这个测试，接着向下走，直到考虑了所有情况。&lt;/p&gt;
&lt;p&gt;正确实例：文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;后半段，“我”针对“字符串按位换行”需求，先考虑了没有空白符的“纯”字符串简单情况，然后因为引入空白符， 多增加了三种情况（分割点在空白符左、相同、右），多写三个测试并修改代码通过它们，最终完成了逻辑。&lt;/p&gt;
&lt;h2 id=&#34;2021-03-11更新&#34;&gt;2021-03-11更新&lt;/h2&gt;
&lt;p&gt;我对TDD有了新的理解：TDD对新手来说比较难以实践，不建议新手去用。有以下几点理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写测试速度很难跟上思考速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDD本质上是把对方法|函数的功能的要求编进测试用例，要求是思考形成的， 
如果对编程语言（＆第三方测试框架）不是如母语一样熟悉，
写测试的速度跟不上思考的速度，就需要阻塞思考，慢慢写出一个个测试用例。&lt;/li&gt;
&lt;li&gt;就像阻塞快速的CPU去做慢速的I/O一样，更惨的是不是人人都是周伯通，
手脑协调同时只能做一件事， 所以不能引入一个终端机制去并行思考&amp;amp;写测试）。&lt;/li&gt;
&lt;li&gt;阻塞思考不仅痛苦还会打断思路，而且编程速度很慢，不利于完成工作。&lt;/li&gt;
&lt;li&gt;解决这个问题，或者提高写测试速度（I/O速度）；或者科幻一些，
借助机器（引入数据通道辅助I/O），比如哪天出现一个自然语言的测试框架，
写英文就能生成对应测试用例，或者脑机接口之类。唉，暂时不可求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试用例是否能体现功能需求与测试是否通过无关，不可强求测试覆盖率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极端例子：&amp;hellip;; assertThat(1，is(1)); 上述用例在计算覆盖率时照常计算，但实际上什么都没有测出来。&lt;/li&gt;
&lt;li&gt;类比网络安全上的常识“虚假的安全感比没有安全感更致命”，
虚假的单元测试覆盖率和绿色的测试通过标记比没有一丁点单元测试同样致命。&lt;/li&gt;
&lt;li&gt;我想说的是，如果强行遵守TDD（意味着无论测试质量如何都会统计出高测试覆盖率）
或者不遵守TDD但有强制的单元测试覆盖率要求，有时对项目伤害更大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有专业全面的测试环节，单元测试的价值会打个折扣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这不是我的见解，我认为&lt;a href=&#34;https://twitter.com/iamshaynez/status/1357606576396275713&#34;&gt;他说得有些道理(推特thread)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但我认为对复杂逻辑的测试该写还是写，因为单元测试就是为开发时即时测试而存在的，和QA两码事。
即使QA发现bug提出工单，你改好了，但下次重构时又 不能&amp;amp;没权限&amp;amp;不方便 即时地把历史工单的测试用例全跑一遍，不踏实。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单逻辑犯错概率很小，没有写测试的必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举个例子，为了打log而写的try-catch(-catch&amp;hellip;)逻辑，
我会把try中的逻辑单独重构成方法，
那么专门对该单纯的try-catch包装方法写测试就比较鸡肋，
如果写测试速度不够快，认真读两遍代码看看异常类的名是否写对更快些。&lt;/li&gt;
&lt;li&gt;（如果throw的方法在try中的逻辑内调用好几层深，或者catch内涉及修改对象状态的“异常时处理”操作，
写个测试用例比较好，保证确实这类异常会被这里的catch抓住而不是被内部的catch抓住，进而触发处理操作。
（比如Java Spring @Transaction 注解，就隐性地要求必须把异常抛出该注解修饰的方法，才能启动回滚，
内部的打log catch要在最后把异常再throw出去。））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要承认，如果真的能同时：1.测试质量高 2.测试覆盖率高，那么这种单元测试的价值非常大。
可惜现实情况往往是没经验满足1，没时间满足2，而且不满足1还反而有害。&lt;/p&gt;
&lt;p&gt;我现在的实践是（我们团队对单元测试没要求），要写用例就用多种assert努力体现完备的功能要求，写不出|懒不想写就干脆不写。
编写完功能代码，针对其中我认为的“复杂(变成自动机它中间状态比较多)”方法
（相对的是“惰性”的一目了然的方法：简单的异常处理，类似构造器的接参数builder方法&amp;hellip;）
写单元测试（简单的边界，null，正常），不在意覆盖率，单纯地“为了当前开发而测试”，如果能方便到以后的重构就更好啦。
（不要和“编程为了长远，只是运行刚好满足于现在的需求”准则弄混，那是描述功能设计而不是单元测试的准则。）&lt;/p&gt;
&lt;h2 id=&#34;2021-04-30更新&#34;&gt;2021-04-30更新&lt;/h2&gt;
&lt;p&gt;说实话，3月时我写下上面的补丁的内容，以提供反面的观点，但心中仍留有疑惑：
我到底该对TDD持有怎样的态度？我该如何使用其中好的思想并避开麻烦的实践过程？
《程序员修炼之道(第2版)》中谈到的关于测试的观点让我倍受启发，
我忍不住大段大段地把内容抄写在这里，以弥补与融合上面两部分中对TDD的支持与反对的观点，使之形成整体的观点。
因抄写字数太多，我不会使用格式标记抄写的段落，反过来，下面我说的话会使用&lt;em&gt;斜体&lt;/em&gt;标记。
有时会抄写原文，有时会把原本不同位置的表达同概念的单句组合在一起，有时改写难以理解的表达，
省略描述书中举例，我尽量将书中的想表达的观点呈现出来。
当然，推荐你找到本书并从“&lt;strong&gt;第7章-41节-为编码测试&lt;/strong&gt;”开始阅读原文，这书没阅读门槛，很值得一读。
嗯，版权问题&amp;hellip;&amp;hellip;我想两位作者不会因为这个来找我的，我们都想让更多人了解到更务实的工作方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;41-为编码测试&#34;&gt;41 为编码测试&lt;/h3&gt;
&lt;p&gt;我们认为“为了找bug|确保代码工作正常而编写测试”是错误的观点。&lt;/p&gt;
&lt;h4 id=&#34;提示66-测试与找bug无关&#34;&gt;提示66 测试与找bug无关&lt;/h4&gt;
&lt;p&gt;我们相信，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是运行它的时候。
当你开始编写新功能，你不知道怎么去写业务逻辑，这时可以提前考虑一下测试：
假设你已经写完了业务逻辑，准备补单元测试了。
&lt;em&gt;想想你要怎么测试业务逻辑？怎么划分每个测试方法的范围？你的代码需要注入什么依赖模块来模拟真实环境？能够控制哪些依赖模块以模拟不同情况？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从考虑测试开始，在不写一行代码的情况下，你已经有了对业务逻辑每个公开方法的方法签名（API）要求的发现，并设计了API。
考虑测试使我们减少了代码中的耦合
（与其他代码紧耦合的函数或方法很难进行测试，因为你必须在运行方法之前设置（&lt;em&gt;mock&lt;/em&gt;）好所有环境，让你的东西可测试也减少了它的耦合），
并增加了灵活性（&lt;em&gt;我们想在测试时自由地控制依赖模块来模拟不同情况，这要求业务逻辑的API所接受的参数范围要广&lt;/em&gt;）。
为公开方法写测试的考虑过程， 使我们得以从外部看待这个方法，这让我们看起来是方法的客户（&lt;em&gt;调用者&lt;/em&gt;）而不是作者。&lt;/p&gt;
&lt;h4 id=&#34;提示67-测试是代码的第一个用户&#34;&gt;提示67 测试是代码的第一个用户&lt;/h4&gt;
&lt;p&gt;我们认为，“&lt;strong&gt;测试所提供的反馈至关重要，可以指导编码过程&lt;/strong&gt;”，这是测试的最大好处。
在你对一个东西做测试前，必须先理解它在干嘛。
现实中我们刚开始编写代码时，只能基于对必须要做的事的模糊理解，&lt;em&gt;边写边理解边解决新出现的要求（错误处理，边界，isNull etc）&lt;/em&gt;，
最后代码总量比真正干事的逻辑大好几倍，里面充斥了条件逻辑与错误处理。&lt;em&gt;这时再写测试就不好分辨整个代码真正在干什么了。&lt;/em&gt;
如果你在开始编码前，就考虑过测试边界条件及其工作方式（&lt;em&gt;不同情况的分类处理&lt;/em&gt;），&lt;em&gt;那么你可能会发现简化条件逻辑的方案&lt;/em&gt;。
如果考虑需要测试的引发错误的条件，&lt;em&gt;那么你将会有意构造对应的错误处理逻辑&lt;/em&gt;。&lt;/p&gt;
&lt;h5 id=&#34;测试驱动开发&#34;&gt;测试驱动开发&lt;/h5&gt;
&lt;p&gt;我们看到TDD的好处，只要遵守流程，代码始终都有测试，你也将一直处于思考测试的状态。
我们也看到人们成为TDD的奴隶：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花费过多时间确保100%测试覆盖率&lt;/li&gt;
&lt;li&gt;做了很多冗余（&lt;em&gt;无用&lt;/em&gt;）的测试 
（&lt;em&gt;书中举例：刚开始编写方法时，对一个特定测试值（这是从特例到公式的必要一步TDD步骤）， 编写之后显著会重复|重写的AD-HOC逻辑&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;TDD的设计从底层开始，然后逐步上升。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;tdd你需要知道该去何方&#34;&gt;TDD：你需要知道该去何方。&lt;/h5&gt;
&lt;p&gt;“小步前行”被吹捧为TDD的一个优点，但这可能会误导你，它鼓励人们专注于不断优化简单的问题，而忽略编码的真正动因（&lt;em&gt;解决需求！&lt;/em&gt;）。
&lt;em&gt;书中案例：罗恩·杰弗里斯的数独程序系列博客，进行多次重构后满意，最终放弃了项目。&lt;/em&gt;
按顺序阅读博客很有趣，可以看到一个聪明人是如何被通过测试的喜悦套牢，开始为琐事（&lt;em&gt;不断想着重构&lt;/em&gt;）而分心。&lt;/p&gt;
&lt;h4 id=&#34;提示68-既非自上而下也非自下而上基于端对端构建程序&#34;&gt;提示68 既非自上而下，也非自下而上，基于端对端构建程序&lt;/h4&gt;
&lt;h5 id=&#34;自上而下与自下而上之争以你该用的方式去做&#34;&gt;自上而下与自下而上之争，以你该用的方式去做&lt;/h5&gt;
&lt;p&gt;计算机领域初期有两种程序设计学派：自上而下与自下而上。
但两个学派都没成功，因为它们都忽略了：刚开始（&lt;em&gt;即设计阶段&lt;/em&gt;）没人知道要做什么。
自上而下要求提前知晓需求，这不可能。
自下而上假设从小到大构造抽象层最终实现需求，但不知需求就无法划分功能边界。&lt;/p&gt;
&lt;p&gt;我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。
应用学到的知识充实代码，让客户参与每一步并让他们指导这个过程。
测试对开发的驱动绝对有帮助，但是，就像每次开车一样，除非心里有一个目的地，
否则就可能到处兜圈子。&lt;/p&gt;
&lt;h4 id=&#34;提示70-要对软件做测试否则只能留给用户去做&#34;&gt;提示70 要对软件做测试，否则只能留给用户去做&lt;/h4&gt;
&lt;p&gt;毫无疑问测试是编程的一部分，不该留给其他部门的人去做（&lt;em&gt;测试部门算其他部门吗？&lt;/em&gt;）。
测试、设计、编码————都是在编程。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好了，抄完了，你应该能读到两位作者的心思：按照TDD的思路在编码前考虑测试有好处，但并不是必须要遵守TDD流程来实践才能获得这个好处。
那么我再抄一段作者在书中的调侃作为本次补丁的结尾吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;忏悔&lt;/p&gt;
&lt;p&gt;我，Dave，因告诉别人自己不再编写测试，而大出风头。这样做的部分原因是想动摇那些把测试变成宗教的人的信仰。
这样说的部分原因是，这（某种程度上）是真的。&lt;/p&gt;
&lt;p&gt;我已经编写了45年的代码，30多年中我都写了自动化测试。构思写测试，已经成了我编码方式的一部分&amp;hellip;
我决定停止编写测试几个月，看看代码会出什么事。令人惊讶的是，影响“不是很大”，我花了一些时间来找出原因。&lt;/p&gt;
&lt;p&gt;我相信这个原因是，（对我来说）测试的好处更主要来自思考测试，以及思考测试对对代码造成的影响。
在长时间坚持这么做后，我写不写测试都会这样思考。代码仍是可测试的，只是无须真的写出来测试。&lt;/p&gt;
&lt;p&gt;&amp;hellip;测试也是与其他开发人员交流的一种方式，所以我开始会在与他人共享代码时为其编写测试，或给有外部依赖的事情写测试。&lt;/p&gt;
&lt;p&gt;Andy说我不应该加上这个知识栏，他担心这会诱使缺乏经验的开发人员不写测试。下面是我的折衷方案：&lt;/p&gt;
&lt;p&gt;应该编写测试吗？要，但等你写了30年后，不妨从容地做些实验，看看它究竟给你带来的什么好处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;https://en.wikipedia.org/wiki/Test-driven_development&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&#34;&gt;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&#34;&gt;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&#34;&gt;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips/#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/unit-test/">unit-test</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Java实现大整数排列组合，解决抽卡欧气计算问题</title>
                <link>https://boholder.github.io/blogs/java-arrangement-combination/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/java-arrangement-combination/</guid>
                <pubDate>Sat, 27 Jul 2019 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近玩的某游戏开了新卡池，抽了8个10连共计80次，&lt;br&gt;
出了4个稀有度最高的角色，&lt;br&gt;
我突发奇想想算算我这个爆率算什么水平，&lt;br&gt;
程序模拟一下，顺便复习排列组合。&lt;/p&gt;
&lt;h2 id=&#34;程序设计&#34;&gt;程序设计&lt;/h2&gt;
&lt;p&gt;Java标准类库中，没有排列组合甚至阶乘的现成方法，  &lt;a href=&#34;https://stackoverflow.com/questions/891031/is-there-a-method-that-calculates-a-factorial-in-java&#34;&gt;搜了一下&lt;/a&gt;&lt;br&gt;
但为了这个引入一个第三方库又未免太麻烦，于是自己来实现。&lt;/p&gt;
&lt;p&gt;实现第一想到的是int和long两个基本类型，&lt;a href=&#34;https://www.iteye.com/blog/ly5633-1219408&#34;&gt;但想了想发现有坑&lt;/a&gt; ：int最多12！，long最多到20！&lt;br&gt;
这可不行，我这都80抽了。&lt;br&gt;
于是换Java的BigDecimal类（大整数）。&lt;/p&gt;
&lt;p&gt;问题换算成伪代码是这样：&lt;br&gt;
res=0&lt;br&gt;
res += c(n, i) *  爆率^i *  (1 - a)^(n-i) 	(i=a~b,i为整数)&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
import java.math.BigDecimal;

public class factorial {

	public static void main(String[] args) {

		// 出货率2.5%
		double a = 0.025d;
		int n = 80;
		// result
		double res = 0;
		double res2 = 0;

		for (int i = 0; i &amp;lt; 5; i++) {
			res2 += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;0~4: &amp;quot; + res2);

		for (int i = 4; i &amp;lt; n + 1; i++) {
			res += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;4~80: &amp;quot; + res);
	}

	// n!
	public static BigDecimal n(int n) {
		if (n == 0)
			return new BigDecimal(0);

		BigDecimal result = new BigDecimal(1);
		BigDecimal a;
		for (int i = 2; i &amp;lt; n + 1; i++) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/m!
	public static BigDecimal n2m(int n, int m) {

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/(n-m)! === a(n,m)
	public static BigDecimal a(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; n - m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// c(n,m) === a(n,m)/(m)!
	public static BigDecimal c(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);
		if (m == n)
			return new BigDecimal(1);

		// 优化计算，避免大除大
		if (m &amp;gt; n / 2)
			return n2m(n, m).divide(n(n - m));
		else
			return a(n, m).divide(n(m));
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;结果结论&#34;&gt;结果&amp;amp;结论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0~4:  0.8176930694561881&lt;/li&gt;
&lt;li&gt;4~80:  0.14056818112756556&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽80次，出0~4次货的概率 高达94.9%、&lt;br&gt;
出4次及以上的概率为 14%，其中出4次占9%&lt;br&gt;
这样一看我还行，乐上加乐，没钱人的开心就是这么简单。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/java/">java</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>自制notepad&#43;&#43;，MarkDown(Obsidian配色)用户定义语言格式（自定义高亮）</title>
                <link>https://boholder.github.io/blogs/markdown-obsidian-user-defined-language-for-notepadpp/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/markdown-obsidian-user-defined-language-for-notepadpp/</guid>
                <pubDate>Wed, 22 May 2019 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近我开始用 Notepad++ 配合这个很棒的插件 &lt;a href=&#34;https://github.com/nea/MarkdownViewerPlusPlus&#34;&gt;MarkdownViewerPlusPlus&lt;/a&gt;  写markdown文件。有个插件在用户定义语言中给我提供了一个Markdown语法高亮，可惜它是配合亮IDE主题使用的，在我的背景色下表现很糟。因此我基于黑曜石配色（Obsidian）和原来的高亮做了一个暗色用户定义语言。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.notepad-plus-plus.org/index.php/User_Defined_Languages&#34;&gt;Nppp Official doc: User Defined Languages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ivan-radic.github.io/udl-documentation/&#34;&gt;UDL documentation site&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;
&lt;p&gt;高亮Markdown语法标签。&lt;/p&gt;
&lt;p&gt;&amp;lt;!&amp;mdash;-&amp;gt; http comment, # 标题粗体.&lt;/p&gt;
&lt;h2 id=&#34;导入与使用&#34;&gt;导入与使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/share/Markdown-Obsidian-theme-lan-format-for-notepadpp2.1.xml&#34;&gt;下载该xml文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;打开 notepad++, select Menubar -&amp;gt; Language -&amp;gt; User Defined Languages&lt;/li&gt;
&lt;li&gt;打开左上的 &amp;ldquo;import&amp;rdquo; 选项, 导入该文件。
如果导入成功，notepad++ 会弹出提示框。&lt;/li&gt;
&lt;li&gt;重启 notepad++, 打开一个 markdown 文件(.md) 并享受。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://boholder.github.io/img/postimg/2019/notepadpp-markdown-show.png&#34; alt=&#34;example image&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/design/">design</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/ide/">IDE</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>HTTP cookie的安全性、安全使用方法和攻击防御手段</title>
                <link>https://boholder.github.io/blogs/cookie_security/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/cookie_security/</guid>
                <pubDate>Sat, 18 May 2019 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文将把，截至2019-05-18的，从互联网上搜集到&lt;/p&gt;
&lt;p&gt;（&amp;ldquo;cookie+security&amp;rdquo;-&amp;gt;Google与StartPage前两页结果为源+相关学术文献）的,&lt;br&gt;
有关Cookie标准与用法、cookie安全性的信息，汇总索引，以方便读者学习了解相关信息。&lt;/p&gt;
&lt;p&gt;本文需要读者对计算机网络有大致了解，&lt;br&gt;
没有了解也可以，术语会挂上解释链接，但阅读体验就比较差了。&lt;/p&gt;
&lt;p&gt;小段英文的翻译交给谷歌处理。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;2部分与3部分的解决方案部分有重复，&lt;br&gt;
但我认为还是把攻防和开发分开，缺陷与解决结合，比较方便阅读。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security/#what-is-cookie&#34;&gt;Cookie是什么&amp;amp;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security/#security-risk-in-design-and-use-and-solution&#34;&gt;设计、使用中的安全隐患以及相应改进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security/#attack-on-cookies-and-solution&#34;&gt;针对cookie窃取的攻击与相应防御&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security/#academic-discussion-about-cookies&#34;&gt;学术讨论涉及cookie的攻防&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security/#summary&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;what-is-cookie&#34;&gt;What is cookie&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.Cookie是什么&amp;amp;用法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34;&gt;维基百科&lt;/a&gt; 还是蛮丰富的，中文维基简单点，可以看&lt;a href=&#34;https://baike.baidu.com/item/cookie/1119&#34;&gt;百度百科&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RFC：&lt;a href=&#34;https://tools.ietf.org/html/rfc2109&#34;&gt;rfc2109-1997&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc2965&#34;&gt;rfc2965-2000&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc6265&#34;&gt;rfc6265-2011&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-httpbis-rfc6265bis/&#34;&gt;rfc6265bis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&#34;&gt;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在最新的定义cookie的RFC2965上，是这么说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;we will use the term cookie to refer to the state&lt;br&gt;
information that passes between an origin server and user agent,&lt;br&gt;
and that gets stored by the user agent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将使用术语cookie来指代在源服务器和用户代理之间传递的状态信息，&lt;br&gt;
以及由用户代理存储的状态信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单总结，cookie是：服务器与客户端间标识状态的信息，储存在客户端&lt;br&gt;
（硬盘或内存，视类型而定），由服务器增删改读。&lt;br&gt;
用途：满足对无状态的HTTP协议，想让它&lt;strong&gt;有状态&lt;/strong&gt;的需求，一种修补措施。&lt;/p&gt;
&lt;p&gt;比如一个服务器，需要同时与多个客户端通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为HTTP协议@的无连接性，所以需要一个额外方法区分不同客户端。&lt;/li&gt;
&lt;li&gt;然后因为计算机网络的网络层路由有&lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR-无类域间路由&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation&#34;&gt;NAT-网络地址转换&lt;/a&gt; 这类协议存在，&lt;br&gt;
服务器不能单靠记录IP或者MAC这些HTTP包里的信息标识每一个客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此Netscape Draft在1994年率先定义了cookie这一解决方案&lt;br&gt;
（此处apache.org的原文链接好像失效了），之后被整理成rfc2109。&lt;/p&gt;
&lt;p&gt;cookie可以用来干什么？&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Uses&#34;&gt;维基&lt;/a&gt; 给了三个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会话管理&lt;/li&gt;
&lt;li&gt;个性化定制 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zombie_cookie&#34;&gt;wikipedia-Zombie cookie （有点意思）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;格式用法&#34;&gt;格式&amp;amp;用法&lt;/h3&gt;
&lt;p&gt;一个cookie由一个键值对（key=value）组成，同时在&lt;em&gt;被设置时&lt;/em&gt; 会附加一些变量（attributes），&lt;br&gt;
这些变量用来控制该cookie的使用方法。&lt;/p&gt;
&lt;p&gt;想了解详细属性，看&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt; ，&lt;br&gt;
找不到新鲜的全面的中文材料，有个不错的&lt;a href=&#34;https://imququ.com/post/host-only-cookie.html#toc-3&#34;&gt;博客@Jerry Qu&lt;/a&gt; ，但是是13年的。&lt;/p&gt;
&lt;p&gt;比如，我们时常听闻的第三方cookie，在设置时会标一个&lt;code&gt;Third-party&lt;/code&gt;属性，&lt;br&gt;
表明这是从非当前网站（URL框里的网站）设置的。&lt;/p&gt;
&lt;p&gt;当一个网站有引用（&amp;lt;img&amp;gt;&amp;hellip;）其他网站，比如广告网站的广告资源时，&lt;br&gt;
浏览器加载该网站时，也会向广告网站发GET请求，&lt;br&gt;
第三方cookie就随着资源一起来到了浏览器上。&lt;/p&gt;
&lt;p&gt;对cookie的操作不再赘述，有需请自取。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&#34;&gt;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2&#34;&gt;https://tools.ietf.org/html/rfc6265#section-4.2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;security-risk-in-design-and-use-and-solution&#34;&gt;Security risk in design and use and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.Cookie设计与使用中的安全隐患，以及相应改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie安全性这点，&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-8&#34;&gt;rfc6265中有一整段(8. Security Considerations)&lt;/a&gt; 去阐述，&lt;br&gt;
务必读一下，总结的很好，我会跳过那些内容，只给出一个目录以供预览。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分标题&lt;/th&gt;
&lt;th&gt;简述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Overview&lt;/td&gt;
&lt;td&gt;总览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ambient Authority&lt;/td&gt;
&lt;td&gt;cookie是一种权限凭证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clear Text&lt;/td&gt;
&lt;td&gt;明文传输问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Session Identifiers&lt;/td&gt;
&lt;td&gt;非可读的会话标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Weak Confidentiality&lt;/td&gt;
&lt;td&gt;cookie在各种层面保密性都弱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reliance on DNS&lt;/td&gt;
&lt;td&gt;cookie的安全性以DNS安全为前提&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;与其说其设计不周全，不如说cookie因本身位置的限制无法保证设计安全，&lt;br&gt;
rfc还警告开发人员不要把cookie作为唯一的认证环节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265: In addition, by default, cookies do not provide confidentiality or integrity&lt;br&gt;
from network attackers, even when used in conjunction with HTTPS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此外，默认情况下，cookie不会为网络攻击者提供机密性或完整性，&lt;br&gt;
即使与HTTPS结合使用也是如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1服务器只能读取cookie键值对读不到属性&#34;&gt;1.服务器只能读取cookie键值对，读不到属性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
Notice that the cookie attributes are not returned.&lt;br&gt;
In particular,the server cannot determine from the Cookie header alone&lt;br&gt;
when a cookie will expire, for which hosts the cookie is valid,&lt;br&gt;
for which paths the cookie is valid, 
or whether the cookie was set with the Secure or HttpOnly attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
请注意，不返回cookie属性。特别是，当cookie过期时，&lt;br&gt;
服务器无法单独从Cookie标头确定，cookie对哪些主机有效，cookie的路径有效，&lt;br&gt;
或者cookie是否使用Secure或HttpOnly属性设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时在设置cookie时，客户端并不会发回结果反馈。这使得服务器不知道cookie是否被正确设置。&lt;br&gt;
这等于要从数据库读一个不知道是否干净的数据，对数据完整性有影响。&lt;/p&gt;
&lt;h4 id=&#34;解决服务器容错与键名走私smuggle&#34;&gt;解决：服务器容错与键名“走私（Smuggle）”&lt;/h4&gt;
&lt;p&gt;大多数情况下，可以用服务器逻辑容错。&lt;br&gt;
&lt;a href=&#34;https://www.owasp.org/images/a/a0/OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf&#34;&gt;OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson&lt;/a&gt;&lt;br&gt;
此报告提供了在cookie名里添加“私货”以标识属性的方法，&lt;br&gt;
比如一个cookie设置了属性&lt;code&gt;http-only&lt;/code&gt;，名字就加个前缀HTTP_ONLY_。&lt;/p&gt;
&lt;h3 id=&#34;2-domainpath属性影响完整性&#34;&gt;2. “Domain”“Path”属性影响完整性&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.3&#34;&gt;rfc6265-两个属性的设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.1.2&#34;&gt;rfc6265-两个属性在客户端的处理算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不贴原文了，简单地总结（参照维基）：&lt;/p&gt;
&lt;h4 id=&#34;path-是指域名host下的路径归属&#34;&gt;&lt;code&gt;Path&lt;/code&gt; 是指域名|Host下的路径归属。&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;比如两网站&lt;code&gt;example.com/site1/index.htm&lt;/code&gt;,&lt;code&gt;example/com/site2/index.htm&lt;/code&gt;，&lt;br&gt;
设置Path属性为&lt;code&gt;/site1&lt;/code&gt;,&lt;code&gt;/site2&lt;/code&gt;两个值以分离两个目录中的页面的cookie。&lt;/li&gt;
&lt;li&gt;有些网站的不同目录是运行不同功能的，比如两个朋友共租一个域名运营博客，用上述方式划分。&lt;br&gt;
通过这种方式可以做到分离两个博客的cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来很好，但稍有不慎（或故意为之），就可以用来绕过&lt;a href=&#34;https://en.wikipedia.org/wiki/Same-origin_policy&#34;&gt;SOE-同源策略&lt;/a&gt; 。&lt;br&gt;
比如，设置path成&lt;code&gt;/&lt;/code&gt;，好，域名下所有页面都能读该cookie了。&lt;/p&gt;
&lt;p&gt;这是一种减少网站开发人员工作量的窍门，也能被攻击者用来做窃取cookie的手段。&lt;/p&gt;
&lt;h4 id=&#34;domain-是指域名归属&#34;&gt;&lt;code&gt;Domain&lt;/code&gt; 是指域名归属。&lt;/h4&gt;
&lt;p&gt;它和&lt;code&gt;Path&lt;/code&gt;属性的缺点差不多类型，设置了&lt;code&gt;Domain&lt;/code&gt;的cookie是&lt;strong&gt;默认暴露给所有子域名&lt;/strong&gt;的。&lt;br&gt;
我们都知道，同域名不一定等于同服务器IP，所以攻击者可以劫持域名解析偷cookie。 &lt;br&gt;
因为这个原因，实际开发中一般不建议设置&lt;code&gt;Domain&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4 id=&#34;解决samesite-属性2016年不设置domain属性&#34;&gt;解决：&lt;code&gt;SameSite&lt;/code&gt; 属性(2016年)&amp;amp;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h4&gt;
&lt;h5 id=&#34;samesite&#34;&gt;&lt;code&gt;SameSite&lt;/code&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Same-site_cookie&#34;&gt;维基#Same-site_cookie&lt;/a&gt;:&lt;br&gt;
In 2016 Google Chrome version 51 introduced a new kind of cookie, the same-site cookie,&lt;br&gt;
which can only be sent in requests originating from the same origin as the target domain.&lt;br&gt;
This restriction mitigates attacks such as cross-site request forgery (XSRF).&lt;br&gt;
A cookie is given this characteristic by setting the SameSite flag to Strict or Lax.&lt;br&gt;
&lt;a href=&#34;https://tools.ietf.org/html/draft-west-first-party-cookies-07&#34;&gt;google：draft-ietf-httpbis-cookie-same-site &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年，谷歌Chrome版本51引入了一种新型cookie，即同一站点的cookie，&lt;br&gt;
只能在源自与目标域相同的源的请求中发送。此限制可缓解诸如跨站点请求伪造（XSRF）等攻击。&lt;br&gt;
通过将SameSite标志设置为Strict或Lax，可以为cookie提供此特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标准支持：截至撰文时间(2019-05)，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发支持：查到的是node.js的express、PHP7.3支持，应该还有没搜到的&lt;/li&gt;
&lt;li&gt;浏览器支持：几个主流浏览器，的新版本都已支持，不再列举名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lambdatest.com/SameSite-cookie-attribute&#34;&gt;Browser Compatibility Testing of &amp;lsquo;SameSite&amp;rsquo; cookie - LambdaTest&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;不设置domain属性&#34;&gt;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/12387338/what-is-a-host-only-cookie&#34;&gt;Stack over flow-What is a host only cookie?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之所以不设置&lt;code&gt;Domain&lt;/code&gt;属性，其实是为了激活&lt;code&gt;host-only-flag&lt;/code&gt;，&lt;br&gt;
&lt;strong&gt;当host-only-flag被设置，子域名无法访问此cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.3&#34;&gt;rfc6265-5.3.  Storage Model&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3对cookie的误用&#34;&gt;3.对cookie的误用&lt;/h3&gt;
&lt;p&gt;上面算是设计问题，下面是多数文章主要讲的，开发者对cookie的误用。&lt;/p&gt;
&lt;h4 id=&#34;http-明文传递-cookie&#34;&gt;①http 明文传递 cookie&lt;/h4&gt;
&lt;p&gt;cookie默认不加密传输，可以在传输中被坏家伙窃听或修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：设置&lt;code&gt; Secure&lt;/code&gt;属性&amp;amp;cookie加密和签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.5&#34;&gt;rfc6265-5.2.5.  The Secure Attribute&lt;/a&gt;&lt;br&gt;
&lt;code&gt;Secure&lt;/code&gt;属性保证cookie只在HTTPS环境下可被传输。&lt;/p&gt;
&lt;p&gt;和数据库设计一样，为了保险，应尽量减少数据中非必须的信息量。&lt;br&gt;
cookie值可以是随机生成的字符串（会话凭证）而不是具体信息，&lt;br&gt;
在下次登录时修改，以应对cookie窃取与重放攻击。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265:&lt;br&gt;
Servers SHOULD encrypt and sign the contents of cookies&lt;br&gt;
(using whatever format the server desires) when transmitting them to the&lt;br&gt;
user agent (even when sending the cookies over a secure channel).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当将服务器传输给用户代理时，服务器应该对cookie的内容进行加密和签名&lt;br&gt;
（使用服务器所需的任何格式）（即使通过安全通道发送cookie）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;cookie-默认可被客户端apijs-etc读取&#34;&gt;②cookie 默认可被客户端API(JS etc)读取&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;解决：设置时加 &lt;code&gt;Http-only-flag&lt;/code&gt; ，禁止客户端JS读取cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;错误规划max-ageexpires&#34;&gt;③错误规划&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准太长，简单总结：&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt;: 类似TTL，以秒计，到时删除。&lt;br&gt;
&lt;code&gt;expires&lt;/code&gt;: GMT时间字符串（Wed, 09 Jun 2021 10:18:14 GMT）,到时删除。&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt; 是 &lt;code&gt;expires&lt;/code&gt; 的一个补充性属性。没有这两个属性，cookie被视为&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Session_cookie&#34;&gt;session cookie&lt;/a&gt; 。&lt;br&gt;
cookie保留在客户端的时间越长，被攻击的可能性越高。&lt;/p&gt;
&lt;h4 id=&#34;解决谨慎设计max-ageexpires的值&#34;&gt;解决：谨慎设计&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;的值&lt;/h4&gt;
&lt;p&gt;越敏感的数据，越要设置时间短，保持用户频繁认证。&lt;/p&gt;
&lt;h2 id=&#34;attack-on-cookies-and-solution&#34;&gt;Attack on cookies and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.针对cookie窃取的攻击与相应防御&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下所有攻击手段，都能单独拉出来写好多篇技术报告|分享，&lt;br&gt;
很明显本文没有这个篇幅，因此本文征求做到全而不详，并附链接以供详求。&lt;/p&gt;
&lt;h3 id=&#34;为什么我们要攻击保护cookie&#34;&gt;为什么我们要攻击|保护cookie？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://odino.org/security-hardening-http-cookies/&#34;&gt;这篇文章&lt;/a&gt; 的一段话讲得不错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Because the data they contain is, more often than not, extremely sensitive&lt;br&gt;
— cookies are generally used to store session IDs or access tokens,&lt;br&gt;
an attacker’s holy grail.&lt;br&gt;
Once they are exposed or compromised, attackers can impersonate users,&lt;br&gt;
or escalate their privileges on your application.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为它们包含的数据通常非常敏感 - 通常用于存储会话ID或访问令牌，攻击者的圣杯。&lt;br&gt;
一旦他们暴露或受到攻击，攻击者就可以冒充用户，或者升级他们对您的应用程序的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常见攻击方式&#34;&gt;常见攻击方式&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Cookie_theft_and_session_hijacking&#34;&gt;维基百科&lt;/a&gt;总结了几种常见的攻击方式，包括攻击过程简介与防御手段，在此不复述，只提供目录。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;攻击&lt;/th&gt;
&lt;th&gt;防御&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MITM&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DNS Poisoning&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOM-Based-XSS&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http-only-flag&lt;/code&gt;&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反射型XSS+恶意代理服务器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;secure&lt;/code&gt;attr&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSRF&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;还有一类维基没提到的，针对&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS协议&lt;/a&gt; 的攻击。&lt;br&gt;
TLS协议不是完全安全的，因为设计或实现的缺陷，&lt;br&gt;
已有不少在特定情况下针对TLS的攻击出现，&lt;br&gt;
主要目的是使HTTPS降为“等同于”HTTP的情况（即复原密文为明文），&lt;br&gt;
这不是一个新方向，列举几个比较有名的攻击方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.contextis.com/en/blog/server-technologies-https-beast-attack&#34;&gt;BEAST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lucky_Thirteen_attack&#34;&gt;Lucky 13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非常见方式&#34;&gt;非常见方式&lt;/h3&gt;
&lt;p&gt;非单一的、利用知识组合各种部分的针对cookie的攻击方式，&lt;br&gt;
可惜我只找到一个。&lt;/p&gt;
&lt;h4 id=&#34;cookiejacking-rosario-valotta-2011-05linkhttpssitesgooglecomsitetentacoloviolacookiejacking&#34;&gt;①cookiejacking-Rosario Valotta-2011-05&lt;a href=&#34;https://sites.google.com/site/tentacoloviola/cookiejacking&#34;&gt;[link]&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;该方法利用了IE浏览器的“跨域交互策略”的一个漏洞，&lt;br&gt;
外部HTML的&amp;lt;iframe&amp;gt;标签可以加载本地cookie文件（本应不能）。&lt;br&gt;
恶意服务器通过一系列正常的手段获知用于构造cookie路径的信息，&lt;br&gt;
然后通过此漏洞读取cookie，并利用&lt;a href=&#34;https://www.securitysift.com/who-do-you-trust-cross-domain-content-extraction-with-clickjacking/&#34;&gt;Clickjacking&lt;/a&gt; 手段传输cookie至服务器。&lt;br&gt;
因为读的是文件，任何cookie都会被窃取。&lt;/p&gt;
&lt;p&gt;微软&lt;a href=&#34;https://digitizor.com/cookiejacking-patch/&#34;&gt;6月&lt;/a&gt; 给这个漏洞打了补丁。&lt;br&gt;
至于Clickjacking，&lt;code&gt;x-frame-options&lt;/code&gt;&lt;a href=&#34;https://www.keycdn.com/blog/x-frame-options&#34;&gt;(XFO)&lt;/a&gt; 可以防止。&lt;/p&gt;
&lt;h2 id=&#34;academic-discussion-about-cookies&#34;&gt;Academic discussion about cookies&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于cookie的学术讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本来想把理论方面作为2、3段的添头，没想到专家们已经在纸头上打过一两轮攻防了。&lt;br&gt;
故单开此段，索引几个我觉得有意思的学术文献。&lt;/p&gt;
&lt;h3 id=&#34;cookie-masking-cookie-掩盖&#34;&gt;cookie masking-cookie 掩盖&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=2714592&#34;&gt;TLS Record Protocol: Security Analysis and&lt;br&gt;
Defense-in-depth Countermeasures for HTTPS&lt;/a&gt;&lt;br&gt;
Author: Olivier Levillain etc&lt;br&gt;
Time: 2015&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个研究总结了针对TLS记录协议的5个攻击方式，并给出了两个cookie掩盖方式：&lt;br&gt;
TLS Scramble &amp;amp; MCookies，以保证在意外导致HTTP明文传输的情况下，&lt;br&gt;
继续保持cookie等秘密信息机密性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/article/10.1007%2Fs12095-018-0280-y&#34;&gt;Statistical attacks on cookie masking for RC4&lt;/a&gt;&lt;br&gt;
Author: Kenneth G. PatersonEmail author etc&lt;br&gt;
Time: 2018-02&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文验证了上篇文章两种掩盖方式理论上可被加大提供算力后破解，&lt;br&gt;
因此该掩盖方式只能提供不强的机密性。&lt;/p&gt;
&lt;h3 id=&#34;测信道攻击&#34;&gt;测信道攻击&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-319-89641-0_11&#34;&gt;Path Leaks of HTTPS Side-Channel by Cookie Injection&lt;/a&gt;&lt;br&gt;
Author: Fuqing Chen etc&lt;br&gt;
Time: 2018-04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文阐述了一种攻击方式和两种应用方面：&lt;br&gt;
利用cookie的弱同源策略（上文有提），实施cookie注入，&lt;br&gt;
用注入的cookie来推断敏感信息，进而复原一部分密文（比如请求的URL）。&lt;br&gt;
没看完，大概是利用当时浏览器的cookie路径匹配的算法的一个缺陷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-662-47854-7_6&#34;&gt;Protecting Encrypted Cookies from&lt;br&gt;
Compression Side-Channel Attacks&lt;/a&gt;&lt;br&gt;
Author: Janaka Alawatugoda etc&lt;br&gt;
Time: 2015-07&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有那么两种对TLS的攻击：&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt; 和 &lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt; （上文有提）,&lt;br&gt;
它们基于传输前压缩过程中产生的额外信息量，复现敏感信息，&lt;br&gt;
针对它们的常规解决方法是禁止传输中压缩，&lt;br&gt;
这意味着加大使用带宽资源。&lt;br&gt;
该文阐述了两种新的压缩方式，用于实现压缩并保护机密信息的功能。&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，关于此文，不包括素材阅读的，纯搜索时间，大概只有2小时多，&lt;br&gt;
因此即使是截至2019-05，此文大概还是遗漏了许多值得一提的部分，请读者海涵。&lt;/p&gt;
&lt;p&gt;其次，经过编写此文，作者对cookie的认识有了很大变化，认清了cookie能力是很有限的，&lt;br&gt;
以后编写web服务也会注意cookie的正确运用。希望各位读者也能从此文中学到知识。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/computer-security/">computer-security</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/web-security/">web-security</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/cookie/">cookie</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://boholder.github.io/blogs/dear-to-step-into-the-underneath/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/dear-to-step-into-the-underneath/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://boholder.github.io/blogs/one-record-about-debuging-unkown-unkown/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/one-record-about-debuging-unkown-unkown/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
