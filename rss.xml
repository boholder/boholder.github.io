<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>BoHolder的网站：博客，小玩意及其他</title>
        <link>https://boholder.github.io/</link>
        <description>BoHolder&#39;s site: crafts, blogs etc</description>
        <generator>Hugo 0.81.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>bottleholder@anche.no (BoHolder)</managingEditor>
        
        
            <webMaster>bottleholder@anche.no (BoHolder)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
        
        <lastBuildDate>Mon, 27 Sep 2021 18:52:24 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://boholder.github.io/rss.xml" />
        
        
            <item>
                <title>编程所需要的东西</title>
                <link>https://boholder.github.io/blogs/what-you-need-for-programming-zh/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/what-you-need-for-programming-zh/</guid>
                <pubDate>Mon, 16 Aug 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文试图通过介绍编程工作中的部分技能和知识，帮助新进入程序员职业的朋友熟悉未来的工作。特别的，本文将额外提供以Java编程语言下的Spring框架开发Web应用后端逻辑的工作相关的介绍。&lt;/p&gt;
&lt;p&gt;因本文实在冗长，建议你结合目录挑选自己感兴趣的部分阅读。如果你想通过文本做跳板寻找优质学习资源，希望附录部分我精心挑选的网站和书籍推荐让你满意。&lt;/p&gt;
&lt;p&gt;对读者的要求：打算把程序员作为职业，还尚未入行的朋友。&lt;/p&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;h3 id=&#34;ide与文本编辑器&#34;&gt;IDE与文本编辑器&lt;/h3&gt;
&lt;p&gt;文件格式分两种，人能读懂的文本文件，和机器能读懂的二进制文件。源代码是文本文件。&lt;/p&gt;
&lt;p&gt;编程其实是在用文本编辑器（Text Editor）修改一个个文本文件（源代码文件）的内容，就像你用Windows记事本打开txt文件敲一些文字一样。理论上你可以用记事本写源码，实际上，有一些电脑达人们喜欢用Linux下的&lt;a href=&#34;https://www.vim.org&#34;&gt;Vim&lt;/a&gt;和&lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt;写源码，它们相当原始，但若用好快捷键与定制功能，它们会变得非常强大。&lt;/p&gt;
&lt;p&gt;虽然可以，但是你往往不想用记事本写代码，因为它们不是“专业写代码”的工具软件，用起来不顺手。你需要的是专业帮手——IDE。IDE全称&lt;a href=&#34;https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524&#34;&gt;集成开发环境（Integrated Development Environment）&lt;/a&gt;，是用于提供程序开发环境的应用程序，包括代码编辑器、编译器、调试器等工具，集成了代码编写、语法分析、编译、调试等额外功能。IDE本质上是一个挂载了许多协助编程的额外功能的文本编辑器。&lt;/p&gt;
&lt;p&gt;一款，你只需要选择并熟练使用一款文本编辑器，你便有了编写源代码的趁手工具。无所谓它是否属于IDE，自己喜欢就好，因为那些编译调试之类的工具大可以在文本编辑器外单独使用。不同文本编辑器的基本功能（即文本编辑功能）大同小异，我们在意的是附加的功能（或丰富的插件市场）、以及完备的快捷键集合（快捷键对程序员来说很重要，可以让我们手不离开键盘完成代码编写，时不时抓鼠标会减慢速度且打断思路）。&lt;/p&gt;
&lt;p&gt;我目前用了三款文本编辑器以适应不同需求。下面我给出一些我知晓的文本编辑器供你浏览，你也可以自行搜索&amp;quot;editor for programming&amp;quot;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.vim.org&#34;&gt;Vim&lt;/a&gt;和&lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt; 这两个文本编辑器很特殊，你可能会在任意一款热门编辑器上看到这两个编辑器的快捷键替换插件。它们的狂热用户们（也同样是业内的老前辈、扛把子们）不愿意因切换文本编辑器而学习新的快捷键，因为快捷键已经变成了某种肌肉记忆，很难改变。这时你应该注意到了，快捷键是某种门派一样的东西，同时学两套快捷键会形成冲突，你只能选一套并把它变成肌肉记忆。快捷键会伴你整个职业生涯，因此慎重选择你的文本编辑器（或者直接学这两款文本编辑器之一的快捷键）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轻量级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://notepad-plus-plus.org&#34;&gt;Notepad++&lt;/a&gt; 它有一些用户插件来提供额外功能。因为它的启动速度很快，我用它作为最轻量级的文本编辑器，用来临时记录或粘贴一些文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.sublimetext.com/&#34;&gt;Sublime Text&lt;/a&gt; 大概是和notepad++并列的一款轻量级文本编辑器，我没用过，我有一个朋友把它作为轻量编辑器使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中量级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;Visual Studio Code&lt;/a&gt; 简称vscode，中量级的全能文本编辑器（全能指什么编程语言都支持），有丰富的插件市场，你可以把它改造成编写任何编程语言的IDE。我最近发现自己修改格式化的配置文本文件的频率变高了，因此选择了它作为中量级的编辑器，用它阅读与修改markdown（现在正在用它写这篇文章）、json、toml、yaml等格式的文件。事实上许多前端开发者使用vscode作为编写经典前端代码（HTML+CSS+JavaScript）的IDE。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt; 大概是与vscode相对的中量级编辑器，还是我的那个朋友会用它，我个人并不了解，姑且列出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重量级（IDE）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://visualstudio.microsoft.com/&#34;&gt;Visual Studio&lt;/a&gt; 微软出品，商业产品，被戏称为宇宙第一IDE（但我没搜到原因）。据我所知可以编写.Net、C、C#、C++、Python、Android语言。体积超级大，启动超级慢，用起来&amp;hellip;我感觉不到好在哪里，可能我没有深度使用。有插件市场。当你看到安装界面中各种数据分析、机器学习等高大上的可选项时，你会感受到这IDE真的体现了微软一如既往的商业又专业的味道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/&#34;&gt;JetBrains IDEs&lt;/a&gt; JetBrains是一家公司，它旗下有诸多用于编写不同语言程序的IDE：IntelliJ IDEA，GoLand，PyCharm，WebStorm，RubyMine&amp;hellip;用来编写Java、Go、Python、JavaScript、Ruby等主流编程语言。这些IDE基本共用一套快捷键。有插件市场。我是JetBrains的忠实用户，因为我感觉JetBrains的IDE开发者们懂得开发者需要什么，产品中的小细节和功能体现着人性化的用心。我用JetBrains IDEs作为重量级编辑器，因为它们启动要好一会。我还选择了JetBrain IDEs快捷键“门派”，还在vscode上安装了&amp;quot;IntelliJ IDEA Keybindings&amp;quot;插件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/eclipseide/&#34;&gt;Eclipse IDE&lt;/a&gt; 开源的多编程语言IDE，有插件市场。因为它是开源的，有不少商业第三方定制化IDE都是基于它改造的。我在大学时一直用它编写Java和C++，真的很不错，直到我在实习时试着换了IntelliJ IDEA，之后再也没启动过它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/install&#34;&gt;Android Studio&lt;/a&gt; 谷歌出品，看名字就知道是编写安卓系统应用程序的IDE。我用过一点，只知道它因为时不时要连接谷歌的网站更新索引之类的什么东西，在国内想用它要配置好离线依赖。另外关于它有许多meme损它启动慢吃内存多，比如：我是安卓工程师，我每天早晨来公司先启动Android Studio，然后把咖啡壶放在机箱上煮咖啡，等我喝完整壶咖啡，我就可以开始工作了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/cn/xcode/ide/&#34;&gt;Xcode&lt;/a&gt; 这是苹果公司推出的编写苹果各产品上的应用（现在苹果产品有了共用芯片，只需编译出一种应用）的IDE，我没有用过，也没有用它的苹果开发者朋友，所以我不知道它怎么样。按照苹果一贯的风格，也许这个IDE很顺滑，搜了下也没找到太多说xcode本身不好用的抱怨。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;java-ide&#34;&gt;Java IDE&lt;/h4&gt;
&lt;p&gt;主流Java IDE有两款，&lt;a href=&#34;https://www.eclipse.org/eclipseide/&#34;&gt;Eclipse IDE&lt;/a&gt;和&lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;，而且从2018年开始，&lt;a href=&#34;https://visualstudio.microsoft.com/&#34;&gt;Visual Studio&lt;/a&gt;也能够（通过连接vscode）支持Java了。从上文你可以看出，我是属于IDEA派的。&lt;/p&gt;
&lt;p&gt;在我看来，Eclipse比不过IntelliJ IDEA的关键不在功能上，它快捷键和插件市场都很完备，甚至因为是开源的，所以你可以把它DIY成符合自己习惯的专属IDE。但它败也败在开源上：没有漂亮又符合人机交互理念的界面（这需要专业的UI设计师参与，而开源项目成员中往往只有程序员）；默认配置较不合适（可定制化和开箱即用不冲突，但需要认真琢磨出厂默认配置）&amp;hellip;细节，它败在了细节上，“The devil is in the detail”。&lt;/p&gt;
&lt;p&gt;截至撰文我已经快三年没有用过Eclipse了，因此不了解它的近况，也许你可以给它一个机会，试用一下？还有宇宙第一IDE&amp;hellip;也可以试一下，我猜配置会很麻烦。&lt;/p&gt;
&lt;p&gt;另外，如果你选择使用IDEA，IDEA从2016年开始内置了一个学习快捷键的插件Learn，可以看&lt;a href=&#34;https://blog.jetbrains.com/idea/2016/12/ide-features-trainer/&#34;&gt;这篇官方介绍&lt;/a&gt;学习如何使用。&lt;/p&gt;
&lt;h3 id=&#34;浏览器搜索引擎与搜索思维&#34;&gt;浏览器、搜索引擎与搜索思维&lt;/h3&gt;
&lt;h4 id=&#34;浏览器&#34;&gt;浏览器&lt;/h4&gt;
&lt;p&gt;你在用火狐（FireFox）浏览器吗？建议从Mozilla官网（https://www.mozilla.org/zh-CN/firefox/new/ ）下载，而非北京谋智火狐信息技术有限公司的网站（http://www.firefox.com.cn/ ），这两个的区别可以看&lt;a href=&#34;https://zhuanlan.zhihu.com/p/138034888&#34;&gt;此文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你必然已会使用浏览器和搜索引擎，我在此补充几个浏览器的别样用法，也许可以帮助你更好的使用浏览器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给PDF阅读材料加书签。现代浏览器内置了PDF阅读器，配合创建用读书笔记作为标题的书签，你可以为本地硬盘上的某个PDF格式的电子书建立自己的书签目录，方便以后连同互联网书签一同查阅。（遗留问题：那个PDF文件不方便随意更换位置，因为浏览器书签的地址是文件系统的路径）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件市场。主流浏览器都有自己的插件市场，你可以用插件让上网体验更好。值得一提的是&lt;a href=&#34;https://www.tampermonkey.net/&#34;&gt;Tampermonkey&lt;/a&gt;插件，它是JavaScript脚本管理器，有自己的脚本市场。你可以把脚本理解为轻量的插件，毕竟在浏览器中就是Js脚本在操作页面。通过Tampermonkey，你可以向某个网页中添加额外的脚本来实现额外功能，而浏览器插件可以为浏览器本身添加额外功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;书签功能。主流浏览器支持同时打开一个书签目录下的所有书签，这样你可以用一个目录来代表一个工作环境，需要时一键开启所有Tab。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器快捷键。页面内查找，Tab左右切换显示，将光标置入搜索栏、切换搜索所使用的搜索引擎&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索栏。主流浏览器的搜索栏可以同时搜索书签和历史记录或使用搜索引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;历史记录。历史记录很重要，虽然它会泄露隐私，但我从不清理它。只要有历史记录，我就能搜到曾经浏览过的网页，节省了重新搜索的时间。（如果我想进行隐私上网，我会打开虚拟机中的Tor浏览器&amp;hellip;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;搜索引擎&#34;&gt;搜索引擎&lt;/h4&gt;
&lt;p&gt;为什么我不使用百度？有几个原因，仅就编程方面的搜索来说，使用百度会搜索到大量&lt;a href=&#34;https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%86%9C%E5%9C%BA/6651503&#34;&gt;内容农场&lt;/a&gt;网站，浪费时间却找不到有用的信息。&lt;/p&gt;
&lt;p&gt;我使用微软的Bing（ &lt;a href=&#34;https://cn.bing.com/&#34;&gt;https://cn.bing.com/&lt;/a&gt; 这是国内特供版网址，Bing的通常网址是 &lt;a href=&#34;https://www.bing.com/&#34;&gt;https://www.bing.com/&lt;/a&gt; ，猜测微软是根据GeoIP来判断该重定向到哪一个网址）。Bing搜索引擎&lt;a href=&#34;https://help.bing.microsoft.com/apex/index/18/en-US/10002&#34;&gt;有一些简单的高级搜索语法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外Bing有两个版面：国内版和国际版，你可以简单理解为国内版搜索结果中的中文结果优先，而国际版是其他语言的结果优先。你可以轻松切换两个版面来实现同时搜索一个关键字的中文和英文搜索结果。就编程方面的搜索来说，你不能肯定一个问题在&lt;a href=&#34;https://www.csdn.net/&#34;&gt;CSDN&lt;/a&gt;或&lt;a href=&#34;https://www.cnblogs.com/&#34;&gt;博客园&lt;/a&gt;上没人写过踩坑文章，也不能肯定&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt;上必然有现成的回答。既然我们会中文和英文两种语言，就应该利用这种优势，同时使用两种语言搜索同一个问题（用中文关键字搜中文结果，vice versa），这样找到答案的概率会更高。&lt;/p&gt;
&lt;p&gt;用Bing搜索中文编程内容能逃避内容农场吗？不完全能。但是因为百度和Bing是两个公司单独计算网页排名，而刷排名的坏东西的目标一般是百度排名，因此Bing比百度的情况好一些。事实上不止中文搜索结果有内容农场这个坏现象，几乎所有语言的搜索结果都有，这需要搜索引擎公司们自己想办法反制。&lt;/p&gt;
&lt;h4 id=&#34;搜索思想&#34;&gt;搜索思想&lt;/h4&gt;
&lt;p&gt;记得把使用搜索引擎查找互联网内容的思想迁移到各个使用场景上。想找存在电脑上的文件？Windows系统可以按一下Win键打开搜索栏。想在网页内找关键字？使用浏览器的网页内搜索。想在文本编辑器里搜索本文件中的内容？文件内搜索。在IDE里搜索整个项目目录的内容？项目内搜索。&lt;/p&gt;
&lt;p&gt;小提示，本文中所有超链接标注的名词都可以作为搜索关键字，我只是每个名词搜了一个质量差不多的网页附上链接&amp;hellip;多花点时间应该能搜到质量更好的。&lt;/p&gt;
&lt;p&gt;搜索的最大目的始终不变：节约寻找答案的时间，因为寻找答案过程本身没有产出。&lt;/p&gt;
&lt;h2 id=&#34;编程语言&#34;&gt;编程语言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;文本命令：&amp;ldquo;老王 吃 苹果&amp;rdquo; -&amp;gt; 执行动作：老王在客厅桌子上找到一个苹果，吃掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编程分为两个部分，人编写文本格式的&lt;a href=&#34;https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969&#34;&gt;源代码&lt;/a&gt;，编译器|解释器（下面统一使用编译器做指代，即使实际上是解释器）负责将源码编译成机器能看懂的&lt;a href=&#34;https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86/238130&#34;&gt;指令&lt;/a&gt;。你可以为任何有结构的文本编写一个编译器，文本就是命令的内容，简单说明了要做什么事，编译器按着文本写出详细指令，计算机按着详细指令做事。举个例子：打仗，司令部传达过来的命令很简单，然后战场上的指挥官会以一两行命令为大纲来拟定详细的计划，士兵们可以按照详细计划行动。&lt;/p&gt;
&lt;p&gt;编译器和战场指挥官一样，帮你补足你在源码中没有提到的细节。注意看上文那句老王吃苹果，源码里没有提到老王在吃苹果前需要找到苹果，也没提到如何找苹果，但最后执行的动作中是存在找苹果的步骤的。这引出了目前主流的两类&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B/1475451&#34;&gt;编程范式&lt;/a&gt;：命令式（imperative）和声明式（declarative），按命令式编程设计的编程语言需要指明执行的细节，比较唠叨，而声明式只需要指定要做什么事，细节由编译器补足。事实上现代语言都混合了不同的编程范式，更加灵活。上面老王吃苹果的例子是偏向于声明式的。&lt;/p&gt;
&lt;p&gt;依我看，编译器越“聪明”，越懂得从寥寥数行源代码里猜测程序员的意图并产生出程序（如JavaScript，尽一切努力不报编译错误，即使会输出很离谱的结果）；反之，编译器越“木头脑袋”，越要求源代码“符合语法语义规则”，源代码越冗长（Java，说的就是你）。要么人写源码多费功夫，要么编译器编译源码多费功夫，仅此而已。编译这门手艺的术语叫&lt;a href=&#34;https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4194&#34;&gt;编译原理&lt;/a&gt;。如果你有一个无限智能的编译器，就可以用自然语言即中文英文等，去指挥计算机做事。可惜，编译器是有极限的，语言越复杂，编译器所要做的工作越多，人就越难去编写这个编译器（编译器是个特殊的程序，终究还是要人来写），最后我们折衷得到了目前这些编程语言和对应的编译器。&lt;/p&gt;
&lt;p&gt;不同编程语言适合做不同的事，就像木匠工具箱里不同工具用来做不同的工作，没有高下之分，也没必要搞工具崇拜。因为有些编程语言底层设计特性是相互冲突的，而且现在已有这么多用得好好的不同语言编写的程序支撑着我们的世界，所以从设计理论和改造成本上看永远不会有一个全能的编程语言可以代替所有语言。顺带一提，每个编程语言的命令表达能力都是相等的，因为它们都是&lt;a href=&#34;https://www.zhihu.com/question/20115374&#34;&gt;图灵完备&lt;/a&gt;的，所以“一个语言可以代替另一个语言完成某个具体工作”这种论断是正确的，只是用不同语言间写源码完成相同的某功能花的力气可能差个几倍几十倍都有可能。&lt;/p&gt;
&lt;p&gt;编程语言本身，和编程语言下的框架、第三方库，只是工具而已。它们一般有个说明书教你如何使用，你可以在网上搜索（官方教程或注释生成的API文档）。有时你能在IDE里看它们源码的注释，注释也会详细地解释这个代码要做什么，就不用搜索了。事实上，在商业编程刚刚起步时，每个程序员手边都有一本关于所用编程语言提供的库API与语法的手册，他们要像查字典一样使用这本工具书，因为那个时候没有互联网，没有在线文档。不要过多花时间在了解工具的使用上（通读文档，试图记住所有库API，类似背诵字典），有需要就用关键字去搜索，越用越熟，就能记住了。&lt;/p&gt;
&lt;h3 id=&#34;学一门编程语言&#34;&gt;学一门编程语言&lt;/h3&gt;
&lt;p&gt;自然语言有听说读写四个技能要求，编程语言是书面语言，学习一门编程语言仅要求读写两个方面，另外额外多一个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习它的编程思想、语法和关键字，即读法写法。&lt;/li&gt;
&lt;li&gt;知道语言的原生库提供了哪些API（帮你省事的现成的功能），知道如何使用或去哪查如何使用这些API（小提示：库代码的注释，网上的在线文档，或教程）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐一个入门图书系列——&lt;a href=&#34;https://baike.baidu.com/item/Head%20First/13972734&#34;&gt;Head First&lt;/a&gt;。由 O&amp;rsquo;Relly 出版社发行的一系列教育书籍，它强调以特殊的方式排版，由大量的图片和有趣的内容组合构成，而达到非疲劳的沉浸式学习效果。我读过它的&lt;a href=&#34;https://book.douban.com/subject/2243615/&#34;&gt;设计模式&lt;/a&gt;书，很有趣。&lt;/p&gt;
&lt;p&gt;还有几个在线中文教程网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/archives.html&#34;&gt;阮一峰的网络日志&lt;/a&gt;，&lt;a href=&#34;https://www.liaoxuefeng.com/&#34;&gt;廖雪峰的官方网站&lt;/a&gt; 这两位为中文互联网提供了大量易懂的入门级IT方面的教程，如果你想通过中文教程了解一个新东西，可以先在搜索栏前面输上&amp;quot;阮一峰&amp;quot; &amp;ldquo;廖雪峰&amp;rdquo;+新东西关键词，看他俩有没有写过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.runoob.com/&#34;&gt;菜鸟教程&lt;/a&gt; 特别的，如果你想通过中文教程学习某种编程语言|工具，并快速写出能跑的程序|运行环境，建议阅读这个网站上的教程，这上面基本涵盖了所有常用的编程语言和工具的快速入门教程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;java编程语言&#34;&gt;Java编程语言&lt;/h4&gt;
&lt;p&gt;Java中规中矩，有一套严格的语法规则。通过学习复杂的语法规则，新手可以了解编程语言的一些共性，我还是比较推荐新手通过Java了解面向对象编程的。最近几年Java想要变年轻，迭代变快了（半年一个新版本），也&lt;a href=&#34;https://dzone.com/articles/a-guide-to-java-versions-and-features&#34;&gt;引入了不少其他语言中好用的特性&lt;/a&gt;。你可以把它理解为保守谨慎的，只会在一个特性被其他语言实践验证后才考虑引入。但是&lt;a href=&#34;https://www.zhihu.com/question/360985479&#34;&gt;业内不少公司都停留在了Java8&lt;/a&gt;，主要是公司们不想还遗产代码的债。&lt;/p&gt;
&lt;p&gt;如果你工作项目使用的是Java8，推荐你了解一下Java8引入的&lt;a href=&#34;https://www.w3cschool.cn/java/java-stream-api.html&#34;&gt;Stream API&lt;/a&gt;。如果你需要Java语言的工具书，建议使用&lt;a href=&#34;https://book.douban.com/subject/26880667/&#34;&gt;Java核心技术&lt;/a&gt;，上下两卷两本大厚书，你也可以通过通读它来学习Java。&lt;/p&gt;
&lt;h3 id=&#34;第三方库&#34;&gt;第三方库&lt;/h3&gt;
&lt;p&gt;在现代，没有任何编程项目是从零开始的。每个编程语言都有自己的第三方库仓库（repository），比如Python的&lt;a href=&#34;https://pypi.org/&#34;&gt;pypi&lt;/a&gt;，Java的&lt;a href=&#34;https://mvnrepository.com&#34;&gt;Maven Repository&lt;/a&gt;等。有些公司为了保证项目所使用的第三方库的稳定，会建立并维护内部的仓库。库（library）或者叫包（package），就是别人写好的功能。你可以把库从在线的仓库下载到本地，就不需要自己编写了对应的功能了。这算盗窃吗？事实上，每个库（每个开源软件项目，库属于一种特殊的专门给程序员用的项目）都有&lt;a href=&#34;https://zhuanlan.zhihu.com/p/322438947&#34;&gt;许可证&lt;/a&gt;，许可证是一个声明，它规定了该库可在什么情况下使用，比如有些许可证就禁止商业使用。&lt;/p&gt;
&lt;h4 id=&#34;框架&#34;&gt;框架&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/1471931&#34;&gt;框架（framework）&lt;/a&gt;是一种特殊的项目，顾名思义，它提供了编写某类程序的大致框架。当你自己动手写练手的项目，你会发现写项目最难的在于如何组织各个组件间的关系，我该把这个文件放在哪个目录？我该把这段逻辑放在哪个组件？谁调用谁？选择一款框架，了解它关于组织组件的建议，你便只需专注你的功能。&lt;/p&gt;
&lt;h4 id=&#34;架构&#34;&gt;架构&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/86052051&#34;&gt;架构（architecture）与框架的联系与区别&lt;/a&gt;，&lt;a href=&#34;https://zhuanlan.zhihu.com/p/3455520&#34;&gt;微服务架构&lt;/a&gt;和单体架构。如果想了解更多，请自行搜索。&lt;/p&gt;
&lt;h5 id=&#34;java下的spring框架&#34;&gt;Java下的Spring框架&lt;/h5&gt;
&lt;p&gt;“&lt;a href=&#34;https://baike.baidu.com/item/spring/85061&#34;&gt;Spring框架&lt;/a&gt;（&lt;a href=&#34;https://spring.io/&#34;&gt;官方网站&lt;/a&gt;）是最受欢迎的企业级 Java 应用程序开发框架。” 听听，它可没吹牛。目前Spring已经发展成了完整的生态（我不喜欢这个词，它代表封闭，但Spring是很开放的），绝大部分新的Java应用项目选择Spring生态作为基础框架是相当自然的事。&lt;/p&gt;
&lt;p&gt;使用Spring对程序员编程有很多实际的好处，不仅是企业级的那些什么可伸缩之类的高大上特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring有完备的基础功能，可以让你只写几行代码就配置好一个复杂的功能，如果不用Spring，也许需要一整天去下载配置相同功能的库或其他外部系统。&lt;/li&gt;
&lt;li&gt;Spring开箱即用，简化了项目配置的过程（配置真是一个消磨精力的事）。&lt;/li&gt;
&lt;li&gt;Spring统一了Java业界的标准，你会发现各种项目和库都支持对Spring的兼容，不需要你来单独做兼容了。&lt;/li&gt;
&lt;li&gt;Spring对原本代码的侵入相当少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring增加了学习成本。我已经见过好几个人，当他们听到除了学Java还要学Spring时，眉头突然皱起来了&amp;hellip;但是&amp;hellip;总要多学一些工作中会用到的常用库，只是Spring稍微有点大，稍微。而且你这样想，学了Spring，就能享受上面提到的大量好处，很值。最低限度的学习，只需要了解Spring配置文件和Spring MVC的注解就行了。&lt;/p&gt;
&lt;h4 id=&#34;工具库&#34;&gt;工具库&lt;/h4&gt;
&lt;p&gt;按照我的分类，工具库通过API提供对象处理功能，你可以像使用语言本身的原生库API一样使用这些工具库。举个例子，因为Web应用的普及，每个语言都会遇到对&lt;a href=&#34;https://baike.baidu.com/item/JSON/2462549&#34;&gt;Json格式&lt;/a&gt;文本的解析、映射等操作的功能需求。比如Java语言没有在其原生库中提供这些Json格式数据的操作，于是Java社区中应需求出现了好几个Json处理工具库。&lt;/p&gt;
&lt;h5 id=&#34;java常用的工具库&#34;&gt;Java常用的工具库&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Json处理：&lt;a href=&#34;https://github.com/FasterXML/jackson&#34;&gt;Jackson&lt;/a&gt;，&lt;a href=&#34;https://github.com/alibaba/fastjson&#34;&gt;FastJson&lt;/a&gt;，&lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据处理（狭义上的工具类）：&lt;a href=&#34;https://github.com/dromara/hutool&#34;&gt;HuTool&lt;/a&gt;，&lt;a href=&#34;https://mvnrepository.com/artifact/org.apache.commons/commons-lang3&#34;&gt;apache commons-lang3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志记录：&lt;a href=&#34;https://www.tutorialspoint.com/slf4j/slf4j_vs_log4j.htm&#34;&gt;slf4j&lt;/a&gt;（它是接口，不能独立工作），&lt;a href=&#34;https://logging.apache.org/log4j/2.x/&#34;&gt;log4j&lt;/a&gt;（它是一种实现，可以独立工作）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一类有其中之一就满足需要了（slf4j除外）。如果你中途加入一个项目组，你需要辨别该项目使用了哪些工具库，并继续使用，不要添加相同功能的其他工具库。&lt;/p&gt;
&lt;h4 id=&#34;依赖管理工具&#34;&gt;依赖管理工具&lt;/h4&gt;
&lt;p&gt;当你使用某个第三方库或框架，你便对它产生了“依赖”，有时我们把它名词化，项目依赖的第三方库就起个别名叫“依赖”（dependency）。当然你使用的第三方库本身也可能有依赖，于是会形成一个以你的项目为根的依赖树。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1122163&#34;&gt;依赖管理工具&lt;/a&gt; 源自人们想要自动化（程序员爱自动化）依赖管理的需求。一般依赖管理工具和第三方库仓库是相辅相成的，本地的依赖管理工具会将第三方库仓库的网址作为远程仓库，从上面下载第三方库文件。部分依赖管理工具还拥有工程构建的功能，你简单理解为编译、打包与部署项目。&lt;/p&gt;
&lt;h5 id=&#34;java依赖管理工具&#34;&gt;Java依赖管理工具&lt;/h5&gt;
&lt;p&gt;主流的Java依赖管理工具有两个：&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Apache Maven&lt;/a&gt;和&lt;a href=&#34;https://gradle.org&#34;&gt;Gradle&lt;/a&gt;。区别？看&lt;a href=&#34;https://cloud.tencent.com/developer/article/1122163&#34;&gt;这篇中文文章&lt;/a&gt;或者&lt;a href=&#34;https://gradle.org/maven-vs-gradle/&#34;&gt;这篇Gradle自己写的对比&lt;/a&gt;或者&lt;a href=&#34;https://www.zhihu.com/question/276078446&#34;&gt;这篇知乎回答&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;往项目里添加依赖&#34;&gt;往项目里添加依赖&lt;/h4&gt;
&lt;p&gt;以Java语言项目为例，单个现代项目往往被分成多个包（package，对，就是上面提到的第三方库的一种别名），包之间的有一定的隔离性，依赖也是各个包独立管理的。&lt;/p&gt;
&lt;p&gt;在编程工作中，你会碰到想使用某个第三方库（或者同一个项目的另一个包）的功能，而目前项目里还没有这个依赖的情况。此时你应该斟酌一下你想在哪个包的代码中使用第三方库，对应要把新的依赖放在哪个包的依赖配置文件里。这个问题没有固定答案，原则就是尽可能少增加复杂度。如果你拿不准，咨询一下有经验的程序员的意见。&lt;/p&gt;
&lt;p&gt;有一个编程原则叫“针对抽象而非具体编程”，我们应该尽可能减少程序中不必要的依赖，因为它会妨碍未来的变更的灵活性。反面例子：依赖是一个树型结构，有些库没有好好遵守这个原则，依赖于某个具体的库，导致使用该库的其他库也&lt;a href=&#34;https://zhuanlan.zhihu.com/p/34427614&#34;&gt;传递依赖&lt;/a&gt;了那个具体库。结果越来越少的库为了避免麻烦选择使用这些库，最终维护者因无人使用放弃了维护，项目死亡了。不可在未来灵活替换的依赖对项目来说是致命的病毒。&lt;/p&gt;
&lt;h2 id=&#34;单元测试与debug&#34;&gt;单元测试与Debug&lt;/h2&gt;
&lt;p&gt;关于单元测试的定义与用途，读&lt;a href=&#34;https://baike.baidu.com/item/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/1917084&#34;&gt;百度百科的介绍&lt;/a&gt;。关于单元测试思想方面的内容，可以读&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/&#34;&gt;这篇文章&lt;/a&gt;。简单说，单元测试是程序员为了检测自己写的功能是否合乎预期而编写的额外的代码。把这种测试的行为用代码持久化下来有不少好处，比如可以重复运行。单元测试不是必须的，写它可能要费不小的事，所以有时要斟酌是否值得写单元测试，主要看写测试的时间能否弥补未来一遍遍手动测试的时间。&lt;/p&gt;
&lt;p&gt;一般使用现成的单元测试库来编写单元测试用例。单元测试库属于工具库，也是百花齐放多种多样。现代的框架，比如&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html&#34;&gt;Java的Spring&lt;/a&gt;，&lt;a href=&#34;https://projectreactor.io/docs/core/release/reference/index.html#_testing_a_scenario_with_stepverifier&#34;&gt;Java的Project Reactor&lt;/a&gt;（我相信其他语言的编程框架也有，奈何我没用过无法举例）都会比较贴心地随框架附带专用的测试工具包，帮助你更顺利地使用框架。如果一些热门的库本身没有提供测试工具包，也会有热心程序员提供第三方的辅助测试包&amp;hellip;社区就是这个样子，有需求就往往有对应的现成解决方案。&lt;/p&gt;
&lt;p&gt;单元测试库的API是额外的学习成本，所以部分程序员不喜欢写单元测试，或者写的单元测试无法自动化运行，需要人盯着看日志输出结果。还有一种不写单元测试的情况是，不知道怎么写、或者没有单元测试库的依赖（内网开发时会遇到）或项目使用特殊的商业框架，因此有心无力写不出单元测试。对于前者，斟酌一下学习并写出单元测试的成本；对后两者&amp;hellip;默哀，放弃单元测试吧，争取用其他工具把集成测试的测试用例自动化。&lt;/p&gt;
&lt;p&gt;Debug，或者叫调试，是在程序尚未被打包部署前，把程序在本地的环境里通过调试器等工具的帮助下运行起来，细致观察程序内部的每一步行为，以确定程序行为符合预期。现代IDE中一般会集成调试器和Debug功能，因此通常的实践是在IDE中，以debug模式运行单元测试用例或整个程序。具体怎么用要查IDE的官网文档或自己动手试用，别忘了学习对应的快捷键。&lt;/p&gt;
&lt;h3 id=&#34;java的单元测试包和idea的debug功能&#34;&gt;Java的单元测试包和IDEA的Debug功能&lt;/h3&gt;
&lt;p&gt;我会介绍我现在用的测试库，你也可以选择自己整理一套喜欢的测试库。自从我学会借助测试库写单元测试后只用过两种语言：Java和JavaScript。写JavaScript单元测试我是用FaceBook开源的&lt;a href=&#34;https://jestjs.io/&#34;&gt;Jest&lt;/a&gt;，本身功能就挺全的，有时会安装基于它的插件包来扩展功能。&lt;/p&gt;
&lt;p&gt;Java就复杂点了，我现在有一套会用的Java测试库，搭配使用它们可以完成基于Spring框架的应用的各种单元测试工作。关键是它们可以用一个&lt;a href=&#34;https://stackoverflow.com/questions/61117933/whats-the-difference-between-spring-boot-test-vs-spring-boot-starter-test&#34;&gt;spring-boot-starter-test&lt;/a&gt;依赖全部导进来，省事（而且公司的内部仓库里大概率会有）。主要有这么几个包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://junit.org/junit5/&#34;&gt;Junit&lt;/a&gt; 它是一个测试框架，很多其他测试包会基于它编写，角色类似上面的Jest。公司项目中有些用Junit4，但它比较老（10年以上），现在出了Junit5，注意两者间用法的&lt;a href=&#34;https://www.baeldung.com/junit-5-migration&#34;&gt;不同&lt;/a&gt;(&lt;a href=&#34;https://www.baeldung.com/junit-5-runwith&#34;&gt;@Runwith兼容&lt;/a&gt;，&lt;a href=&#34;https://www.baeldung.com/mockito-junit-5-extension&#34;&gt;Mockito in Junit5&lt;/a&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html&#34;&gt;Spring提供的测试组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/features.html&#34;&gt;Spring Boot提供的测试组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; Mock，嘲弄，在测试中我们说mock被测试组件的依赖，是指把调用被试和被被试调用的组件，全部用测试库提供的API换成假的空壳子。这样我们可以控制输入被试的数据，和被试调用其他组件时其他组件的反应。举个例子，我们可以mock一个数据库API，然后写明如果被试调用该API，抛出异常，测试被试在数据库异常时的异常处理逻辑。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hamcrest.org/JavaHamcrest/&#34;&gt;Hamcrest&lt;/a&gt; 小巧的断言（assertion）框架，作为Junit断言API的替换品，提供可读性更高的API。（Hamcrest仅是判断一个对象的值怎样怎样，如果想判断其他的比如抛出异常，用Junit的API更方便。）断言是单元测试自动化的核心：自动判断运行结果是否符合预先编写好的结果。例子：assertThat(result,is(&amp;ldquo;expected-output&amp;rdquo;))，期望result这个变量是个字符串格式，值是&amp;quot;expected-output&amp;quot;。如果没通过判断，断言API会抛出异常，让这个测试用例失败，并打印出失败的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写Java的测试用例时要留意一下IDEA Auto Import的哪个库的注解|API，不能无脑回车导入。因为都是用在测试场景，不少库有同名或名称相似注解|API（例：org.junit.Test和org.junit.jupiter.api.Test）。注解|API间需要搭配使用，混用可能使某个注解|API失效导致测试运行失败，报错也总是云里雾里，无法快速发现是注解用错的原因。这个需要多读点教程和文档弄明白常用的注解|API间的关系，又是一笔额外的学习成本。&lt;/p&gt;
&lt;p&gt;顺带一提，上面的Hamcrest基于的测试理念是“基于用例的测试”，即提前写好预测的结果，一个用例只能预测一种行为的一个输入和对应的结果。现在业内出了一个还没流行起来的新测试理念——“基于特性的测试”，简单说就是测试框架根据给定的范围，自动生成测试数据，一个测试用例可以用大量的随机数据测试被测组件的抽象行为。但是这种测试用例特别难写，主要是难以抽象总结被测组件的行为。感兴趣的话，可以阅读&lt;a href=&#34;https://boholder.github.io/blogs/unit-test-methods/&#34;&gt;这篇文章中的后两节&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;IDEA的debug功能挺强大的，尤其是debug中途修改变量值，可以作为写不出单元测试时的替代操作。它还允许现改代码并编译替换运行中的类文件，允许drop堆栈来实现“反悔”回到上一步调用处，使得程序可以在一段逻辑中反复运行，测试各种情况。可以用上文提到的Learn插件学习IDEA的debug功能，或者读&lt;a href=&#34;https://www.jetbrains.com/help/idea/debugging-code.html&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编程思想&#34;&gt;编程思想&lt;/h2&gt;
&lt;h3 id=&#34;编程原则&#34;&gt;编程原则&lt;/h3&gt;
&lt;p&gt;编程原则（principle）是一些抽象化的格言，用来规范提醒程序员的编程行为实践。比如提到面向对象编程实践就是&lt;a href=&#34;https://www.baeldung.com/solid-principles&#34;&gt;SOLID五大原则&lt;/a&gt;。还有什么ETC（easy to change）原则，DRY（do not repeat yourself）原则，FEP（fail early，不够仨单词的原则会把原则的P也算进缩写）等。这些原则不是术语，算是程序员间的共识（或者叫黑话），而且可能同一原则有不同解释方式和缩写变体。&lt;/p&gt;
&lt;p&gt;编程原则试图从抽象层面对抗未来必然会出现的代码变更，尽可能让代码变更变得容易，少修改已经写好的代码。我借用一下忘了哪本书中提到的观点：把软件开发学科与建筑学科相类比的观点（软件架构architecture一词是从建筑学借来的，软件设计模式也是基于建筑学典著&lt;a href=&#34;https://book.douban.com/subject/1157145/&#34;&gt;建筑模式语言&lt;/a&gt;启发出现）已经过时，因为开发流程不再是严格遵守计划表的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/81383161&#34;&gt;瀑布式开发&lt;/a&gt;。软件开发更像园艺，你把种子种在花园里，不能控制植物的自然生长（未来的需求变更），只能通过园艺技术（&lt;a href=&#34;https://book.douban.com/subject/4262627/&#34;&gt;代码重构&lt;/a&gt;）修剪、梳理花园。&lt;/p&gt;
&lt;p&gt;编程原则无关编程语言，甚至在编程之外的工作和生活中都能借鉴，算是一种行为哲学。希望你能聆听这些编程原则，写出易于变更的代码。&lt;/p&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式&lt;/h3&gt;
&lt;p&gt;请看这篇文章了解设计模式：&lt;a href=&#34;https://draveness.me/holy-grail-design-pattern/#fnref:5&#34;&gt;圣杯与银弹 · 没用的设计模式&lt;/a&gt;。以我的经验而言，设计模式最大的用途是减少沟通成本，冲这个用途值得花时间学一些常用的设计模式的概念。&lt;/p&gt;
&lt;h2 id=&#34;完成编程工作所需的外围技能&#34;&gt;完成编程工作所需的外围技能&lt;/h2&gt;
&lt;p&gt;你可以在网络上搜索什么&amp;quot;Xxx职业技能树|知识图谱|技术栈&amp;quot;，有许多人试图总结出这么一个东西，但是要我说，看看&lt;a href=&#34;https://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html&#34;&gt;这位有10年间有多岗位经验的reddit老哥&lt;/a&gt;是怎么描述这个行业的技术栈的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;英语&#34;&gt;英语&lt;/h3&gt;
&lt;p&gt;四级，英语四级水平的英语读写绝对够用了，只要日常工作没有听说英语的需求。除开每次写方法名都要愣一下单词怎么拼（记得在IDE上安装拼写纠正插件，别闹了笑话）以外，编程工作不是太要求英语水平。编程相关的问答、教程、官网、文档&amp;hellip;都不会用很生僻的单词，大家都倾向于用最简单的单词表达意图。唯二的例外是博客和论文。博客是口语化的文章，我碰到过不少次作者想举个例子或者玩笑幽默一下，但把我卡住用字典查里面的生词，继续读下去明白了只是一个例子|玩笑的无奈情况。论文&amp;hellip;论文的生词主要是术语，数学术语、机器学习术语、数据分析术语等。&lt;/p&gt;
&lt;p&gt;有些中文程序员不喜欢英语材料，可能是因为不习惯或者读得慢浪费时间。其实我读得也不快，有时候也因为怕浪费时间选择找中文材料去读。但是如果你去读，你会发现英语材料是可以读懂的，读懂就足够了，多读一些就能克服不习惯的心理障碍，也能慢慢提高阅读速度。&lt;/p&gt;
&lt;p&gt;你还可以借助科技的辅助：&lt;a href=&#34;https://www.deepl.com/en/translator&#34;&gt;DeepL Translate&lt;/a&gt;等翻译网站、浏览器翻译插件和IDE翻译插件等可以帮你弥补英语能力的不足。&lt;/p&gt;
&lt;h3 id=&#34;版本控制工具&#34;&gt;版本控制工具&lt;/h3&gt;
&lt;p&gt;源代码是文本文件，对吧。&lt;a href=&#34;https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/3311252&#34;&gt;版本控制工具&lt;/a&gt; 是用来管理文本文件的内容变更的功能，类似Microsoft Office Word里的Review（审计？）功能，就是写论文时导师用来帮你打批注、改论文的那个。我见过有写手用它管理txt格式的小说文件，写代码真的和写作很像啊。版本控制工具不仅会记录哪个人对哪个文件做了什么改动，还允许你独立地管理这些改动，确保多人协作的同时维护源代码文件不会被搞成乱糟糟的“源码-v02的副本(1)(2)(1)”这副模样。&lt;/p&gt;
&lt;p&gt;有两款主流的版本控制工具工具：&lt;a href=&#34;https://www.runoob.com/git/git-tutorial.html&#34;&gt;Git&lt;/a&gt;和&lt;a href=&#34;https://www.runoob.com/svn/svn-tutorial.html&#34;&gt;SVN&lt;/a&gt;（曾经还有&lt;a href=&#34;https://baike.baidu.com/item/CVS/405463&#34;&gt;CVS&lt;/a&gt;，SVN成功取代了CVS）。两者区别？打开Git的链接阅读介绍。另外我想分享一个写得不错的&lt;a href=&#34;https://www.atlassian.com/git/tutorials/what-is-version-control&#34;&gt;英文的Git教程系列&lt;/a&gt;，它不仅讲命令，还总结命令间的区别，还稍微讲了一些git的实现原理，让你对git命令的执行过程有更深的认识。&lt;/p&gt;
&lt;h3 id=&#34;linux命令行操作&#34;&gt;Linux命令行操作&lt;/h3&gt;
&lt;p&gt;现在有三种主流的个人计算机操作系统，微软的Windows，苹果的macOS，和开源的（各种发行版的）Linux。服务器操作系统就很多了，五花八门的商业产品，比如Windows的&lt;a href=&#34;https://www.microsoft.com/en-us/windows-server/&#34;&gt;Windows Server&lt;/a&gt;，还有各种Linux。Linux系列操作系统因为其内存占用小、运行稳定、开源（即，免费，服务器版本的操作系统超贵）等特点，成为了主流的应用服务器的宿主操作系统。就是说，我们编写的应用在编译打包后，最终要部署到运行着Linux操作系统的服务器上。&lt;/p&gt;
&lt;p&gt;如果你在Windows或MacOS操作系统上编程，一般你会使用Linux服务器做这两种工作：&lt;/p&gt;
&lt;p&gt;部署（也称发版，发布新版本）程序。有时会有专门的运维职业的人员负责这方面工作，或者有自动化构建流水线，有时现实没那么美好，要程序员自己干。部署的操作流程视编程语言而定，在中途加入的项目组中，一般会有其他程序员写好的部署脚本（&lt;a href=&#34;https://www.runoob.com/linux/linux-shell.html&#34;&gt;Shell脚本&lt;/a&gt;）来简化部署操作。&lt;/p&gt;
&lt;p&gt;查看日志文件。当程序打包部署后，我们就不能以debug的形式查看程序内部的运行情况了。因此我们会在程序中各处插入打印日志的语句，日志会被打印到一些文本文件中，我们通过查看日志文件来判断程序是否正常运行。看日志文件基本是程序员的职责，比如当自己负责的功能出问题时&amp;hellip;就会有电话联系你“看一下某请求的情况”，你就要去对应的服务器上查看日志，来判断到底是你的功能出bug了，还是其他系统或功能形成的异常数据致使你的功能运行不正常（这种情况也要增加异常处理补丁去防止再次发生，编程原则：永远不要信任外部系统）。如果只是看日志文件的话，最低限度需学习的命令有&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/cd.1p.html&#34;&gt;切换目录的cd&lt;/a&gt;，&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/ls.1p.html&#34;&gt;查看目录内容的ls&lt;/a&gt;，&lt;a href=&#34;https://www.man7.org/linux/man-pages/man1/grep.1p.html&#34;&gt;使用正则过滤查看日志文件的grep&lt;/a&gt;。当然你还需要咨询同组其他人、或阅读程序中的日志输出配置文件来了解日志文件的位置。&lt;/p&gt;
&lt;p&gt;如果你不熟悉命令行界面，看&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/an-introduction-to-the-linux-terminal&#34;&gt;这篇英文介绍&lt;/a&gt;或者&lt;a href=&#34;https://www.runoob.com/linux/linux-tutorial.html&#34;&gt;菜鸟教程的中文Linux教程&lt;/a&gt;。另外，在命令行中输入“man”（代表manual）+其他命令，可以打开命令的说明书；或输入命令+&lt;code&gt;-h&lt;/code&gt;或&lt;code&gt;--help&lt;/code&gt;参数，打印命令的简单说明。你也可以在网上搜索在Linux中应该使用哪个命令做你想做的事。&lt;/p&gt;
&lt;p&gt;特别的，从我们自己的电脑连接到服务器来使用服务器的命令行界面，需要使用&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&#34;&gt;SSH&lt;/a&gt;这么一种命令行工具（同时它也是工具原理的同名协议）。一般不需要直接使用它，有多种图形界面软件供你选择，这里不再列举，请自行搜索。关于服务器的IP、端口、用户名与密码等连接所需的信息，你需要咨询同组的其他人。&lt;/p&gt;
&lt;h3 id=&#34;对各种外部系统的配置&#34;&gt;对各种外部系统的配置&lt;/h3&gt;
&lt;p&gt;提问！上文中出现了几次“配置”？（提示：使用搜索快捷键）开个玩笑，其实我是想说，编程离不开对外部系统的配置。编程项目不是从零开始的，对吧，我们要使用许多已有的系统来省事，比如&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728&#34;&gt;数据库&lt;/a&gt;、&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240&#34;&gt;中间件&lt;/a&gt;、框架、日志系统（打日志是一件很复杂的事）&amp;hellip;这些系统都需要我们通过配置来调整它们的行为，以适应我们项目的需要。&lt;/p&gt;
&lt;p&gt;一般我们说配置一个系统，指的是编写配置文件，配置文件是一种遵守某种&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849&#34;&gt;标记语言&lt;/a&gt;（xml,json,toml,yaml&amp;hellip;）的文本文件，它就是系统的设置项，和手机设置一样。系统一般在启动时读取配置文件，基于此调整行为。注意，系统一般只会在启动时读取配置文件，所以如果系统启动后你想修改配置文件并让它生效，往往需要重启系统。当然这有很多例外&amp;hellip;比如你可以多开一个&lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835&#34;&gt;守护进程&lt;/a&gt;专门监控配置文件的变化，若出现变化，就重启系统让系统读新的配置文件。另外在我看来，配置文件的内容是只能被该系统识别并解析的“语言”（&lt;a href=&#34;https://www.infoworld.com/article/2077865/core-java-creating-dsls-in-java-part-1-what-is-a-domain-specific-language.html&#34;&gt;领域特定语言&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为了写出配置文件，要去读说明书。可以读官方的配置说明文档（往往详细又冗长），也可以省事读简化版的第三方文档，比如中文翻译、博客记录等。这个工作最麻烦的步骤就是要硬着头皮读大篇幅的文档。读哪个都行，能明白怎么写完成工作就好，我推荐配合网页内搜索读官方文档，毕竟最详细。注意配置与软件一样都是有版本的，要读自己项目所用的版本的对应说明书，或者有些文档只有一版，但会在每个配置项下标注从哪个版本开始生效。&lt;/p&gt;
&lt;h2 id=&#34;总结太多了先学哪个&#34;&gt;总结：太多了，先学哪个？&lt;/h2&gt;
&lt;p&gt;不好意思，我没收住字数，写太多了。咚地一下全摆在面前是挺吓人的，而且说实话本文仍未涵盖我所认定的所有“必备技能”，如正则表达式等。&lt;/p&gt;
&lt;p&gt;总之先学编程语言吧，然后是熟悉框架和几个常用的库的用法，此时就能完成工作了。然后如果你对这个职业仍有兴趣，可以学习单元测试、debug和编程思想（看书看博客），还有外围的技能，这些可以慢慢来。额外的知识会提高你的专业性，让你能够有底气地承认自己被付钱来编写程序，你对自己写出的程序有信心且对它负责。&lt;/p&gt;
&lt;p&gt;如果你对这个职业不感兴趣，学到足够工作使用的知识就可以停止了，你也可能会发现其他兴趣和职业的知识会迁移性地对编程工作产生意想不到的帮助，很多抽象的原则和知识是共通的。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;
&lt;h3 id=&#34;有用的网站&#34;&gt;有用的网站&lt;/h3&gt;
&lt;p&gt;下面是通用的几个网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/&#34;&gt;StackOverflow&lt;/a&gt; 它是&lt;a href=&#34;https://stackexchange.com/&#34;&gt;StackExchange&lt;/a&gt; 问答网站中分离出的编程问答板块。如果想解决程序报错、想知道某个API怎么用、不知道如何完成一个功能、想了解一种编程实践的理念&amp;hellip;一切关于编程的东西，基本上你不是第一个碰到这个问题的人，stackoverflow上大概率会有对应的提问和专业亲切的回答。为了不限制搜索引擎的能力，不建议使用网站内部的搜索功能，而是直接在搜索引擎的搜索栏上开头写&amp;quot;stackoverflow&amp;quot; + 你的问题描述（用英文）。关于这个网站有不少meme赞美它的便利，比如：在没有stackoverflow之前程序员怎么可能顺利写完程序呢。PS: stackoverflow需要从&lt;code&gt;ajax.googleapis.com&lt;/code&gt;域名加载Js脚本，因为GFW封禁了该域名，在国内网络打开该网站的速度会慢得不可忍受。如果你没有网络代理，你可以使用浏览器的广告屏蔽插件规则将该脚本的加载屏蔽，进而恢复正常的网页打开速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web&#34;&gt;MDN(Mozilla Developer Network) Web docs&lt;/a&gt; 这是实质上的互联网唯一的Web前端开发参考文档，附带翔实有趣的教程（多语言翻译，有中文）。你可以不走出这个网站而学习完前端开发所需要的大部分基础知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt; 结合&lt;a href=&#34;https://boholder.github.io/blogs/learn-from-source-code&#34;&gt;这篇文章&lt;/a&gt;从Github里找点感兴趣的项目看一下，感兴趣优先，真的什么千奇百怪的项目都能搜出来。另外有一个小诀窍，如果你拿不准某个库的某个API怎么用，而注释、文档和stackoverflow又没能让你满意，你可以在github中搜索使用了该api的代码片段，学习使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://old.reddit.com/r/ExperiencedDevs/&#34;&gt;Reddit-ExperiencedDevs&lt;/a&gt; 这版块只允许3年以上从业经验的开发者发帖，版块里聊的都是职业规划、公司中发生的事等等，很少涉及技术。看这里面的帖子就像一群大佬围着聊闲天时你凑进去听，只是听就能学到不少东西。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是Java方面的网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/&#34;&gt;Baeldung&lt;/a&gt; 这网站上有内容充实的关于Java与Java生态（如Spring框架）的教程，质量比那种内容农场网站高出一截。不需要刻意在网站中搜索，当你搜索Java相关教程时，这个网站往往排在搜索结果前面&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blogs.oracle.com/javamagazine/&#34;&gt;Oracle Java Manazine&lt;/a&gt; 因为Java不太受同行待见（这是真的吗？），所以不怎么能看到关于Java语言的公开讨论。虽然（仅在中国？）工作上用Java的程序员很多，但讨论Java语言俨然是个小圈子。这时我们要借助学术界中小圈子交流的方法：研讨会和期刊。研讨会&amp;hellip;至少我不够格参与，因此我选择邮件订阅Oracle公司组织编撰的免费杂志，进而一窥Java行业的动向，学点新东西。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;之前没接触过it行业的基础知识&#34;&gt;之前没接触过IT行业的基础知识？&lt;/h3&gt;
&lt;p&gt;基础知识体系无法突击补习，这是慢活，更别提还会遗忘。目前大学的软件工程|计算机科学专业会开设大约10门左右的IT专业课程，也就是说你和科班出身的IT专业本科毕业生的差距在10本左右的教科书，以及几个练手的小项目。&lt;/p&gt;
&lt;p&gt;不补基础知识体系的前提下完成公司要求的编程工作是可以的，现在的编程语言和工具已经把底层实现都封装起来了。但它会在工作上限制你的思考：不知道原理，就没法想象你的程序如何运行，也就没法深入地思考一个解决方案的细节，心里很不舒服。或者&amp;hellip;小心&lt;a href=&#34;https://droidyue.com/blog/2019/03/24/cargo-cults-programming/&#34;&gt;货物崇拜编程&lt;/a&gt;，它是指新手程序员常犯的那种“网上找解决方案复制粘贴下来”的不良编程实践。越不熟悉基础知识，越可能在工作中出现货物崇拜编程现象，这可能会在程序里埋下炸弹，最终伤害你或身边的程序员。&lt;/p&gt;
&lt;p&gt;这里有一个好的起步课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1HJ411q7bm&#34;&gt;【中英字幕|2019 CS50|哈佛大学编程入门】 CS50 Harvard University2019&lt;/a&gt;
用非术语讲解IT行业里的一些知识体系。真正的0基础开始学。可惜课不太全。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1dx411i7dW&#34;&gt;【哈佛大学-编程入门】 CS50 Harvard University（2016）11集（全）&lt;/a&gt;
课全了，可惜没中文字幕。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;我推荐的阅读材料&#34;&gt;我推荐的阅读材料&lt;/h3&gt;
&lt;p&gt;API的使用方法可以通过关键字去搜索文档和问答，但职业经验就不方便搜索了，它们恰恰是重要的东西。IT行业很有意思，我没见过除此之外哪个行业在遵守工匠道路的同时，又不吝啬甚至乐于向同行分享自己的经验。有许多人会写经验类的博客，比热门博客更系统化也更著名的是出版成书的著作。下面是我读过的，能打包票的经验方面的阅读材料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/3032825/&#34;&gt;Clean Code 代码整洁之道&lt;/a&gt; 讲细小层面（语句级别）的编程技巧。当用某种编程语言写了一个练手项目或几个功能时就可以开始看了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/6114900/&#34;&gt;The Clean Coder 程序员职业素养&lt;/a&gt; 很薄的一本书，对的，和Clean Code是同一系列， 该系列还有两本：架构整洁之道，敏捷开发实践，等级比较高，我还没看¯\_(ツ)_/¯。不涉及技术细节，指导程序员在某件工作乃至职业规划上应该如何做。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/35006892/&#34;&gt;The Pragmatic Programmer: From Journeyman to Master 程序员修炼之道（第2版）&lt;/a&gt; 分了许多小章节，每个章节用一个比喻做标题。两个作者想把他们的职业经验讲给你听，内容涉及方方面面。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/3324516/&#34;&gt;实现模式&lt;/a&gt; 书不厚，类似Clean Code，讲细节的编程技巧，但是对读者的经验要求比Clean Code高一些。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/zer4tul/44ac7d145a4342d876f3&#34;&gt;如何成为黑客&lt;/a&gt; 不，hacker不是你想象的那个意思，你指的是cracker。这篇文章是一位温和派的开源运动领导者写的关于实践开源精神的一些建议，里面一些原则值得以程序员的角度去理解学习。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/35043034/&#34;&gt;计算机简史（第三版）&lt;/a&gt; 学校里没有开设关于IT行业的历史课，我倒觉得该开一门。了解历史能多明白一些为什么现在的IT行业是这副样子。比如，开源运动如何让行业内出现了可自由使用的第三方库，让软件研发行业对人员专业素质的要求大幅降低，进而让提供了大量岗位。随着科技的发展和商业需求、社会环境的演变，曾经的一些黄金实践原则已经过时或不合时宜，也出现了适应时代的新的原则。举个例子，你不会在50年前要求程序员编写单元测试，因为他们连编译个程序都要等好几个小时，而现在的算力如此廉价，在一台个人笔记本上运行整个项目的整套单元测试只需要几分钟，这也让&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&#34;&gt;持续集成&lt;/a&gt;成为可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/25956450/&#34;&gt;人件&lt;/a&gt;、&lt;a href=&#34;https://book.douban.com/subject/1102259/&#34;&gt;人月神话&lt;/a&gt;和&lt;a href=&#34;https://book.douban.com/subject/25881855/&#34;&gt;大教堂与集市&lt;/a&gt; 这三本是软件开发组织架构方面的理论书，结合对应的年代和历史事件，它们会让你了解软件开发行业是怎样从瀑布式开发转向敏捷开发的，开发团队的组织规模为何从大部队分散成灵活的小组。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>译文：从源码中学习（阅读源码，初学者的有效成长方式）</title>
                <link>https://boholder.github.io/blogs/learn-from-source-code/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/learn-from-source-code/</guid>
                <pubDate>Tue, 25 May 2021 00:00:00 &#43;0000</pubDate>
                
                <copyright>all rights reserved</copyright>
                
                    <description>&lt;p&gt;这是一篇译制博客文章，原博客为
&lt;a href=&#34;https://coderscat.com/learn-from-source-code/&#34;&gt;Learn from Source Code (an Effective Way to Grow for Beginners)&lt;/a&gt;
，原作者为&lt;a href=&#34;mailto:nickmose8@gmail.com&#34;&gt;Nick Mose&lt;/a&gt; 。
&lt;a href=&#34;mailto:boholder@anche.no&#34;&gt;我&lt;/a&gt; 向Nick申请获得了此文的中文翻译权与中文翻译文章发布权。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;上周我在和一位年轻程序员聊天时，他问到我：“如何阅读源码？”，我们讨论了一段时间，我还列举了几种有效阅读源码的方式。
然后他说：“你应该就这个话题写篇文章，这对初学者很有帮助，而且这种经验无法从书籍和教程中获得。”
那么开始吧，下面是我关于阅读源码的小技巧。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要读源码&#34;&gt;为什么我们需要读源码&lt;/h2&gt;
&lt;p&gt;我们程序员每天都要和源码打交道。经过数年的学习，大多数程序员可以“写”代码，或者至少是拷贝并修改代码。
而且，我们教授编程的方式强调编写代码的艺术，而不是如何阅读代码。
当我说“阅读代码”，我是指&lt;strong&gt;有意地专门阅读代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;众所周知，编程和写作有诸多相同之处。
唐纳德·克努特甚至引入了&lt;a href=&#34;https://en.wikipedia.org/wiki/Literate_programming&#34;&gt;文学编程(literate programming)&lt;/a&gt; 编程范式。
编程与写作有相同的理念：&lt;a href=&#34;https://www.coderscat.com/how-to-learn-all-pl&#34;&gt;表达我们的想法&lt;/a&gt; 。
还记得你在学校是怎么学习写作的吗？我们的写作能力来源于从小学开始直到现在的大量的文本阅读。
多年以来，我们阅读了不同难度的伟大作家的作品，并练习了多种写作技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果你没时间读，你就没时间（或工具）写，就这么简单。”
—— 斯蒂芬·金，&lt;a href=&#34;https://book.douban.com/subject/3888123/&#34;&gt;《写作这回事：创作生涯回忆录》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如斯蒂芬·金所观察到的那样，一个作家必须广泛而频繁地阅读，才能形成自己的声音，
并学会写出促使读者拿起书并痴读的句式和故事结构。
&lt;strong&gt;和读书一样，有意地阅读代码可以帮助程序员加速成长，尤其是对中级(intermediate)程序员而言。&lt;/strong&gt;
这样做有三个好处。&lt;/p&gt;
&lt;h3 id=&#34;站在巨人的肩膀上&#34;&gt;站在巨人的肩膀上&lt;/h3&gt;
&lt;p&gt;我们从他人身上学习。优秀的源代码就像文学杰作，它不仅仅只提供了知识和信息，还提供了启迪。&lt;/p&gt;
&lt;p&gt;通过浏览Linux内核、Redis、Nginx、Rails或其他著名项目，
你可以从全球范围的成千上万的顶级程序员那里汲取智慧。
在这些项目中可以找到无数的良好编程示例、编程范式选择、设计和架构。
向他人学习的另一个好处是能够避免常见的坑，大多数坑早已被他人踩过。&lt;/p&gt;
&lt;h3 id=&#34;解决困难问题&#34;&gt;解决困难问题&lt;/h3&gt;
&lt;p&gt;在你的职业生涯中，你终将会碰到谷歌都无法解决的问题。
如果你还没碰到过这种问题，这只是因为你编程的时间还不足够长 :)。
阅读源码是调查这类问题的好方法，也是学习新东西的好机会。&lt;/p&gt;
&lt;h3 id=&#34;扩展你的边界&#34;&gt;扩展你的边界&lt;/h3&gt;
&lt;p&gt;大多数程序员只在少数特别领域编过程。
一般而言，如果你不时常推自己一把，你的编程技能会维持在你同事间的平均水平。
不要满足于修补bug或在现有系统中添加琐碎特性的工作。
相反，你可以试着扩展到一个新的领域，持续尝试找到一个你在日常工作中接触不到、但你感兴趣的领域。
这将从整体上拓宽你对编程的理解。&lt;/p&gt;
&lt;h2 id=&#34;应该读什么样的源码&#34;&gt;应该读什么样的源码&lt;/h2&gt;
&lt;p&gt;综上，阅读源码是有益的。
那么下一个问题，有这么多优秀作品可供选择，我们该选择并阅读什么样的源码呢？
你必须从选择目标开始。如果不在这个步骤上下点功夫，你从源码中学习的效果就会打折扣。
这里有一些典型场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当你想学习一门新语言。学新语言可&lt;a href=&#34;https://coderscat.com/how-to-learn-all-pl&#34;&gt;不只是学会语法&lt;/a&gt; 。
不管怎样，阅读源码是一个非常有效的学习新语言的方式。我从&lt;a href=&#34;https://github.com/rust-rosetta/rust-rosetta&#34;&gt;rust-rosetta&lt;/a&gt;
项目中学到了很多Rust语言知识。&lt;a href=&#34;http://rosettacode.org/wiki/Category:Programming_Languages&#34;&gt;Rosetta Code&lt;/a&gt;
是一个收集同一批通用任务在不同语言上的解决方案的项目，这是一个可用来学习新语言的有用资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想了解一个特殊的算法或实现。
例如，我们都会使用标准库中的sort函数，你有没有好奇过它是怎么实现的？
或者当你要使用Redis中的Set结构，它是用什么数据结构实现的？
为了解决这些疑惑，你只需要读源码中与之相关的实现部分，通常只有很少的文件或函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在特殊的框架中编程。这意味着你对该框架已经有了一定的经验，
这是个阅读一些框架本身的源码的好机会。
很显然，了解框架的源码有助于提高你对框架的理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你想拓展进入新的领域，你可以阅读这个领域的经典著名的项目的源码。
比如说，如果你在做Web开发的工作，你对分布式系统感兴趣吗？
如果你的答案是“是”而且你懂Golang，也许&lt;a href=&#34;https://github.com/etcd-io/etcd&#34;&gt;etcd&lt;/a&gt;
是你的选择。你想钻研操作系统的内部构成吗？那么也许&lt;a href=&#34;https://github.com/mit-pdos/xv6-public&#34;&gt;xv6&lt;/a&gt;
是一个好的开始。我们处在一个许多优秀开源项目都托管在了Github的好时代，请试着寻找一些这种项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记住，&lt;strong&gt;选择与你当前的编程技能与知识水平相当的项目。&lt;/strong&gt; 
如果你选择了远超你当前技能水平的项目，最终你会感到沮丧。
读一些相对较小的项目，接着读更大的项目。
如果目前你不能理解某些特定的代码片段，这意味着你有个知识缺口(knowledge gap)。
把代码放到一边去，试着读一些相关的书、论文或其他文档，当你更有信心时再回来接着读代码。
我们总能在一个模式中取得进展：读（代码、书、论文），写，更多的读，更多的写。&lt;/p&gt;
&lt;h2 id=&#34;如何读源码&#34;&gt;如何读源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095&#34;&gt;《How to read a book》&lt;/a&gt;
是一本指导人进行明智地阅读的书。作为初学者，我们值得投入时间和精力去思考我们应该如何阅读代码。
&lt;strong&gt;阅读代码不是件容易的事。&lt;/strong&gt; 光是阅读源码是不够的，你要试着去理解他人的设计和想法。&lt;/p&gt;
&lt;h3 id=&#34;预先准备&#34;&gt;预先准备&lt;/h3&gt;
&lt;p&gt;为了更有效率地阅读代码，你需要提前在手边准备这些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个你可以熟练使用的编辑器。你需要拥有快速搜索关键字或变量名的能力。
有时你需要查找函数的引用和定义。和你的编辑器相处融洽些。
为了更加有效率，试着学习仅使用键盘操作编辑器。
这会使你专注于代码而不受打扰（译：指额外思考编辑器操作）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握基本的Git或其他版本控制工具的技能，这样你就能比较代码在版本间的差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与源码有关的文档。文档可以为你的阅读提供参考，尤其是设计文档、编码规范等文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有一定的编程语言与设计模式的知识和经验。这对（阅读）大项目是强制性的。
如果你很了解一门编程语言，你也会了解关于源码组织与编程范式的最佳实践。
当然，这需要时间来积累。要有耐心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流程与技巧&#34;&gt;流程与技巧&lt;/h3&gt;
&lt;p&gt;阅读过程不是线性的。你不会就那么一个接一个地读源文件。
相反，大多数时候我们会从顶到底地阅读代码。
下面是一些更有效率阅读代码的小技巧：&lt;/p&gt;
&lt;h4 id=&#34;结合上下文阅读代码&#34;&gt;结合上下文阅读代码&lt;/h4&gt;
&lt;p&gt;当你阅读代码时，请持续提出问题。
例如，如果一个应用有缓存策略，一个好问题就是：如果键无效了会怎样？缓存中的值如何更新？
带着这些问题阅读代码，就是结合上下文。或者说因为你有了一个目标，你会变得享受阅读的过程。
你甚至可以自己做一些假设，然后在代码中寻找验证。&lt;/p&gt;
&lt;p&gt;你有点像侦探：&lt;strong&gt;你想发现代码的真相，代码的逻辑，代码是如何像故事一般上下流动的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;把实例跑起来并与之交互&#34;&gt;把实例跑起来并与之交互&lt;/h4&gt;
&lt;p&gt;源码就像乐高积木，只是已经组装好了。
如果你想了解它们是怎么组装在一起的，你需要和它交互，有时甚至要把它拆开。
阅读同一模块的老版本同样有帮助。从Git中阅读版本差异，试着弄清楚特定的特性是如何实现的
（修改日志在这个场景很有用）。
举个例子，我发现Lua的第一个版本相当简单，这可以帮助我了解作者最初的设计理念。&lt;/p&gt;
&lt;p&gt;Debug是另一种与代码交互的方式。试着在代码中加一些断点（或打印一些变量值），
然后弄明白打印到控制台中的所有输出。&lt;/p&gt;
&lt;p&gt;如果你对代码了解比较透彻了，试着对代码做一些修改，重新build并把它跑起来。
最简单的方式是试着调整配置项，去看不同配置的运行结果。
之后你可以试着添加一些细微的特性。
如果这些特性对其他人也有用，你应该把代码贡献到上游。&lt;/p&gt;
&lt;h4 id=&#34;了解数据结构间的关系&#34;&gt;了解数据结构间的关系&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;“糟糕的程序员担心代码，优秀的程序员担心数据结构和它们的关系。”
-Linus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据结构是一个程序中最重要的元素。用笔或者你喜欢的其他工具画出数据结构间的关系。
这个图就是源码的映射。你会在阅读过程中时常参考这个图。一些工具比如&lt;a href=&#34;https://scitools.com/&#34;&gt;scitools&lt;/a&gt;
可以用来生成UML类图。
（译：这个方法用在写代码中能节约翻Model声明文件的时间，推荐用纸笔，不占屏幕）&lt;/p&gt;
&lt;h4 id=&#34;了解模块间的依赖关系与边界&#34;&gt;了解模块间的依赖关系与边界&lt;/h4&gt;
&lt;p&gt;大项目中会包含许多模块，一个模块经常只拥有单一职责。
这有助于我们减少代码复杂度，在适当的层级上做抽象。
模块的接口是抽象的边界，我们可以一个接一个地阅读模块。
如果你在阅读一个使用Make构建的C/C++项目，Makefile是了解模块间如何组织的好切入点。&lt;/p&gt;
&lt;p&gt;边界本身也很有用。优秀的代码组织得很好，变量名与函数名的命名风格体现着可读性。
你不需要阅读全部源文件，你可以&lt;strong&gt;忽略不重要的或你熟悉的部分&lt;/strong&gt;。
如果你确定一个模块是仅仅是为了被解析而设计的(just designed for parsing)，
那么你已经大致了解了它的功能；那么你就可以跳过不读这个模块。
当然，这将大大节约时间。&lt;/p&gt;
&lt;h4 id=&#34;使用测试用例&#34;&gt;使用测试用例&lt;/h4&gt;
&lt;p&gt;测试用例也是帮助代码理解的一个很好的补充。&lt;strong&gt;测试用例就是文档。&lt;/strong&gt;
当你在阅读一个类时，试着把对应的测试代码一起读了。
测试用例能帮你弄清一个类的接口，和该类的典型用法。
集成测试用例可以让你顺着走过程序的整体流程，适合输入一些特殊值并debug运行。&lt;/p&gt;
&lt;h4 id=&#34;点评&#34;&gt;点评&lt;/h4&gt;
&lt;p&gt;为什么不在花了不少时间阅读一个项目后，写一篇代码点评呢？就像写一篇书评一样。
你可以写下代码中好的和不好的部分，还可以记下你从中学到了什么。
攥写这类文章可以帮助你阐明自己的理解，也有助于其他人阅读源码。&lt;/p&gt;
&lt;h2 id=&#34;一些好书&#34;&gt;一些好书&lt;/h2&gt;
&lt;p&gt;我发现阅读代码是一个远超我想象的广泛话题。没有系统性训练该技能的方法。
总而言之，不断练习，找到你自己的方式。下面是一些帮助你提升代码阅读能力的好书：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/&#34;&gt;《Design Patterns: Elements of Reusable Object-Oriented Software》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/0134494164/&#34;&gt;《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/How-Read-Book-Classic-Intelligent/dp/0671212095/&#34;&gt;《How to Read a Book: The Classic Guide to Intelligent Reading》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啊哈，这本书对程序员也很有用。&lt;/p&gt;
&lt;h2 id=&#34;译者的话&#34;&gt;译者的话&lt;/h2&gt;
&lt;p&gt;这篇文章是为苦于不知从何开始阅读陌生项目代码的人（包括我）准备的。
截止撰文时间为止，我认为这篇文章是在同话题中较为务实的一篇，
不仅包含理念，还包含不少具体可实践的建议，因此我想把它分享给更多人。
而且我想如果它有中文版本，愿意读下去的人会多一些，我也方便向周围的人分享，于是我向Nic申请了翻译权。
我把标题改了改，这样搜索“源码”“学习”、“阅读源码”都能搜到。&lt;/p&gt;
&lt;p&gt;这篇文章对我而言，最大作用是帮我突破了“不需要有意地专门阅读代码”的心理障碍。
我一直以为既然“写代码的时间中十之六七都是花在读既有代码上”（语出《Clean Code》），
就没必要再花时间专门读代码，我大错特错。&lt;/p&gt;
&lt;p&gt;个人经验：驱动我“专门读代码”的最大动机是好奇心，和小孩拆小物件为了看内部构造差不多。
学习OO设计模式，我建议阅读&lt;a href=&#34;https://book.douban.com/subject/2243615/&#34;&gt;《Head First 设计模式》&lt;/a&gt;
，这本书超有趣，比四人帮那本删减了一些不常用的模式，但是你能轻松读下去。&lt;/p&gt;
&lt;p&gt;阅读了解项目代码是参与（开源）项目的第一步，希望这篇文章能帮助你参与到心仪的项目中去。
这也可以帮助你在工作中了解同组同事的工作，而&lt;a href=&#34;https://laike9m.com/blog/jin-ji-nian-wo-zai-zhi-chang-cai-guo-de-keng,143/#-4&#34;&gt;“了解同组同事的工作对工作有诸多潜在益处”&lt;/a&gt; 。
来吧，花点时间挑一个看上眼的项目（或者就读你手头的项目别人写的部分），
找到你最感兴趣的功能，读一读它是怎么实现的。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>单元测试的不同方式</title>
                <link>https://boholder.github.io/blogs/unit-test-methods/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/unit-test-methods/</guid>
                <pubDate>Sun, 23 May 2021 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;对读者的知识要求前言&#34;&gt;对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;h3 id=&#34;要求&#34;&gt;要求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;掌握任一编程语言，明白“单元测试”即相关概念定义和作用，写过单元测试。&lt;/li&gt;
&lt;li&gt;&lt;del&gt;王婆卖瓜：如果不确定自己是否明白“单元测试的定义”，
请看&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#41-%E4%B8%BA%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95&#34;&gt;这段解释“为编码测试”的文字&lt;/a&gt; 。&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;现在&lt;a href=&#34;https://martinfowler.com/articles/2021-test-shapes.html&#34;&gt;单元测试和集成测试的定义因学派、组织和团队而异&lt;/a&gt; ，
我预先说明，本文中“单元测试”指“程序员为编码而编写的，
可能会使用mock技术的，针对单个类(组件？)的，总运行时间在几分钟内的测试”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;在本文中我将介绍编写单元测试(和组件测试，实践中这两个概念拆不开)时可使用的三种调用-期望方式，用途各不相同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对运行时间的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：调用被测函数，并记录调用前后时间差值，计算运行时间。&lt;/li&gt;
&lt;li&gt;目的：测试运行时间表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于用例的测试(example-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：写明特定的桩(stub)的反应(mock::given&amp;hellip;thenReturn&amp;hellip;)，
写明调用被测函数时的测试数据，期望(expect,assert)特定的输出。&lt;/li&gt;
&lt;li&gt;目的：确认模块对特定输入的输出符合预期的特定值
(包括对被测在运行中调用桩时传入的参数，和对调用本身的返回值两方面)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试(property-based testing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征：基于函数与调用者的契约(contract)，生成随机的测试数据并反复调用被测函数，
期待被测因没有正确根据输入修正自己的行为，抛出被测逻辑中没有考虑到的异常。&lt;/li&gt;
&lt;li&gt;目的：测试被测函数是否满足契约。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有研究（没找到论文链接）显示，人脑对信息的记忆和理解不仅发生在接受时，还发生在接受后的一段时间。
我打算先介绍运行时间测试（很短很容易理解），再讲“基于用例的测试”（我们都熟悉的那种），最后试着让你理解一个新概念：“基于特性的测试”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这篇文章结构是头轻脚重，篇幅比例是2:3:5，运行时间测试这部分的存在非常突兀，但我不想把这部分剔除。&lt;/li&gt;
&lt;li&gt;标题包含“单元测试”就是想说明，下文介绍的内容都能在单元测试层面实现，并指导编码。&lt;/li&gt;
&lt;li&gt;“基于特性的测试”在网上有诸多争议性观点，我试着对其中一些给出基于自己理解的解释。&lt;/li&gt;
&lt;li&gt;文中唯一的举例代码所用的编程语言为Java，无需担心的是，不同语言到撰文止都已有各自的成熟的基于用例的和基于特性的测试库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-对运行时间的测试&#34;&gt;1. 对运行时间的测试&lt;/h2&gt;
&lt;p&gt;解决方案是在&lt;a href=&#34;https://book.douban.com/subject/11614538/&#34;&gt;《The Clean Coder(程序员的职业素养)》&lt;/a&gt; 中读到的。
书里的一段对测试用例的协商对话（7.2验收测试）无意间描述了这个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试人员A：该函数运行时间不应超过两秒。&lt;/li&gt;
&lt;li&gt;测试人员B：无法为“不应超过两秒”编写测试，我们可以引入概率，即保证99.5%情况下符合。&lt;/li&gt;
&lt;li&gt;测试人员A: 如果要编写循环1000次测试，期望超时次数小于5，这个用例将耗时1小时，不现实。&lt;/li&gt;
&lt;li&gt;测试人员B: 可以执行15次操作，期望运行时间确切为2秒的
&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%88%86%E6%95%B8&#34;&gt;Z-score（标准分数）&lt;/a&gt;
大于2.57。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述对话提到了两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要用概率约束关于性能的需求，这种需求才可编写测试体现。&lt;/li&gt;
&lt;li&gt;合理运用抽样统计思想可减少测试所需的重复运行次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;在勉强把它归为一类吗&#34;&gt;在勉强把它归为一类吗？&lt;/h3&gt;
&lt;p&gt;嗯，有自觉。在单元测试层面，因测试框架对程序的控制权有限，能测的所谓“性能”仅仅指运行时间。
这个方式本质算作第二种“基于用例的测试”，但它的期望目标比较特殊，所以单独提出来介绍印象会比较深。&lt;/p&gt;
&lt;p&gt;虽然提起性能就是集成测试，需求中对性能要求的范围也往往是整个流程链路，
但这个确实能在单元测试层面实现。
比如每个高级些的语言都会有查看当前时间戳的库函数，
调用前后计算差值，就能得到与真实情况偏差不大的运行时间。
注意测试框架往往提供方式限制单个测试用例的运行时间，
那个的设计意图是防止单个用例影响整体测试运行，
不适合用来测运行时间，因为不能测量重复运行，单样本在统计学上不能验证假设。&lt;/p&gt;
&lt;p&gt;在单元测试中测试运行时间有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要等到集成测试时发现问题再打回来优化，fall fast嘛，至少保证这部分没有拖后腿。&lt;/li&gt;
&lt;li&gt;根据“单元测试指导编码”的原则，如果对模块的内部的函数有不同实现方案，
该函数运行负担较重且可测试，就可计算并利用运行时间作为方案取舍的参考。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-基于用例的测试example-based-testing-ebt&#34;&gt;2. 基于用例的测试(example-based testing, EBT)&lt;/h2&gt;
&lt;p&gt;用例本该用来翻译case或use case，这是术语，
但想了想还是把example翻译成用例合适，搜了下中文的博客也都用的这个翻译。
清楚与明确，就是EBT的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于计算类函数，可以做边界值测试。&lt;/li&gt;
&lt;li&gt;对于功能类函数（后端CRUD工作），可以写个冒烟测试（冒烟是集成测试的术语，在此借其定义）检查代码能否正常工作。
或者输入异常测试数据、给桩mock异常反应，测试被测函数的异常处理流程。&lt;/li&gt;
&lt;li&gt;TDD时需要故意写使测试失败的测试用例以启发编码，这是标准操作流程。&lt;/li&gt;
&lt;li&gt;再比如你想逐步debug，使用EBT可以让你清楚地知道程序走到每一步时应有的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;运用设计模式简化构造复杂测试数据实例的过程&#34;&gt;运用设计模式简化构造复杂测试数据实例的过程&lt;/h3&gt;
&lt;p&gt;在MVx架构模式族中，中间模块的方法的参数通常是领域定义的Model，Model的某种集合，甚至主Model嵌套属性Model。
关于如何简生成过程，有以下内容供参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java语言，&lt;a href=&#34;https://stackoverflow.com/questions/12568742/generating-test-data-for-unit-test-cases-for-nested-objects&#34;&gt;StackOverFlow上的这个问题&lt;/a&gt;
可能对你有所帮助。你也可以用&lt;a href=&#34;https://projectlombok.org/&#34;&gt;Lombok库&lt;/a&gt; ，
它的&lt;code&gt;@Builder&lt;/code&gt;注解可以生成Builder模式的对象构造代码。
或者IDEA编辑器，也有生成Setter方法的功能，但Builder模式比调用Setter构造对象方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非Java语言，&lt;a href=&#34;http://www.natpryce.com/articles/000714.html&#34;&gt;这篇博客&lt;/a&gt; 中提到的几个设计模式，
比如&lt;a href=&#34;http://wiki.c2.com/?ObjectMother&#34;&gt;Object Mother(数据生成工具类)&lt;/a&gt; ，&lt;a href=&#34;https://wiki.c2.com/?TestDataBuilder&#34;&gt;Builder&lt;/a&gt;
可以简化重复的构建语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示范代码&#34;&gt;示范代码&lt;/h3&gt;
&lt;p&gt;下面示例代码使用Java语言及其下的测试框架与库：
&lt;a href=&#34;https://junit.org/junit5/&#34;&gt;Junit&lt;/a&gt; ，&lt;a href=&#34;http://hamcrest.org/&#34;&gt;Hamcrest&lt;/a&gt; ，
&lt;a href=&#34;https://site.mockito.org/&#34;&gt;Mockito&lt;/a&gt; 。
目的是测试MVC模型中一个Service的getEntitiesBy()方法的正常逻辑(略去部分代码)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设定环境&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;假设DB中存在（对Mapper进行mock）与输入Request内容对应的记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;期望&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 桩：该方法会使用输入的Request中的索引值&amp;quot;normal&amp;quot;调用Mapper查询数据库，获取对应记录包装成的Entity Model。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 返回值：该方法应返回一个消息代码为&amp;quot;ok&amp;quot;的Response对象，其数据应为一个Entity对象的列表，首个元素的状态应与Mapper返回的对象相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// -------service.ServiceTest
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Given-When-Then - Behavior Driven Development (BDD)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;withNormalResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;normal&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// given, Mockito
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;given&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;willReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// when
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buildRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// then, Hamcrest, 对调用的返回值的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ok&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actual&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Mockito, 对被测调用桩时传入的参数的期望
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArgumentCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;forClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;verify&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;times&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getEntitiesBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;capture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mapperArgCaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;assertThat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;whatMapperGot&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 构造Mapper桩所返回的测试数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;buildDummyMapperReturn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Collections&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;singletonList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setCategory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dto.Response
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Lombok
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Entity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// -------dao.entity.Entity
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Getter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Setter&lt;/span&gt;
&lt;span class=&#34;nd&#34;&gt;@Accessors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Entity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-基于特性的测试property-based-testing-pbt&#34;&gt;3. 基于特性的测试(property-based testing, PBT)&lt;/h2&gt;
&lt;h3 id=&#34;名词解释&#34;&gt;名词解释&lt;/h3&gt;
&lt;p&gt;实在不好意思，我得先让你读一些难懂的名词定义，
关键内容大多是从&lt;a href=&#34;https://book.douban.com/subject/35006892/&#34;&gt;《程序员修炼之道(第2版)》&lt;/a&gt; 抄来的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例程（routine）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“例程是某个系统对外提供的功能接口或服务的集合。
比如操作系统的API、服务等就是例程；
Delphi或C++Builder提供的标准函数和库函数等也是例程。” &amp;ndash;&lt;a href=&#34;https://baike.baidu.com/item/%E4%BE%8B%E7%A8%8B/2390628&#34;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;契约式设计（development based on contract, DBC, 或contract-driven development）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;出自&lt;a href=&#34;https://archive.org/details/objectorientedso00meye_0&#34;&gt;《面向对象软件构造(Object-Oriented Software Construction)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前置条件：例程期望自己运行前环境的状态符合它运行的需求。&lt;/li&gt;
&lt;li&gt;后置条件：例程保证自己退出时，环境的状态是什么样子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的不变式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从调用者的角度来看，类会确保不变式始终为真。&lt;/li&gt;
&lt;li&gt;在例程的内部处理期间，可以不遵守不变式，但退出时不变式需为真。&lt;/li&gt;
&lt;li&gt;因为Eiffel是OO语言，所以《OOSC》的作者将该概念命名为“类”的不变式，
实际上这个名词指的是例程所依靠的模块的内部状态，在OO语言里，就是类实例的状态。
《修炼之道》作者指出，在函数式语言中，状态是在函数间传递的数据本身，不变式概念依然有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例程与调用者的契约：
&lt;ul&gt;
&lt;li&gt;如果调用者满足例程所有前置条件，则例程保证退出时所有后置条件和不变式为真。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果任一方没有履行契约，就会调用（之前同意的）补救措施——抛出异常，或程序终止。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于特性的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《修炼之道》：契约和不变式放在一起并称为特性，我们基于它做自动化测试。&lt;/li&gt;
&lt;li&gt;PBT库Hypothesis的作者的&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;解释PBT概念的文章&lt;/a&gt; ：
&lt;ol&gt;
&lt;li&gt;内部对调用者透明(&lt;a href=&#34;https://hypothesis.works/articles/referential-transparency/&#34;&gt;referential transparency&lt;/a&gt;))&lt;/li&gt;
&lt;li&gt;指定随机实例的类型(types)&lt;/li&gt;
&lt;li&gt;随机生成(randomization)&lt;/li&gt;
&lt;li&gt;对相关工具的使用(the use of any particular tool or library)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;只有ebt还不够&#34;&gt;只有EBT还不够&lt;/h3&gt;
&lt;p&gt;EBT优点在精准，缺点在太精准。一言以蔽之，EBT引入了太多主观且与需求无关的细节，且能测试到的代码运行路径的覆盖率及其有限。&lt;/p&gt;
&lt;p&gt;甚至个别用例会导致类似机器学习过拟合的效果，让代码偏离了原本的意图。
这更多是错认为“测试所表达的意图不会变且一直正确”的思维陷阱所导致的。
在EBT中，测试用例就是主观对需求的理解，需要在修改功能时不断检查无法通过的测试是否仍具有意义。
比如TDD实践中所使用的单元测试方式就是EBT，
在这篇记录两个开发者使用TDD流程结对编程实现一个Kata的
&lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/home/articles/the-bowling-game-an-example-of-test-first-pair-programming&#34;&gt;文章&lt;/a&gt;
中，两人会讨论“是否该把之前写的一个测试用例删除，因为它所代表的操作已不会在现实发生，虽然之前是有意义的”，还好他们凭经验避开了。&lt;/p&gt;
&lt;p&gt;从EBT转向PBT，像从&lt;a href=&#34;https://en.wikipedia.org/wiki/Programming_paradigm&#34;&gt;命令式(imperative)编程范式&lt;/a&gt; 到声明式(declarative)编程范式的转变。
命令式是给出具体过程的实现，就像EBT要明确构造调用被测函数时的测试数据的状态。
而声明式只是声明想做什么，具体过程交给解释器，
PBT也是只对特性的假设下准确定义，但关于在抽象定义的特性的限制下如何生成大量测试数据，交给PBT库。
这样我们仅仅给出了足够定义特性的信息，而没有引入对具体取值的依赖，符合&lt;a href=&#34;https://en.wikipedia.org/wiki/Interface_segregation_principle&#34;&gt;ISP原则&lt;/a&gt; 。
两者仅在对测试数据的构造方式上有差别，而对于被测函数的期望两者是相同精确的，都要明确写成assert, expect&amp;hellip;语句。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://increment.com/testing/in-praise-of-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 里不仅有关于EBT与PBT的代码级比较，还有使用PBT发现EBT难以暴露的bug的两个真实案例。&lt;/p&gt;
&lt;p&gt;不过我个人认为，PBT并不能完全取代EBT，比如边界值这个案例，
如果不是CI那种持续地测，没准儿只运行一次单元测试没能随机出特定的边界值呢。
而且两者也不互斥，可以针对同一个API写两种测试，更可靠。&lt;/p&gt;
&lt;p&gt;另外，我看到不止一个地方这样描述PBT：它会给你带来惊喜。&lt;/p&gt;
&lt;h3 id=&#34;pbt和fuzzing概念的区分&#34;&gt;PBT和Fuzzing概念的区分&lt;/h3&gt;
&lt;p&gt;PBT很像小到被测函数范围的&lt;a href=&#34;http://en.wikipedia.org/wiki/Fuzzing&#34;&gt;Fuzzing&lt;/a&gt; ，
目的是用大量随机输入无情地对待代码，尝试找出它代码上没有体现到，但是需求上承诺要做到的特性
（对于Fuzzing来说，被测软件应该承诺做到尽可能的鲁棒性和安全性）。
&lt;a href=&#34;https://hypothesis.works/articles/what-is-property-based-testing/&#34;&gt;这篇文章&lt;/a&gt; 阐述了两者间差别与相同之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fuzzing是完全由计算机控制的随机过程，而PBT在随机的范围上基于特性进行了人为限定。&lt;/li&gt;
&lt;li&gt;PBT工具与Fuzzing工具在运行流程上高度相似，两者可相互替代使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个区别上我们也能看出，PBT不仅会利用计算机的随机与自动化摆脱思维对需求的偏见，
还能反过来促使开发人员思考总结并用代码表达出函数真正的、广范围的契约与不变式。
PBT可作为单元测试的一种方式，在单元测试层面，其最重要目的也是“启发编码”。&lt;/p&gt;
&lt;h3 id=&#34;pbt到底在哪个概念层级&#34;&gt;PBT到底在哪个概念层级&lt;/h3&gt;
&lt;p&gt;我认为PBT的明确对立概念应该是EBT，发生混淆的原因有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EBT已与太多的熟悉的概念绑定：TDD实践中明确使用EBT，谈起单元测试就是EBT；
谈起集成测试、QA以及更高层的测试，也是用具体的测试集去书面化需求文档，
测试集大多为EBT（但同时也存在引入随机测试数据的测试平台）。&lt;/li&gt;
&lt;li&gt;PBT运行时间多于EBT，不符合单元测试或者TDD要求的秒级结果反馈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可能会看到有观点说单元测试、TDD和PBT是对立的概念，《修炼之道》里部分文字也有这个意思。
当人们使用对比手法介绍PBT时，如果无法把EBT这个细类概念从大类概念中抽出，并明确地指出来，就会无意中造成这种表达理解上的误差。&lt;/p&gt;
&lt;p&gt;也有观点说PBT独立于单元测试、集成测试等测试层级概念，是“额外的一类测试”，我反对这个观点。
首先，我了解到的几个现有的PBT库都兼容在了原先存在的为EBT编写的成熟测试框架下，
或者应该说是测试框架逐渐变成了无关测试方式的抽象框架，这是事实依据。
其次从定义上区分，测试层级描述的是项目活动，区别主要在参与该活动的&lt;a href=&#34;https://en.wikipedia.org/wiki/Project_stakeholder&#34;&gt;项目干系人(stakeholder)&lt;/a&gt; 
的类别，和运行时对系统覆盖的范围，和PBT所定义的东西相差甚远。
PBT可以用在单元测试中，也可以用在集成测试中，它描述的仅仅是一种构造测试数据的思路。&lt;/p&gt;
&lt;h3 id=&#34;我认为单元测试中可以使用pbt&#34;&gt;我认为单元测试中可以使用PBT&lt;/h3&gt;
&lt;p&gt;在编程实践而非项目管理定义上，单元测试（和组件测试，组件测试在定义上比单元测试多涉及一个mock）有几个共识的特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由开发人员为指导编码所写。&lt;/li&gt;
&lt;li&gt;被测代码范围最大为单个模块，我们会使用Mock技术编写模块所依赖的桩，
模拟上层调用者调用模块的API，模拟被测模块的上下文。&lt;/li&gt;
&lt;li&gt;自动化与可重复运行。&lt;/li&gt;
&lt;li&gt;测试粒度比集成测试等包含多模块的层级更细。&lt;/li&gt;
&lt;li&gt;测试反映了开发人员对代码行为的期望。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以判断说PBT没有违反上述单元测试的定义。PBT与单元测试的矛盾大概在运行时间上。&lt;/p&gt;
&lt;h4 id=&#34;单元测试运行时间的大部分受不可控因素影响&#34;&gt;单元测试运行时间的大部分受不可控因素影响&lt;/h4&gt;
&lt;p&gt;TDD等倡导测试优先的学派，为了实践需要，额外为单元测试增加了“测试集运行速度需缩短到秒级”的要求。
这个要求是基于现代电脑的高性能前提提出的，而且我猜测，单元测试被TDD概念反过来影响，加之开发人员们主观感受，
认为单元测试就是而且应该是很快的。&lt;/p&gt;
&lt;p&gt;但我们在实践中已经了解到，一旦引入Mock机制，运行一次某个类对应的单元（严格来说是组件）测试的总时间，
绝大部分为测试框架执行mock加载上下文的时间，正比于我们想测的模块所涉及的依赖的启动复杂程度。&lt;/p&gt;
&lt;p&gt;举例，以我的经验（大概只是工作电脑性能低），对于Java的Spring-boot应用中的单个Junit测试类，
使用&lt;code&gt;@RunWith(MockitoJUnitRunner.class)&lt;/code&gt;最快，大概启动10秒左右；
如果要用&lt;code&gt;@RunWith(SpringRunner.class)&lt;/code&gt;，&lt;code&gt;@SpringBootTest&lt;/code&gt;就要启动30多秒；
如果被测代码还包含从配置文件中读取配置的内容，需要额外用&lt;code&gt;@TestPropertySource&lt;/code&gt;在启动时导入测试配置文件，
又要加个10秒左右。
不管测一个方法还是测所有方法也是加载同一个上下文，最小化上下文还是需要这么多启动时间。
肯定每次运行时都要看控制台里application启动时慢慢输出的log，然后刷刷两下所有用例都测完，测试退出。
这类代码从实践上考虑就无法使用TDD开发，但这些测试就是它们的单元测试。&lt;/p&gt;
&lt;p&gt;我个人认为，正确理解单元测试的速度要求需要&lt;strong&gt;相对于&lt;/strong&gt;集成测试来说，
单元测试相比集成测试运行时间低至少一个数量级，这种说法是对的。
同时通过Mock这个例子，我们发现单元测试的运行时间取决于代码的依赖的复杂度、电脑性能等不可控因素上
（有些牵强？哈哈抱歉，大概就是想表达这么个意思，没讨论到的因素还有很多）。&lt;/p&gt;
&lt;h4 id=&#34;单元测试中能否用pbt取决于具体欲测特性的复杂度&#34;&gt;单元测试中能否用PBT，取决于具体欲测特性的复杂度&lt;/h4&gt;
&lt;p&gt;这个说法真模糊啊，但我只能拿出这种说法了。
你看，单个PBT用例相比单个EBT用例，慢就慢在要测多于一个测试数据，加上生成数据的时间，关键在运行时间。
但是生成数据的范围和单个数据测试的时间又是由特性决定的，下面分别对两方面解释一下。&lt;/p&gt;
&lt;p&gt;关于大家和PBT库认为单个PBT用例的运行次数，或者说生成测试集的大小，我搜索的结果是，
从提供限定大小的参数的库，到默认100个的固定数量的随机测试集的库，
到正统的不许设定数据集大小，粒度只能指定到数据类型，需要持续运行测试的看法，都有。
首先，肯定运行越多越好，持续集成里的测试可以这么写。其次，单元测试肯定受不了相对较长的运行时间。&lt;/p&gt;
&lt;p&gt;《修炼之道》给的介绍PBT的例子有这两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行100次，随机列表作为输入，测试排序方法调用前后列表长度没变，排序结果正确，运行时间0.95秒。&lt;/li&gt;
&lt;li&gt;运行100次，从大小为4的集合中随机取元素作为输入，测试“库存始终大于0”不变式，找到了bug，没写运行时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;嗯，第二个例子100次不算多，能找到bug是因为这个bug比较“容易”被引爆，“容易”是个主观定性的词，描述了这个特性的复杂度。
&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;这篇文章&lt;/a&gt; 里介绍了一些PBT常见模式，
不少模式（所代表的特性）复杂度并不高。&lt;/p&gt;
&lt;p&gt;鉴于我们的单元测试时间可能大部分还是会消耗在执行mock上，花10秒运行1000次测试来测试一个特性，
这样对整个模块的PBT单元测试大概要跑几分钟（共十几个特性），似乎是可以接受的。&lt;/p&gt;
&lt;h3 id=&#34;如何构造pbt所需测试数据&#34;&gt;如何构造PBT所需测试数据&lt;/h3&gt;
&lt;p&gt;基本&lt;a href=&#34;https://hypothesis.works/articles/quickcheck-in-every-language/&#34;&gt;每个编程语言都有PBT库&lt;/a&gt;
（这篇2016年的文章信息稍有过时），
这类PBT测试库通常会提供，对其服务的语言的原生库内的类的实例的随机构造方法。
有点绕，用Java下的&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/basic-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 
库举例就是：该库会提供对Java基本类型、String、常用集合类、Date等类的随机构造方法。
这种构造方法因库而异，在提供给用户使用的方式上稍有不同，
比如&lt;a href=&#34;https://pholser.github.io/junit-quickcheck/site/1.0/usage/other-types.html&#34;&gt;junit-quickcheck&lt;/a&gt; 使用参数上的注解，
Python下的&lt;a href=&#34;https://hypothesis.readthedocs.io/en/latest/quickstart.html&#34;&gt;Hypothesis&lt;/a&gt; 使用方法上的注解。&lt;/p&gt;
&lt;p&gt;这样方便你写测试时进一步构造自己软件所在领域的Model之类的实例。
构造方式与PBT相似，还是要运用上文EBT部分所述的技巧自己手工编写，
只是把Model的属性赋值部分换成库提供的随机生成方法。
具体到代码，可以参照&lt;a href=&#34;https://dev.to/quii/property-based-testing-in-real-life-4db8&#34;&gt;这篇文章&lt;/a&gt; 的做法。&lt;/p&gt;
&lt;h3 id=&#34;更多关于pbt的参考内容&#34;&gt;更多关于PBT的参考内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个叫jqwik的Java PBT库的&lt;a href=&#34;https://jqwik.net/property-based-testing.html&#34;&gt;介绍页面&lt;/a&gt; 给出了不少关于PBT的资料。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;文章 Property-based Testing Patterns&lt;/a&gt; 
易懂地说明了PBT中可遵守的一些模式，可根据这些模式来指导总结代码中的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;希望这篇文章给你讲明白了，或者至少你可以把所有参考资料读一遍，自己形成理解。
试试在工作中把PBT用起来，如果害怕擅自导入PBT包被发现，不提交至VCS就行。
顺带一提我还没实践过，打算下次迭代时试试。我预计即使是后端日常CRUD功能，
根据那篇&lt;a href=&#34;https://blog.ssanj.net/posts/2016-06-26-property-based-testing-patterns.html&#34;&gt;PBT Patterns文章&lt;/a&gt; 
，针对数据变换或判断的方法都可能能总结出特性。&lt;/p&gt;
&lt;p&gt;抛砖引玉，欢迎在评论中指点指正，或给出另一个角度的看法，好让我对这些概念了解更深。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>对适用于个人的电子数据备份体系的总结</title>
                <link>https://boholder.github.io/blogs/individual-data-backup-summary/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/individual-data-backup-summary/</guid>
                <pubDate>Mon, 07 Dec 2020 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;p&gt;本文中个人电子数据特指&lt;strong&gt;只凭大脑记不住或可能随时间遗忘模糊的&lt;/strong&gt;、 
对拥有其的个人来说该部分数据&lt;strong&gt;丢失或泄露将会对本人社会参与状态或本人身心状态造成不利影响的&lt;/strong&gt;，
电子数据（下文简称“数据”）。
数据保存在电子介质上，且只能通过电子设备读写， 这意味着可能需要购买额外设备以满足对其保存、处理的需要。&lt;/p&gt;
&lt;p&gt;本文在引用所有没有对应术语级定义的自创名词时，将使用大括号高亮该名词，防止读者迷惑（例：【自创名词】）。
同时本文使用反引号引用上文已提到的有对应术语的名词（例：&lt;code&gt;术语名词&lt;/code&gt;）。
本文为作者因愚蠢与意外，丢失了四个半月工作数据的反思总结文。本文内容仅个人见解，欢迎指点与讨论。&lt;/p&gt;
&lt;h2 id=&#34;数据重要性分级&#34;&gt;数据重要性分级&lt;/h2&gt;
&lt;p&gt;数据按重要性（丢失后的损失大小）分为几个等级。&lt;/p&gt;
&lt;h3 id=&#34;一级&#34;&gt;一级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密密钥：
&lt;ul&gt;
&lt;li&gt;用于解密被加密的大块数据，但数据丢失对应加密密钥也没用了&lt;/li&gt;
&lt;li&gt;即它与它所加密的数据相互依赖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TOTP(Time-based One-Time Password)的seed：
&lt;ul&gt;
&lt;li&gt;保有它本身能生成TOTP6位数字，&lt;/li&gt;
&lt;li&gt;即它不依赖于其他（已经被输入验证器APP中且无法提取出的）数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台账户、软件激活序列号、平台登录Licence&amp;hellip;&amp;hellip;统称“凭证”：
&lt;ul&gt;
&lt;li&gt;等同于&lt;code&gt;加密密钥&lt;/code&gt;，是“access大块数据的凭证”。&lt;/li&gt;
&lt;li&gt;它对应的“加密”数据通常不由个人保存（平台服务）或易于再取得（付费软件）。&lt;/li&gt;
&lt;li&gt;即它不依赖于其“加密”的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积小，通常很难超过100MB，该特征对&lt;code&gt;多副本备份&lt;/code&gt;要求有利，易于保存在多个存储媒介上。&lt;/li&gt;
&lt;li&gt;价值大，该类数据的确认丢失通常伴随着不可挽回的巨大损失，欲哭无泪的那种心情。
（还好平台账户还能找回密码！）&lt;/li&gt;
&lt;li&gt;你不想让它公开（加密），也不想彻底丢失它（多副本备份）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存&lt;/li&gt;
&lt;li&gt;多副本备份，包括本地存储专用设备（移动硬盘，家庭NAS）和网盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二级&#34;&gt;二级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;个人信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常被以“个人隐私”统称，因个人经历生成、或包含可识别特定个人的身份信息，多为文档、多媒体类型。&lt;/li&gt;
&lt;li&gt;此处只且只能关心你&lt;strong&gt;可以控制&lt;/strong&gt;的部分（，
至于上传到外部或在外部平台上产生的，最好在源头控制它，即永远上传最无关自己现实身份的最少信息，
相信我，遵守该原则不会影响网络社交行为，这个话题和论证可以另外写一本书的量，就此打住）。&lt;/li&gt;
&lt;li&gt;属于【个人信息】的文件举例：求职简历等“个人信息汇总提交型文档”，包含本人脸部（哪怕是低分辨率的非正脸）的照片视频，
与他人在网络上的交流记录（聊天记录、邮件、别人发来的内含自己信息的文档等）
&lt;ul&gt;
&lt;li&gt;【个人信息】和&lt;code&gt;凭证&lt;/code&gt;的差别在于文件体积大小和含义，&lt;code&gt;凭证&lt;/code&gt;就像钥匙，而【个人信息】就是宝藏本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他因人而异的想保密的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如虽然和狭义上的【个人信息】无关，但仍包含在广义的“个人隐私”中的部分（比如与个人兴趣相关的数据）。&lt;/li&gt;
&lt;li&gt;所有你不想让它公开或泄露的数据（不管它是否不宜公开，你有天然的权利使它保密，至少是权力）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;体积不定且随年龄增大（经历增多）而增大，视个体兴趣性格职业差异，
体积多数可控制在500G之内（爱拍照摄影的时尚达人们可能仍不满足这个已经被高估的容量）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;价值不定，但对你来说这些是重要的，这就足够作为执行备份的理由了。
（对你有兴趣的坏东西和好朋友通常也对这些信息感兴趣。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加密保存（加密所用密钥可保存在【一级数据】中）&lt;/li&gt;
&lt;li&gt;至少一份完整的本地备份，和可选的网盘备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三级&#34;&gt;三级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在电子设备使用过程中积累在硬盘中的一般数据，包括程序和操作记录、文档等：
&lt;ul&gt;
&lt;li&gt;加密与否无关紧要，但一般来说不会想丢失它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;体积非常大，但只需要购买容量适合自己需求（包括未来几年的潜在需求）的额外存储设备。&lt;/li&gt;
&lt;li&gt;价值较小，但值得花费钱和精力加一道保险。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少一份完整的本地备份&lt;/li&gt;
&lt;li&gt;还要考虑定期将仅仅是存储在硬盘中但不常用的大文件转移到存储专用设备中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他与加密和备份相关的个人见解&#34;&gt;其他与加密和备份相关的个人见解&lt;/h2&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;p&gt;来推荐工具吧！作者已使用好几年且现在仍然在使用&lt;a href=&#34;https://www.veracrypt.fr/en/Home.html&#34;&gt;VeraCrypt&lt;/a&gt;
(&lt;a href=&#34;https://github.com/veracrypt/VeraCrypt&#34;&gt;github项目地址&lt;/a&gt;)
作为所有加密相关操作的工具软件，开源、多平台且功能完备，而且曾经停滞过几年的它现在又活跃起来了！
还有什么比一个长久又仍在活跃的开源软件项目更棒的呢。VeraCrypt既可以加密整个Driver
（驱动器？盘？我还是用英文吧）， 又可以建立一个强加密的“文件型Driver”，
解密挂载时是一个可存取文件的盘，卸载后就是一个Portable的文件。
Portable=可以当作普通单一文件进行备份处理，完美。&lt;/p&gt;
&lt;p&gt;有个非程序小缺陷，直接从官网下载时非常慢，50kb/s(35M total)，且只能单线程请求数据。
别担心，我们还有&lt;a href=&#34;https://sourceforge.net/projects/veracrypt/&#34;&gt;sourceforge的分流&lt;/a&gt;。
（注意！不要被VeraCrypt的文件Driver功能迷惑了眼睛，
作者就是因为不读文档没做备份鲁莽试用Bitlocker时，将备份密钥存入文件Driver，
忘记了该文件本身储存在设置了Bitlocker的Driver中，迷惑操作。）&lt;/p&gt;
&lt;p&gt;对于Windows专业版用户来说，
&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview&#34;&gt;Microsoft Windows BitLocker&lt;/a&gt;
也是一个趁手的工具，作为商业级软件，它使用方便，且有微软的持续质量支持。但它只能加密Driver，
因此与备份操作结合时不太方便。使用BitLocker软件加密的Driver，
在备份前需要手动解密，或设置开机（登录）后自动解密，这样备份操作才不会因读取Driver失败而失败。
作为副作用，这会让加密文件在备份过程中暴露在可被读取的未加密状态下，因此对备份时环境的安全性（断网关服务）要求严格些。&lt;/p&gt;
&lt;p&gt;不好意思，作者对Mac和Linux的常用软件集合了解不多，无法介绍对应其上的平台独有软件，
VeraCrypt是多平台的，或许你可以先试试它。&lt;/p&gt;
&lt;p&gt;特别的，对【一级数据】而言，加密保存指使用另外一个人类可读的密钥（俗语：密码）
加密存有【一级数据】的独立的Driver（或其他可独立转移的“数据集合结构”）。
这要求你至少记住这么一个“主密钥”，“主密钥”用来解密出其他密钥。
作者使用VeraCrypt提供的文件Driver保存此类信息，该方法很原始，但作者固执认为它“更安全”。
市面上还有许多诸如&lt;a href=&#34;https://1password.com/zh-cn/&#34;&gt;1Password&lt;/a&gt;等直接提供此类信息加密与备份服务的软件，
甚至连Firefox，Chrome等现代浏览器中就内置了网站密码管理服务，稍加尝试就能找到合你口味的。&lt;/p&gt;
&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;
&lt;p&gt;考虑备份要首先识别需要被备份的数据主体，
可以认为一个主体是一个包含多个同类文件的，可独立转移的集合。
举例，对于作者来说，有一个【一级数据】，
两个【二级数据】（个人保密文档和工作保密文档），
五个【三级数据】（家里台式机，家里笔记本，工作笔记本，手机，平板电脑）
（手机和平板电脑是独特的，它们实际上是备份在电脑硬盘的【三级数据】部分中，
它们本身属于一二三级混合，作者的方案是将它们的备份加密（作为【二级数据】处理），
但随电脑的【三级数据】备份。）&lt;/p&gt;
&lt;h4 id=&#34;备份位置&#34;&gt;备份位置？&lt;/h4&gt;
&lt;p&gt;因为数据保存在电子介质上，是基于物理存在的存储设备的，
因此对于备份位置的选择，作者没有考虑过同存储位置内的冗余备份，
而是做到硬件级隔离，先不管地理位置（在抽屉里的移动硬盘还是地上的NAS还是网盘服务的主机集群中），
至少是硬盘级别的隔离。&lt;/p&gt;
&lt;p&gt;举例：作者本人讨厌网络存储服务且没有多设备大量转移数据的需求（主观+客观原因），
因此没有使用客观来讲确实经济实惠又方便的网盘服务。
作者也没有设置家庭NAS，只是购买了两块大容量移动硬盘，
定期把【二级数据】和【三级数据】备份在两块硬盘上，
一块在公司柜子里，一块在家里，四舍五入也算异地容灾了，容个火灾和人祸。
至于【一级数据】，保存在家里台式机、家里笔记本电脑、两块移动硬盘、公司笔记本电脑，共五个备份。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经过这次意外后作者决定将【一级数据】和【二级数据】额外上传到Microsoft OneDrive上，
反正加密了，备份数量多多益善，而且大小不是很大，能快速完成备份。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：【一级数据】最好存在于每个【二级数据】所在的备份位置中，因为两者相互依赖，
可以理解为钥匙配得比宝箱数量多，钥匙放在每一个宝箱旁，还有“主密钥”做为钥匙的保护机制。
（像作者这种使用独立加解密软件的人，还需要额外将加解密软件的免安装便携版与【一级数据】和【二级数据】放在一起）&lt;/p&gt;
&lt;h4 id=&#34;备份频率&#34;&gt;备份频率？&lt;/h4&gt;
&lt;p&gt;这是作者本次经历的人祸所暴露出的备份体系中的最大问题，
&lt;strong&gt;备份不够频繁&lt;/strong&gt;，准确的说是对于公司笔记本电脑备份不频繁。
作者决定将之后的备份频率设置到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家中和公司的本地移动硬盘上每周备份一次（顺便备份手机与平板电脑）。&lt;/li&gt;
&lt;li&gt;家中和公司的两个移动硬盘每月交叉形成两份完整备份。&lt;/li&gt;
&lt;li&gt;【一级数据】和【二级数据】在电脑上设置自动网盘上传，每次更改过后就上传。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;备份间的自动化同步问题&#34;&gt;备份间的（自动化）同步问题&lt;/h4&gt;
&lt;p&gt;这个问题又要体现网盘的优势了，经过体验，OneDrive在Windows上可以做到实时备份，
可以使用该特性保证联网存储设备上备份间的一致性。
如果不想使用网盘服务，也可自建家庭NAS，
只要是能保证储存设备间相互联网，总能有现成的解决方案建立起自动化的数据同步系统。
比如Windows10系统自带的&amp;quot;备份&amp;quot;功能，可做到目录级粒度最短每10分钟同步一次。&lt;/p&gt;
&lt;p&gt;但是无法联网的设备，比如我那两块移动硬盘，我把它看作商业级方案中的“磁带仓库”————
容量大且便宜，保存介质稳定，但无法通过网络读写。
只能通过手动操作的方式对其进行备份更新，但最多也只是按时把它拿出来插在电脑上，
剩下的应交给只需手动配置一次的电脑上的软件级备份工具。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;本来作者的备份频率是一个月一次，在家里有好好遵守设定好的TODO为设备备份，
但公司的电脑因为嫌沉发懒，一直没带回家，加之上班就是工作下班就是回家，
这几个月都没在公司专门为工作笔记本备过份。
更灵异的是，在出事前的昨天晚上，作者看视频时脑中突然蹦出“好像工作笔记本好久没备过份了”，
随即被视频的精彩打消了顾虑，或许是冥冥中注定一劫让我清醒过来吧。
还是要感谢这次意外的，因为虚假的安全比不设保险更危险。
另外一个基于SRE理论的感悟是，重要操作前先备份，
但别忘了&lt;strong&gt;无法做到先备份则应停止继续重要操作，Process fall in safe&lt;/strong&gt;。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/thought/">thought</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/sre/">SRE</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>TDD实践经验分享与对TDD实践程度的讨论</title>
                <link>https://boholder.github.io/blogs/tdd-tips-zh/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/tdd-tips-zh/</guid>
                <pubDate>Fri, 17 Jul 2020 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;0对读者的知识要求前言&#34;&gt;0.对读者的知识要求&amp;amp;前言&lt;/h2&gt;
&lt;p&gt;要求：简单掌握任一编程语言，明白“软件测试”的定义、类别与各测试类别的作用。&lt;/p&gt;
&lt;p&gt;去年刚写这篇文章（20200717）时，我第一次在《代码整洁之道》系列书中读到TDD的概念与好处，
并试着在工作中实践了一个月，写这篇文章的目的是分享实践中摸索与网上搜索到的TDD实践技巧。
今年我读了更多的书，感觉对TDD的理论与实践多了解了一些，更新打的“补丁”字数也不少，
于是把标题改成更宽泛的“对TDD的实践的讨论”。&lt;/p&gt;
&lt;p&gt;本文分成几大部分：
第一部分，对TDD的实践技巧分享，我建议跳过第4小部分的经验细节，先把后面更新的观点类的文字读一读。
第二部分，给出“严格遵守TDD在实践上很困难”、“TDD部分流程不太‘务实’”的观点以及理由；
第三部分，摘录大量书籍《程序员修炼之道(第2版)》中的文字，给出可利用TDD优势而不会陷入教条的折中实践方案，
与对于“测试”概念的新颖理解方式。&lt;/p&gt;
&lt;p&gt;希望本文能消除你对于TDD概念与实践的疑惑，让你在平时编码时能够从TDD的思维方式中获得好处，而不必苦苦承受遵守TDD流程实践中的重复与艰难。&lt;/p&gt;
&lt;h2 id=&#34;1什么是tdd&#34;&gt;1.什么是TDD&lt;/h2&gt;
&lt;p&gt;TDD的全称是 “测试驱动开发（Test-driven development）”&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;
，“是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名”。&lt;/p&gt;
&lt;p&gt;一个TDD循环的简单流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个需求对应的测试，该测试以一个功能方法的 &lt;strong&gt;一部分逻辑&lt;/strong&gt; 为目标。&lt;/li&gt;
&lt;li&gt;编写简洁的业务逻辑代码，以通过测试。&lt;/li&gt;
&lt;li&gt;回归测试，运行和这部分逻辑相关的所有测试（或者简单的把整个测试类run一下），确认全通过。&lt;/li&gt;
&lt;li&gt;重构代码，修正步骤2中因思考逻辑而忽略的设计原则|设计模式（比如if-else中重复的代码可以提取成一个方法）。&lt;/li&gt;
&lt;li&gt;重新执行步骤3，确保重构没破坏功能。回到步骤1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2tdd的好处&#34;&gt;2.TDD的好处&lt;/h2&gt;
&lt;p&gt;在此引用Uncle Bob的《代码整洁之道-程序员的职业素养》（另，推荐阅读此系列书）一书中他第一次看到TDD的回忆：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;首先，他写了一个单元测试的一小部分，没几行代码。然后，他写了刚好能使那个测试通过的代码。
接着，他又写了些测试，然后再写一些代码&amp;hellip;从编码到运行的周期如此之短&amp;hellip;Kent居然每30秒运行一次（测试）程序&amp;hellip;
忽然，我发现这种周期似曾相识！许多年前，当我还是孩子的时候&amp;hellip;解释型语言,无需编译构建，你要做的只是添加一行代码，
然后执行，再添加，再执行&amp;hellip;使用这些语言的编程效率极高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（我看到“30秒”那里，就对TDD感兴趣了。）Bob大叔说得对，我们在刚开始编程时都有一个时期，小心翼翼，一次只加一行代码， 然后运行看看print出的变量值发生了什么变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;符合预期的变化会给我们信心，而且直白的目标使下一行要加的代码“呼之欲出”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是TDD的魔力所在。它鼓励你拿出勇气去重构（烂）代码，因为你不再害怕重构它有破坏功能的风险， 快速方便的回归测试集的re-run报告帮你撑腰。&lt;/p&gt;
&lt;p&gt;TDD还有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试的代码覆盖率接近100%。&lt;/li&gt;
&lt;li&gt;这些测试不仅是单元测试的一部分，也是代码形式的用例和文档。&lt;/li&gt;
&lt;li&gt;便于执行自动化回归测试（单元测试层面）。&lt;/li&gt;
&lt;li&gt;测试间相互隔离，鼓励每次循环时编写的新逻辑间保持松耦合。&lt;/li&gt;
&lt;li&gt;TDD要求测试先行，这有助于帮助开发人员拆解需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3我认为的实施tdd的知识要求&#34;&gt;3.（我认为的）实施TDD的知识要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;熟练使用当前项目所用语言的特性与类库，和单元测试工具。 前者减少因为不熟悉语言而卡壳愣住的概率，后者是使用TDD的硬性要求。&lt;/li&gt;
&lt;li&gt;会拆解需求，从理想情况到需求所定义的限制性条件，一步步增加条件。（第4部分中详细解释）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4实施tdd过程中的困惑和解决方案&#34;&gt;4.实施TDD过程中的困惑和解决方案&lt;/h2&gt;
&lt;p&gt;TDD理论说来容易，但如果自身技能不够扎实，只是从头疼怎么写业务代码转到头疼怎么写测试而已。 测试先行意味着，测试写得不够“好”，则直接影响开发人员进一步的思考方向，严重时会把开发人员带进思考泥潭。&lt;/p&gt;
&lt;h3 id=&#34;41不需要在编写测试时编写非法输入测试&#34;&gt;4.1.不需要在编写测试时编写非法输入测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：如何在使用TDD时保证代码的健壮性？是否需要考虑非法输入？&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：TDD时不需要。TDD之后，部分代码会需要，再加上就是。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;的第二个回答，&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;1.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;编写非法输入测试(比如输入NULL，空对象指针etc，这不是一个正规名词但涵盖范围正确）是QA（测试人员）的任务， 当他们测试时，会在至少是单元测试的层面的封装（或者调用链）上测试非法输入，这意味着 &lt;strong&gt;不是每个方法都要考虑非法输入&lt;/strong&gt; ，
而TDD的测试会覆盖到每个方法。 另外，在TDD之后而不是TDD时考虑这个部分，修改代码会更头脑清晰更方便（回归测试给的信心）。&lt;/p&gt;
&lt;p&gt;同时应该注意的是，如果业务逻辑本身要求“分情况考虑”， 那么像是数组长度=0，以及由“情况”的排列组合得出的对应的“合法的”边界测试（edge cases），就要在TDD时覆盖到。 正确实例：&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;
（这是一个优雅如禅宗公案的“kata”）最后，为了考虑逻辑的“周全性”而添加的两个测试。（一个输入情况对应一个测试）&lt;/p&gt;
&lt;h3 id=&#34;42避免错误的步子大的测试&#34;&gt;4.2.避免错误的步子大的测试&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我写出了下一个测试，但在编业务代码时卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：先排除自身编码不熟练的因素，然后检查这个测试，&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;是不是覆盖的逻辑太大了，重新写一个小一些的测试（4.3详解）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;3.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;酒要一口一口地喝，路要一步一步走，步子迈大了，容易_ _ _。————《让子弹飞》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在TDD过程中，业务逻辑编码只需要恰好满足使测试通过， 如果坚持住这个原则，那么唯一使编程步骤卡壳的原因就在于： 开发人员不能快速想出通过测试的方案，又陷入了使用TDD前的窘境————没有短又直白的编码目标，头疼怎么一步到位。
这个测试不能驱动编码思路&lt;em&gt;呼之欲出&lt;/em&gt;，说明这个测试有问题，需要重新换一个。 两个资料里都提到了这样含义的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免一个测试覆盖太大的逻辑范围，这违反了TDD单个测试对应小目标的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;错误实例：就像文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;中“我”在第一次分析需求时，选择了不明朗的测试“演化”方向， 导致最后一步测试，实质上对应的是一步到位处理超过一种的新加入的情况，无法延续现有的代码继续修改以通过测试。&lt;/p&gt;
&lt;p&gt;现在的问题转换为“如何写出下一个测试”，请接着读4.3。&lt;/p&gt;
&lt;h3 id=&#34;43简化问题场景-逐步添加限制条件&#34;&gt;4.3.简化问题场景-&amp;gt;逐步添加限制|条件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问：我无法写出下一个测试，卡壳了&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;答：接着上一步测试的目的，继续分析需求，我们走到哪了？或者我们应该换个思路重新分析需求？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资料：&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;2.，&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;文章中间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;When faced with a problem you do not understand, do any part of it you do understand,
then look at it again.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;给出的引用，来自一部科幻小说。下面我要写的是我根据文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;和其他kata解决需求的思路悟出的门路， 总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要按步骤1-2-3线性流程切分需求，而是按套娃，
从理想的简单状态机（简单输入简单处理输出|复杂输入简化处理输出）到有条件|限制的复杂状态机（复杂处理+复杂输入|输出），
一步步完善处理逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你手边有《计算机网络》这类书，看看每个层的第一个教学使用的理论协议的假设条件有多理想，以数据链路层的协议为例： 单工，发送方和接收方的网络层总是准备就绪，数据处理不计时间， 可用缓存无限大，信道不会在物理层损坏|丢失。
这种理想协议只会在教科书上存在，但它形象地描述了该层协议 &lt;em&gt;可能的风险|考量&lt;/em&gt; 。 之后的篇幅逐渐引入各种机制来解决理想协议中忽略的考量，最终一个能在现实场景中使用的协议完成了。&lt;/p&gt;
&lt;p&gt;咱们的测试也应该像设计协议一样，每次只测试一个考量|一种情况， 修改少量代码通过这个测试，接着向下走，直到考虑了所有情况。&lt;/p&gt;
&lt;p&gt;正确实例：文章&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;后半段，“我”针对“字符串按位换行”需求，先考虑了没有空白符的“纯”字符串简单情况，然后因为引入空白符， 多增加了三种情况（分割点在空白符左、相同、右），多写三个测试并修改代码通过它们，最终完成了逻辑。&lt;/p&gt;
&lt;h2 id=&#34;参考文章因渲染问题跑到了最下面&#34;&gt;参考文章（因渲染问题跑到了最下面）&lt;/h2&gt;
&lt;h2 id=&#34;2021-03-11更新&#34;&gt;2021-03-11更新&lt;/h2&gt;
&lt;p&gt;我对TDD有了新的理解：TDD对新手来说比较难以实践，不建议新手去用。有以下几点理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写测试速度很难跟上思考速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TDD本质上是把对方法|函数的功能的要求编进测试用例，要求是思考形成的， 
如果对编程语言（＆第三方测试框架）不是如母语一样熟悉，
写测试的速度跟不上思考的速度，就需要阻塞思考，慢慢写出一个个测试用例。&lt;/li&gt;
&lt;li&gt;就像阻塞快速的CPU去做慢速的I/O一样，更惨的是不是人人都是周伯通，
手脑协调同时只能做一件事， 所以不能引入一个终端机制去并行思考&amp;amp;写测试）。&lt;/li&gt;
&lt;li&gt;阻塞思考不仅痛苦还会打断思路，而且编程速度很慢，不利于完成工作。&lt;/li&gt;
&lt;li&gt;解决这个问题，或者提高写测试速度（I/O速度）；或者科幻一些，
借助机器（引入数据通道辅助I/O），比如哪天出现一个自然语言的测试框架，
写英文就能生成对应测试用例，或者脑机接口之类。唉，暂时不可求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试用例是否能体现功能需求与测试是否通过无关，不可强求测试覆盖率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极端例子：&amp;hellip;; assertThat(1，is(1)); 上述用例在计算覆盖率时照常计算，但实际上什么都没有测出来。&lt;/li&gt;
&lt;li&gt;类比网络安全上的常识“虚假的安全感比没有安全感更致命”，
虚假的单元测试覆盖率和绿色的测试通过标记比没有一丁点单元测试同样致命。&lt;/li&gt;
&lt;li&gt;我想说的是，如果强行遵守TDD（意味着无论测试质量如何都会统计出高测试覆盖率）
或者不遵守TDD但有强制的单元测试覆盖率要求，有时对项目伤害更大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有专业全面的测试环节，单元测试的价值会打个折扣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这不是我的见解，我认为&lt;a href=&#34;https://twitter.com/iamshaynez/status/1357606576396275713&#34;&gt;他说得有些道理(推特thread)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但我认为对复杂逻辑的测试该写还是写，因为单元测试就是为开发时即时测试而存在的，和QA两码事。
即使QA发现bug提出工单，你改好了，但下次重构时又 不能&amp;amp;没权限&amp;amp;不方便 即时地把历史工单的测试用例全跑一遍，不踏实。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单逻辑犯错概率很小，没有写测试的必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举个例子，为了打log而写的try-catch(-catch&amp;hellip;)逻辑，
我会把try中的逻辑单独重构成方法，
那么专门对该单纯的try-catch包装方法写测试就比较鸡肋，
如果写测试速度不够快，认真读两遍代码看看异常类的名是否写对更快些。&lt;/li&gt;
&lt;li&gt;（如果throw的方法在try中的逻辑内调用好几层深，或者catch内涉及修改对象状态的“异常时处理”操作，
写个测试用例比较好，保证确实这类异常会被这里的catch抓住而不是被内部的catch抓住，进而触发处理操作。
（比如Java Spring @Transaction 注解，就隐性地要求必须把异常抛出该注解修饰的方法，才能启动回滚，
内部的打log catch要在最后把异常再throw出去。））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要承认，如果真的能同时：1.测试质量高 2.测试覆盖率高，那么这种单元测试的价值非常大。
可惜现实情况往往是没经验满足1，没时间满足2，而且不满足1还反而有害。&lt;/p&gt;
&lt;p&gt;我现在的实践是（我们团队对单元测试没要求），要写用例就用多种assert努力体现完备的功能要求，写不出|懒不想写就干脆不写。
编写完功能代码，针对其中我认为的“复杂(变成自动机它中间状态比较多)”方法
（相对的是“惰性”的一目了然的方法：简单的异常处理，类似构造器的接参数builder方法&amp;hellip;）
写单元测试（简单的边界，null，正常），不在意覆盖率，单纯地“为了当前开发而测试”，如果能方便到以后的重构就更好啦。
（不要和“编程为了长远，只是运行刚好满足于现在的需求”准则弄混，那是描述功能设计而不是单元测试的准则。）&lt;/p&gt;
&lt;h2 id=&#34;2021-04-30更新&#34;&gt;2021-04-30更新&lt;/h2&gt;
&lt;p&gt;说实话，3月时我写下上面的补丁的内容，以提供反面的观点，但心中仍留有疑惑：
我到底该对TDD持有怎样的态度？我该如何使用其中好的思想并避开麻烦的实践过程？
《程序员修炼之道(第2版)》中谈到的关于测试的观点让我倍受启发，
我忍不住大段大段地把内容抄写在这里，以弥补与融合上面两部分中对TDD的支持与反对的观点，使之形成整体的观点。
因抄写字数太多，我不会使用格式标记抄写的段落，反过来，下面我说的话会使用&lt;em&gt;斜体&lt;/em&gt;标记。
有时会抄写原文，有时会把原本不同位置的表达同概念的单句组合在一起，有时改写难以理解的表达，
省略描述书中举例，我尽量将书中的想表达的观点呈现出来。
当然，推荐你找到本书并从“&lt;strong&gt;第7章-41节-为编码测试&lt;/strong&gt;”开始阅读原文，这书没阅读门槛，很值得一读。
嗯，版权问题&amp;hellip;&amp;hellip;我想两位作者不会因为这个来找我的，我们都想让更多人了解到更务实的工作方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;41-为编码测试&#34;&gt;41 为编码测试&lt;/h3&gt;
&lt;p&gt;我们认为“为了找bug|确保代码工作正常而编写测试”是错误的观点。&lt;/p&gt;
&lt;h4 id=&#34;提示66-测试与找bug无关&#34;&gt;提示66 测试与找bug无关&lt;/h4&gt;
&lt;p&gt;我们相信，测试获得的主要好处发生在你考虑测试及编写测试的时候，而不是运行它的时候。
当你开始编写新功能，你不知道怎么去写业务逻辑，这时可以提前考虑一下测试：
假设你已经写完了业务逻辑，准备补单元测试了。
&lt;em&gt;想想你要怎么测试业务逻辑？怎么划分每个测试方法的范围？你的代码需要注入什么依赖模块来模拟真实环境？能够控制哪些依赖模块以模拟不同情况？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从考虑测试开始，在不写一行代码的情况下，你已经有了对业务逻辑每个公开方法的方法签名（API）要求的发现，并设计了API。
考虑测试使我们减少了代码中的耦合
（与其他代码紧耦合的函数或方法很难进行测试，因为你必须在运行方法之前设置（&lt;em&gt;mock&lt;/em&gt;）好所有环境，让你的东西可测试也减少了它的耦合），
并增加了灵活性（&lt;em&gt;我们想在测试时自由地控制依赖模块来模拟不同情况，这要求业务逻辑的API所接受的参数范围要广&lt;/em&gt;）。
为公开方法写测试的考虑过程， 使我们得以从外部看待这个方法，这让我们看起来是方法的客户（&lt;em&gt;调用者&lt;/em&gt;）而不是作者。&lt;/p&gt;
&lt;h4 id=&#34;提示67-测试是代码的第一个用户&#34;&gt;提示67 测试是代码的第一个用户&lt;/h4&gt;
&lt;p&gt;我们认为，“&lt;strong&gt;测试所提供的反馈至关重要，可以指导编码过程&lt;/strong&gt;”，这是测试的最大好处。
在你对一个东西做测试前，必须先理解它在干嘛。
现实中我们刚开始编写代码时，只能基于对必须要做的事的模糊理解，&lt;em&gt;边写边理解边解决新出现的要求（错误处理，边界，isNull etc）&lt;/em&gt;，
最后代码总量比真正干事的逻辑大好几倍，里面充斥了条件逻辑与错误处理。&lt;em&gt;这时再写测试就不好分辨整个代码真正在干什么了。&lt;/em&gt;
如果你在开始编码前，就考虑过测试边界条件及其工作方式（&lt;em&gt;不同情况的分类处理&lt;/em&gt;），&lt;em&gt;那么你可能会发现简化条件逻辑的方案&lt;/em&gt;。
如果考虑需要测试的引发错误的条件，&lt;em&gt;那么你将会有意构造对应的错误处理逻辑&lt;/em&gt;。&lt;/p&gt;
&lt;h5 id=&#34;测试驱动开发&#34;&gt;测试驱动开发&lt;/h5&gt;
&lt;p&gt;我们看到TDD的好处，只要遵守流程，代码始终都有测试，你也将一直处于思考测试的状态。
我们也看到人们成为TDD的奴隶：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花费过多时间确保100%测试覆盖率&lt;/li&gt;
&lt;li&gt;做了很多冗余（&lt;em&gt;无用&lt;/em&gt;）的测试 
（&lt;em&gt;书中举例：刚开始编写方法时，对一个特定测试值（这是从特例到公式的必要一步TDD步骤）， 编写之后显著会重复|重写的AD-HOC逻辑&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;TDD的设计从底层开始，然后逐步上升。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;tdd你需要知道该去何方&#34;&gt;TDD：你需要知道该去何方。&lt;/h5&gt;
&lt;p&gt;“小步前行”被吹捧为TDD的一个优点，但这可能会误导你，它鼓励人们专注于不断优化简单的问题，而忽略编码的真正动因（&lt;em&gt;解决需求！&lt;/em&gt;）。
&lt;em&gt;书中案例：罗恩·杰弗里斯的数独程序系列博客，进行多次重构后满意，最终放弃了项目。&lt;/em&gt;
按顺序阅读博客很有趣，可以看到一个聪明人是如何被通过测试的喜悦套牢，开始为琐事（&lt;em&gt;不断想着重构&lt;/em&gt;）而分心。&lt;/p&gt;
&lt;h4 id=&#34;提示68-既非自上而下也非自下而上基于端对端构建程序&#34;&gt;提示68 既非自上而下，也非自下而上，基于端对端构建程序&lt;/h4&gt;
&lt;h5 id=&#34;自上而下与自下而上之争以你该用的方式去做&#34;&gt;自上而下与自下而上之争，以你该用的方式去做&lt;/h5&gt;
&lt;p&gt;计算机领域初期有两种程序设计学派：自上而下与自下而上。
但两个学派都没成功，因为它们都忽略了：刚开始（&lt;em&gt;即设计阶段&lt;/em&gt;）没人知道要做什么。
自上而下要求提前知晓需求，这不可能。
自下而上假设从小到大构造抽象层最终实现需求，但不知需求就无法划分功能边界。&lt;/p&gt;
&lt;p&gt;我们坚信，构建软件的唯一方法是增量式的。构建端到端功能的小块，一边工作一边了解问题。
应用学到的知识充实代码，让客户参与每一步并让他们指导这个过程。
测试对开发的驱动绝对有帮助，但是，就像每次开车一样，除非心里有一个目的地，
否则就可能到处兜圈子。&lt;/p&gt;
&lt;h4 id=&#34;提示70-要对软件做测试否则只能留给用户去做&#34;&gt;提示70 要对软件做测试，否则只能留给用户去做&lt;/h4&gt;
&lt;p&gt;毫无疑问测试是编程的一部分，不该留给其他部门的人去做（&lt;em&gt;测试部门算其他部门吗？&lt;/em&gt;）。
测试、设计、编码————都是在编程。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好了，抄完了，你应该能读到两位作者的心思：按照TDD的思路在编码前考虑测试有好处，但并不是必须要遵守TDD流程来实践才能获得这个好处。
那么我再抄一段作者在书中的调侃作为本次补丁的结尾吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;忏悔&lt;/p&gt;
&lt;p&gt;我，Dave，因告诉别人自己不再编写测试，而大出风头。这样做的部分原因是想动摇那些把测试变成宗教的人的信仰。
这样说的部分原因是，这（某种程度上）是真的。&lt;/p&gt;
&lt;p&gt;我已经编写了45年的代码，30多年中我都写了自动化测试。构思写测试，已经成了我编码方式的一部分&amp;hellip;
我决定停止编写测试几个月，看看代码会出什么事。令人惊讶的是，影响“不是很大”，我花了一些时间来找出原因。&lt;/p&gt;
&lt;p&gt;我相信这个原因是，（对我来说）测试的好处更主要来自思考测试，以及思考测试对对代码造成的影响。
在长时间坚持这么做后，我写不写测试都会这样思考。代码仍是可测试的，只是无须真的写出来测试。&lt;/p&gt;
&lt;p&gt;&amp;hellip;测试也是与其他开发人员交流的一种方式，所以我开始会在与他人共享代码时为其编写测试，或给有外部依赖的事情写测试。&lt;/p&gt;
&lt;p&gt;Andy说我不应该加上这个知识栏，他担心这会诱使缺乏经验的开发人员不写测试。下面是我的折衷方案：&lt;/p&gt;
&lt;p&gt;应该编写测试吗？要，但等你写了30年后，不妨从容地做些实验，看看它究竟给你带来的什么好处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;https://en.wikipedia.org/wiki/Test-driven_development&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&#34;&gt;https://softwareengineering.stackexchange.com/questions/224711/tdd-workflow-for-implementation-specific-edge-cases&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&#34;&gt;https://silkandspinach.net/2014/06/02/tdd-three-easy-mistakes/&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&#34;&gt;http://thecleancoder.blogspot.com/2010/10/craftsman-62-dark-path.html&lt;/a&gt; &lt;a href=&#34;https://boholder.github.io/blogs/tdd-tips-zh/#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Java实现大整数排列组合，解决抽卡欧气计算问题</title>
                <link>https://boholder.github.io/blogs/java_arrangement_combination_zh/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/java_arrangement_combination_zh/</guid>
                <pubDate>Sat, 27 Jul 2019 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h1 id=&#34;heading&#34;&gt;&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近玩的某游戏开了新卡池，抽了8个10连共计80次，&lt;br&gt;
出了4个稀有度最高的角色，&lt;br&gt;
我突发奇想想算算我这个爆率算什么水平，&lt;br&gt;
程序模拟一下，顺便复习排列组合。&lt;/p&gt;
&lt;h2 id=&#34;程序设计&#34;&gt;程序设计&lt;/h2&gt;
&lt;p&gt;Java标准类库中，没有排列组合甚至阶乘的现成方法，  &lt;a href=&#34;https://stackoverflow.com/questions/891031/is-there-a-method-that-calculates-a-factorial-in-java&#34;&gt;搜了一下&lt;/a&gt;&lt;br&gt;
但为了这个引入一个第三方库又未免太麻烦，于是自己来实现。&lt;/p&gt;
&lt;p&gt;实现第一想到的是int和long两个基本类型，&lt;a href=&#34;https://www.iteye.com/blog/ly5633-1219408&#34;&gt;但想了想发现有坑&lt;/a&gt; ：int最多12！，long最多到20！&lt;br&gt;
这可不行，我这都80抽了。&lt;br&gt;
于是换Java的BigDecimal类（大整数）。&lt;/p&gt;
&lt;p&gt;问题换算成伪代码是这样：&lt;br&gt;
res=0&lt;br&gt;
res += c(n, i) *  爆率^i *  (1 - a)^(n-i) 	(i=a~b,i为整数)&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
import java.math.BigDecimal;

public class factorial {

	public static void main(String[] args) {

		// 出货率2.5%
		double a = 0.025d;
		int n = 80;
		// result
		double res = 0;
		double res2 = 0;

		for (int i = 0; i &amp;lt; 5; i++) {
			res2 += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;0~4: &amp;quot; + res2);

		for (int i = 4; i &amp;lt; n + 1; i++) {
			res += c(n, i).longValue() * Math.pow(a, i) * Math.pow(1 - a, n - i);
		}
		System.out.println(&amp;quot;4~80: &amp;quot; + res);
	}

	// n!
	public static BigDecimal n(int n) {
		if (n == 0)
			return new BigDecimal(0);

		BigDecimal result = new BigDecimal(1);
		BigDecimal a;
		for (int i = 2; i &amp;lt; n + 1; i++) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/m!
	public static BigDecimal n2m(int n, int m) {

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// n!/(n-m)! === a(n,m)
	public static BigDecimal a(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);

		BigDecimal result = new BigDecimal(n);
		BigDecimal a;
		for (int i = n - 1; i &amp;gt; n - m; i--) {
			a = new BigDecimal(i);
			result = result.multiply(a);
		}
		return result;
	}

	// c(n,m) === a(n,m)/(m)!
	public static BigDecimal c(int n, int m) {
		if (m == 0)
			return new BigDecimal(1);
		if (m == n)
			return new BigDecimal(1);

		// 优化计算，避免大除大
		if (m &amp;gt; n / 2)
			return n2m(n, m).divide(n(n - m));
		else
			return a(n, m).divide(n(m));
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;结果结论&#34;&gt;结果&amp;amp;结论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0~4:  0.8176930694561881&lt;/li&gt;
&lt;li&gt;4~80:  0.14056818112756556&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽80次，出0~4次货的概率 高达94.9%、&lt;br&gt;
出4次及以上的概率为 14%，其中出4次占9%&lt;br&gt;
这样一看我还行，乐上加乐，没钱人的开心就是这么简单。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/programming/">programming</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/java/">java</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/programming/">programming</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>HTTP cookie的安全性、安全使用方法和攻击防御手段</title>
                <link>https://boholder.github.io/blogs/cookie_security_zh/</link>
                <guid isPermaLink="true">https://boholder.github.io/blogs/cookie_security_zh/</guid>
                <pubDate>Sat, 18 May 2019 00:00:00 &#43;0000</pubDate>
                
                    <author>bottleholder@anche.no (BoHolder)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文将把，截至2019-05-18的，从互联网上搜集到&lt;/p&gt;
&lt;p&gt;（&amp;ldquo;cookie+security&amp;rdquo;-&amp;gt;Google与StartPage前两页结果为源+相关学术文献）的,&lt;br&gt;
有关Cookie标准与用法、cookie安全性的信息，汇总索引，以方便读者学习了解相关信息。&lt;/p&gt;
&lt;p&gt;本文需要读者对计算机网络有大致了解，&lt;br&gt;
没有了解也可以，术语会挂上解释链接，但阅读体验就比较差了。&lt;/p&gt;
&lt;p&gt;小段英文的翻译交给谷歌处理。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;p&gt;2部分与3部分的解决方案部分有重复，&lt;br&gt;
但我认为还是把攻防和开发分开，缺陷与解决结合，比较方便阅读。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#what-is-cookie&#34;&gt;Cookie是什么&amp;amp;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#security-risk-in-design-and-use-and-solution&#34;&gt;设计、使用中的安全隐患以及相应改进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#attack-on-cookies-and-solution&#34;&gt;针对cookie窃取的攻击与相应防御&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#academic-discussion-about-cookies&#34;&gt;学术讨论涉及cookie的攻防&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boholder.github.io/blogs/cookie_security_zh/#summary&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;what-is-cookie&#34;&gt;What is cookie&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.Cookie是什么&amp;amp;用法&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;
&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34;&gt;维基百科&lt;/a&gt; 还是蛮丰富的，中文维基简单点，可以看&lt;a href=&#34;https://baike.baidu.com/item/cookie/1119&#34;&gt;百度百科&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RFC：&lt;a href=&#34;https://tools.ietf.org/html/rfc2109&#34;&gt;rfc2109-1997&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc2965&#34;&gt;rfc2965-2000&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://tools.ietf.org/html/rfc6265&#34;&gt;rfc6265-2011&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-ietf-httpbis-rfc6265bis/&#34;&gt;rfc6265bis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&#34;&gt;https://hc.apache.org/httpcomponents-client-ga/tutorial/html/statemgmt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在最新的定义cookie的RFC2965上，是这么说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;we will use the term cookie to refer to the state&lt;br&gt;
information that passes between an origin server and user agent,&lt;br&gt;
and that gets stored by the user agent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将使用术语cookie来指代在源服务器和用户代理之间传递的状态信息，&lt;br&gt;
以及由用户代理存储的状态信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单总结，cookie是：服务器与客户端间标识状态的信息，储存在客户端&lt;br&gt;
（硬盘或内存，视类型而定），由服务器增删改读。&lt;br&gt;
用途：满足对无状态的HTTP协议，想让它&lt;strong&gt;有状态&lt;/strong&gt;的需求，一种修补措施。&lt;/p&gt;
&lt;p&gt;比如一个服务器，需要同时与多个客户端通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为HTTP协议@的无连接性，所以需要一个额外方法区分不同客户端。&lt;/li&gt;
&lt;li&gt;然后因为计算机网络的网络层路由有&lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR-无类域间路由&lt;/a&gt;、&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation&#34;&gt;NAT-网络地址转换&lt;/a&gt; 这类协议存在，&lt;br&gt;
服务器不能单靠记录IP或者MAC这些HTTP包里的信息标识每一个客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此Netscape Draft在1994年率先定义了cookie这一解决方案&lt;br&gt;
（此处apache.org的原文链接好像失效了），之后被整理成rfc2109。&lt;/p&gt;
&lt;p&gt;cookie可以用来干什么？&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Uses&#34;&gt;维基&lt;/a&gt; 给了三个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会话管理&lt;/li&gt;
&lt;li&gt;个性化定制 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zombie_cookie&#34;&gt;wikipedia-Zombie cookie （有点意思）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;格式用法&#34;&gt;格式&amp;amp;用法&lt;/h3&gt;
&lt;p&gt;一个cookie由一个键值对（key=value）组成，同时在&lt;em&gt;被设置时&lt;/em&gt; 会附加一些变量（attributes），&lt;br&gt;
这些变量用来控制该cookie的使用方法。&lt;/p&gt;
&lt;p&gt;想了解详细属性，看&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt; ，&lt;br&gt;
找不到新鲜的全面的中文材料，有个不错的&lt;a href=&#34;https://imququ.com/post/host-only-cookie.html#toc-3&#34;&gt;博客@Jerry Qu&lt;/a&gt; ，但是是13年的。&lt;/p&gt;
&lt;p&gt;比如，我们时常听闻的第三方cookie，在设置时会标一个&lt;code&gt;Third-party&lt;/code&gt;属性，&lt;br&gt;
表明这是从非当前网站（URL框里的网站）设置的。&lt;/p&gt;
&lt;p&gt;当一个网站有引用（&amp;lt;img&amp;gt;&amp;hellip;）其他网站，比如广告网站的广告资源时，&lt;br&gt;
浏览器加载该网站时，也会向广告网站发GET请求，&lt;br&gt;
第三方cookie就随着资源一起来到了浏览器上。&lt;/p&gt;
&lt;p&gt;对cookie的操作不再赘述，有需请自取。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&#34;&gt;https://en.wikipedia.org/wiki/HTTP_cookie#Implementation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2&#34;&gt;https://tools.ietf.org/html/rfc6265#section-4.2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;security-risk-in-design-and-use-and-solution&#34;&gt;Security risk in design and use and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.Cookie设计与使用中的安全隐患，以及相应改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie安全性这点，&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-8&#34;&gt;rfc6265中有一整段(8. Security Considerations)&lt;/a&gt; 去阐述，&lt;br&gt;
务必读一下，总结的很好，我会跳过那些内容，只给出一个目录以供预览。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分标题&lt;/th&gt;
&lt;th&gt;简述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Overview&lt;/td&gt;
&lt;td&gt;总览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ambient Authority&lt;/td&gt;
&lt;td&gt;cookie是一种权限凭证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clear Text&lt;/td&gt;
&lt;td&gt;明文传输问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Session Identifiers&lt;/td&gt;
&lt;td&gt;非可读的会话标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Weak Confidentiality&lt;/td&gt;
&lt;td&gt;cookie在各种层面保密性都弱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reliance on DNS&lt;/td&gt;
&lt;td&gt;cookie的安全性以DNS安全为前提&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;与其说其设计不周全，不如说cookie因本身位置的限制无法保证设计安全，&lt;br&gt;
rfc还警告开发人员不要把cookie作为唯一的认证环节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265: In addition, by default, cookies do not provide confidentiality or integrity&lt;br&gt;
from network attackers, even when used in conjunction with HTTPS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;此外，默认情况下，cookie不会为网络攻击者提供机密性或完整性，&lt;br&gt;
即使与HTTPS结合使用也是如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1服务器只能读取cookie键值对读不到属性&#34;&gt;1.服务器只能读取cookie键值对，读不到属性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
Notice that the cookie attributes are not returned.&lt;br&gt;
In particular,the server cannot determine from the Cookie header alone&lt;br&gt;
when a cookie will expire, for which hosts the cookie is valid,&lt;br&gt;
for which paths the cookie is valid, 
or whether the cookie was set with the Secure or HttpOnly attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-4.2.2&#34;&gt;rfc6265#section-4.2.2&lt;/a&gt; :&lt;br&gt;
请注意，不返回cookie属性。特别是，当cookie过期时，&lt;br&gt;
服务器无法单独从Cookie标头确定，cookie对哪些主机有效，cookie的路径有效，&lt;br&gt;
或者cookie是否使用Secure或HttpOnly属性设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时在设置cookie时，客户端并不会发回结果反馈。这使得服务器不知道cookie是否被正确设置。&lt;br&gt;
这等于要从数据库读一个不知道是否干净的数据，对数据完整性有影响。&lt;/p&gt;
&lt;h4 id=&#34;解决服务器容错与键名走私smuggle&#34;&gt;解决：服务器容错与键名“走私（Smuggle）”&lt;/h4&gt;
&lt;p&gt;大多数情况下，可以用服务器逻辑容错。&lt;br&gt;
&lt;a href=&#34;https://www.owasp.org/images/a/a0/OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf&#34;&gt;OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson&lt;/a&gt;&lt;br&gt;
此报告提供了在cookie名里添加“私货”以标识属性的方法，&lt;br&gt;
比如一个cookie设置了属性&lt;code&gt;http-only&lt;/code&gt;，名字就加个前缀HTTP_ONLY_。&lt;/p&gt;
&lt;h3 id=&#34;2-domainpath属性影响完整性&#34;&gt;2. “Domain”“Path”属性影响完整性&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.3&#34;&gt;rfc6265-两个属性的设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.1.2&#34;&gt;rfc6265-两个属性在客户端的处理算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不贴原文了，简单地总结（参照维基）：&lt;/p&gt;
&lt;h4 id=&#34;path-是指域名host下的路径归属&#34;&gt;&lt;code&gt;Path&lt;/code&gt; 是指域名|Host下的路径归属。&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;比如两网站&lt;code&gt;example.com/site1/index.htm&lt;/code&gt;,&lt;code&gt;example/com/site2/index.htm&lt;/code&gt;，&lt;br&gt;
设置Path属性为&lt;code&gt;/site1&lt;/code&gt;,&lt;code&gt;/site2&lt;/code&gt;两个值以分离两个目录中的页面的cookie。&lt;/li&gt;
&lt;li&gt;有些网站的不同目录是运行不同功能的，比如两个朋友共租一个域名运营博客，用上述方式划分。&lt;br&gt;
通过这种方式可以做到分离两个博客的cookie。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起来很好，但稍有不慎（或故意为之），就可以用来绕过&lt;a href=&#34;https://en.wikipedia.org/wiki/Same-origin_policy&#34;&gt;SOE-同源策略&lt;/a&gt; 。&lt;br&gt;
比如，设置path成&lt;code&gt;/&lt;/code&gt;，好，域名下所有页面都能读该cookie了。&lt;/p&gt;
&lt;p&gt;这是一种减少网站开发人员工作量的窍门，也能被攻击者用来做窃取cookie的手段。&lt;/p&gt;
&lt;h4 id=&#34;domain-是指域名归属&#34;&gt;&lt;code&gt;Domain&lt;/code&gt; 是指域名归属。&lt;/h4&gt;
&lt;p&gt;它和&lt;code&gt;Path&lt;/code&gt;属性的缺点差不多类型，设置了&lt;code&gt;Domain&lt;/code&gt;的cookie是&lt;strong&gt;默认暴露给所有子域名&lt;/strong&gt;的。&lt;br&gt;
我们都知道，同域名不一定等于同服务器IP，所以攻击者可以劫持域名解析偷cookie。 &lt;br&gt;
因为这个原因，实际开发中一般不建议设置&lt;code&gt;Domain&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4 id=&#34;解决samesite-属性2016年不设置domain属性&#34;&gt;解决：&lt;code&gt;SameSite&lt;/code&gt; 属性(2016年)&amp;amp;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h4&gt;
&lt;h5 id=&#34;samesite&#34;&gt;&lt;code&gt;SameSite&lt;/code&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Same-site_cookie&#34;&gt;维基#Same-site_cookie&lt;/a&gt;:&lt;br&gt;
In 2016 Google Chrome version 51 introduced a new kind of cookie, the same-site cookie,&lt;br&gt;
which can only be sent in requests originating from the same origin as the target domain.&lt;br&gt;
This restriction mitigates attacks such as cross-site request forgery (XSRF).&lt;br&gt;
A cookie is given this characteristic by setting the SameSite flag to Strict or Lax.&lt;br&gt;
&lt;a href=&#34;https://tools.ietf.org/html/draft-west-first-party-cookies-07&#34;&gt;google：draft-ietf-httpbis-cookie-same-site &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年，谷歌Chrome版本51引入了一种新型cookie，即同一站点的cookie，&lt;br&gt;
只能在源自与目标域相同的源的请求中发送。此限制可缓解诸如跨站点请求伪造（XSRF）等攻击。&lt;br&gt;
通过将SameSite标志设置为Strict或Lax，可以为cookie提供此特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标准支持：截至撰文时间(2019-05)，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发支持：查到的是node.js的express、PHP7.3支持，应该还有没搜到的&lt;/li&gt;
&lt;li&gt;浏览器支持：几个主流浏览器，的新版本都已支持，不再列举名字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lambdatest.com/SameSite-cookie-attribute&#34;&gt;Browser Compatibility Testing of &amp;lsquo;SameSite&amp;rsquo; cookie - LambdaTest&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;不设置domain属性&#34;&gt;不设置&lt;code&gt;Domain&lt;/code&gt;属性&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/12387338/what-is-a-host-only-cookie&#34;&gt;Stack over flow-What is a host only cookie?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之所以不设置&lt;code&gt;Domain&lt;/code&gt;属性，其实是为了激活&lt;code&gt;host-only-flag&lt;/code&gt;，&lt;br&gt;
&lt;strong&gt;当host-only-flag被设置，子域名无法访问此cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.3&#34;&gt;rfc6265-5.3.  Storage Model&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3对cookie的误用&#34;&gt;3.对cookie的误用&lt;/h3&gt;
&lt;p&gt;上面算是设计问题，下面是多数文章主要讲的，开发者对cookie的误用。&lt;/p&gt;
&lt;h4 id=&#34;http-明文传递-cookie&#34;&gt;①http 明文传递 cookie&lt;/h4&gt;
&lt;p&gt;cookie默认不加密传输，可以在传输中被坏家伙窃听或修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：设置&lt;code&gt; Secure&lt;/code&gt;属性&amp;amp;cookie加密和签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2.5&#34;&gt;rfc6265-5.2.5.  The Secure Attribute&lt;/a&gt;&lt;br&gt;
&lt;code&gt;Secure&lt;/code&gt;属性保证cookie只在HTTPS环境下可被传输。&lt;/p&gt;
&lt;p&gt;和数据库设计一样，为了保险，应尽量减少数据中非必须的信息量。&lt;br&gt;
cookie值可以是随机生成的字符串（会话凭证）而不是具体信息，&lt;br&gt;
在下次登录时修改，以应对cookie窃取与重放攻击。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rfc6265:&lt;br&gt;
Servers SHOULD encrypt and sign the contents of cookies&lt;br&gt;
(using whatever format the server desires) when transmitting them to the&lt;br&gt;
user agent (even when sending the cookies over a secure channel).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当将服务器传输给用户代理时，服务器应该对cookie的内容进行加密和签名&lt;br&gt;
（使用服务器所需的任何格式）（即使通过安全通道发送cookie）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;cookie-默认可被客户端apijs-etc读取&#34;&gt;②cookie 默认可被客户端API(JS etc)读取&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;解决：设置时加 &lt;code&gt;Http-only-flag&lt;/code&gt; ，禁止客户端JS读取cookie。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;错误规划max-ageexpires&#34;&gt;③错误规划&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265#section-5.2&#34;&gt;rfc6265-The Set-Cookie Header&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准太长，简单总结：&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt;: 类似TTL，以秒计，到时删除。&lt;br&gt;
&lt;code&gt;expires&lt;/code&gt;: GMT时间字符串（Wed, 09 Jun 2021 10:18:14 GMT）,到时删除。&lt;br&gt;
&lt;code&gt;max-age&lt;/code&gt; 是 &lt;code&gt;expires&lt;/code&gt; 的一个补充性属性。没有这两个属性，cookie被视为&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Session_cookie&#34;&gt;session cookie&lt;/a&gt; 。&lt;br&gt;
cookie保留在客户端的时间越长，被攻击的可能性越高。&lt;/p&gt;
&lt;h4 id=&#34;解决谨慎设计max-ageexpires的值&#34;&gt;解决：谨慎设计&lt;code&gt;max-age&lt;/code&gt;、&lt;code&gt;expires&lt;/code&gt;的值&lt;/h4&gt;
&lt;p&gt;越敏感的数据，越要设置时间短，保持用户频繁认证。&lt;/p&gt;
&lt;h2 id=&#34;attack-on-cookies-and-solution&#34;&gt;Attack on cookies and solution&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3.针对cookie窃取的攻击与相应防御&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下所有攻击手段，都能单独拉出来写好多篇技术报告|分享，&lt;br&gt;
很明显本文没有这个篇幅，因此本文征求做到全而不详，并附链接以供详求。&lt;/p&gt;
&lt;h3 id=&#34;为什么我们要攻击保护cookie&#34;&gt;为什么我们要攻击|保护cookie？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://odino.org/security-hardening-http-cookies/&#34;&gt;这篇文章&lt;/a&gt; 的一段话讲得不错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Because the data they contain is, more often than not, extremely sensitive&lt;br&gt;
— cookies are generally used to store session IDs or access tokens,&lt;br&gt;
an attacker’s holy grail.&lt;br&gt;
Once they are exposed or compromised, attackers can impersonate users,&lt;br&gt;
or escalate their privileges on your application.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为它们包含的数据通常非常敏感 - 通常用于存储会话ID或访问令牌，攻击者的圣杯。&lt;br&gt;
一旦他们暴露或受到攻击，攻击者就可以冒充用户，或者升级他们对您的应用程序的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常见攻击方式&#34;&gt;常见攻击方式&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie#Cookie_theft_and_session_hijacking&#34;&gt;维基百科&lt;/a&gt;总结了几种常见的攻击方式，包括攻击过程简介与防御手段，在此不复述，只提供目录。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;攻击&lt;/th&gt;
&lt;th&gt;防御&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;MITM&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DNS Poisoning&lt;/td&gt;
&lt;td&gt;TLS&amp;amp;&lt;code&gt;secure&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DOM-Based-XSS&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http-only-flag&lt;/code&gt;&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反射型XSS+恶意代理服务器&lt;/td&gt;
&lt;td&gt;&lt;code&gt;secure&lt;/code&gt;attr&amp;amp;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSRF&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SameSite&lt;/code&gt;attr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;还有一类维基没提到的，针对&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS协议&lt;/a&gt; 的攻击。&lt;br&gt;
TLS协议不是完全安全的，因为设计或实现的缺陷，&lt;br&gt;
已有不少在特定情况下针对TLS的攻击出现，&lt;br&gt;
主要目的是使HTTPS降为“等同于”HTTP的情况（即复原密文为明文），&lt;br&gt;
这不是一个新方向，列举几个比较有名的攻击方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.contextis.com/en/blog/server-technologies-https-beast-attack&#34;&gt;BEAST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lucky_Thirteen_attack&#34;&gt;Lucky 13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非常见方式&#34;&gt;非常见方式&lt;/h3&gt;
&lt;p&gt;非单一的、利用知识组合各种部分的针对cookie的攻击方式，&lt;br&gt;
可惜我只找到一个。&lt;/p&gt;
&lt;h4 id=&#34;cookiejacking-rosario-valotta-2011-05linkhttpssitesgooglecomsitetentacoloviolacookiejacking&#34;&gt;①cookiejacking-Rosario Valotta-2011-05&lt;a href=&#34;https://sites.google.com/site/tentacoloviola/cookiejacking&#34;&gt;[link]&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;该方法利用了IE浏览器的“跨域交互策略”的一个漏洞，&lt;br&gt;
外部HTML的&amp;lt;iframe&amp;gt;标签可以加载本地cookie文件（本应不能）。&lt;br&gt;
恶意服务器通过一系列正常的手段获知用于构造cookie路径的信息，&lt;br&gt;
然后通过此漏洞读取cookie，并利用&lt;a href=&#34;https://www.securitysift.com/who-do-you-trust-cross-domain-content-extraction-with-clickjacking/&#34;&gt;Clickjacking&lt;/a&gt; 手段传输cookie至服务器。&lt;br&gt;
因为读的是文件，任何cookie都会被窃取。&lt;/p&gt;
&lt;p&gt;微软&lt;a href=&#34;https://digitizor.com/cookiejacking-patch/&#34;&gt;6月&lt;/a&gt; 给这个漏洞打了补丁。&lt;br&gt;
至于Clickjacking，&lt;code&gt;x-frame-options&lt;/code&gt;&lt;a href=&#34;https://www.keycdn.com/blog/x-frame-options&#34;&gt;(XFO)&lt;/a&gt; 可以防止。&lt;/p&gt;
&lt;h2 id=&#34;academic-discussion-about-cookies&#34;&gt;Academic discussion about cookies&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于cookie的学术讨论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本来想把理论方面作为2、3段的添头，没想到专家们已经在纸头上打过一两轮攻防了。&lt;br&gt;
故单开此段，索引几个我觉得有意思的学术文献。&lt;/p&gt;
&lt;h3 id=&#34;cookie-masking-cookie-掩盖&#34;&gt;cookie masking-cookie 掩盖&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=2714592&#34;&gt;TLS Record Protocol: Security Analysis and&lt;br&gt;
Defense-in-depth Countermeasures for HTTPS&lt;/a&gt;&lt;br&gt;
Author: Olivier Levillain etc&lt;br&gt;
Time: 2015&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个研究总结了针对TLS记录协议的5个攻击方式，并给出了两个cookie掩盖方式：&lt;br&gt;
TLS Scramble &amp;amp; MCookies，以保证在意外导致HTTP明文传输的情况下，&lt;br&gt;
继续保持cookie等秘密信息机密性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/article/10.1007%2Fs12095-018-0280-y&#34;&gt;Statistical attacks on cookie masking for RC4&lt;/a&gt;&lt;br&gt;
Author: Kenneth G. PatersonEmail author etc&lt;br&gt;
Time: 2018-02&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文验证了上篇文章两种掩盖方式理论上可被加大提供算力后破解，&lt;br&gt;
因此该掩盖方式只能提供不强的机密性。&lt;/p&gt;
&lt;h3 id=&#34;测信道攻击&#34;&gt;测信道攻击&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-319-89641-0_11&#34;&gt;Path Leaks of HTTPS Side-Channel by Cookie Injection&lt;/a&gt;&lt;br&gt;
Author: Fuqing Chen etc&lt;br&gt;
Time: 2018-04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该文阐述了一种攻击方式和两种应用方面：&lt;br&gt;
利用cookie的弱同源策略（上文有提），实施cookie注入，&lt;br&gt;
用注入的cookie来推断敏感信息，进而复原一部分密文（比如请求的URL）。&lt;br&gt;
没看完，大概是利用当时浏览器的cookie路径匹配的算法的一个缺陷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-662-47854-7_6&#34;&gt;Protecting Encrypted Cookies from&lt;br&gt;
Compression Side-Channel Attacks&lt;/a&gt;&lt;br&gt;
Author: Janaka Alawatugoda etc&lt;br&gt;
Time: 2015-07&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有那么两种对TLS的攻击：&lt;a href=&#34;https://blog.qualys.com/ssllabs/2012/09/14/crime-information-leakage-attack-against-ssltls&#34;&gt;CRIME&lt;/a&gt; 和 &lt;a href=&#34;http://breachattack.com/&#34;&gt;BREACH&lt;/a&gt; （上文有提）,&lt;br&gt;
它们基于传输前压缩过程中产生的额外信息量，复现敏感信息，&lt;br&gt;
针对它们的常规解决方法是禁止传输中压缩，&lt;br&gt;
这意味着加大使用带宽资源。&lt;br&gt;
该文阐述了两种新的压缩方式，用于实现压缩并保护机密信息的功能。&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，关于此文，不包括素材阅读的，纯搜索时间，大概只有2小时多，&lt;br&gt;
因此即使是截至2019-05，此文大概还是遗漏了许多值得一提的部分，请读者海涵。&lt;/p&gt;
&lt;p&gt;其次，经过编写此文，作者对cookie的认识有了很大变化，认清了cookie能力是很有限的，&lt;br&gt;
以后编写web服务也会注意cookie的正确运用。希望各位读者也能从此文中学到知识。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/categories/computer-security/">computer-security</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/web-security/">web-security</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/cookie/">cookie</category>
                                
                            
                                
                                
                                
                                    <category domain="https://boholder.github.io/tags/blog/">blog</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
